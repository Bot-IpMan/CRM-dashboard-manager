<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Домашня CRM-панель</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-soft: rgba(99, 102, 241, 0.12);
            --accent: #22d3ee;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #0ea5e9;
            --bg: #f4f6fb;
            --surface: rgba(255, 255, 255, 0.95);
            --border: rgba(99, 102, 241, 0.08);
            --text: #0f172a;
            --text-muted: #64748b;
            --shadow: 0 20px 45px rgba(15, 23, 42, 0.08);
            --glass: rgba(255, 255, 255, 0.75);
            --radius-lg: 24px;
            --radius-md: 16px;
            --radius-sm: 12px;
            --dashboard-columns: auto-fit;
            --dashboard-card-min: 320px;
            --metrics-columns: auto-fit;
            --metric-card-min: 220px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(180deg, #f9fbff 0%, #eef2ff 100%);
            color: var(--text);
            min-height: 100vh;
        }

        h1, h2, h3, h4 {
            margin: 0;
        }

        p {
            margin: 0;
        }

        .app-layout {
            display: grid;
            grid-template-columns: 280px 1fr;
            min-height: 100vh;
        }

        .sidebar {
            background: linear-gradient(200deg, #111827 0%, #1e1b4b 100%);
            color: white;
            padding: 32px 28px 40px;
            display: flex;
            flex-direction: column;
            gap: 32px;
            position: sticky;
            top: 0;
            height: 100vh;
        }

        .sidebar::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top, rgba(99, 102, 241, 0.15), transparent 60%);
            pointer-events: none;
        }

        .sidebar-inner {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            gap: 32px;
            flex: 1;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .brand-logo {
            width: 48px;
            height: 48px;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.25) 0%, rgba(34, 211, 238, 0.25) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .brand h1 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .brand p {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }

        .nav-controls {
            display: grid;
            gap: 16px;
        }

        .nav-search {
            position: relative;
        }

        .nav-search input {
            width: 100%;
            padding: 12px 14px 12px 42px;
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.25);
            background: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 14px;
            outline: none;
            transition: border 0.2s ease, background 0.2s ease;
        }

        .nav-search input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .nav-search input:focus {
            border-color: rgba(255, 255, 255, 0.45);
            background: rgba(255, 255, 255, 0.14);
        }

        .nav-search i {
            position: absolute;
            top: 50%;
            left: 16px;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 15px;
        }

        .nav-filter {
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.25);
            padding: 10px 12px;
            background: rgba(15, 23, 42, 0.45);
            color: rgba(255, 255, 255, 0.85);
            font-size: 14px;
            outline: none;
        }

        .nav-filter:focus {
            border-color: rgba(255, 255, 255, 0.45);
        }

        .nav {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .nav-empty {
            display: none;
            padding: 14px 16px;
            border-radius: var(--radius-sm);
            border: 1px dashed rgba(255, 255, 255, 0.18);
            background: rgba(15, 23, 42, 0.45);
            color: rgba(255, 255, 255, 0.75);
            font-size: 13px;
            line-height: 1.5;
        }

        .nav-empty.is-visible {
            display: block;
        }

        .nav-group {
            display: grid;
            gap: 10px;
        }

        .nav-group + .nav-group {
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: 14px;
        }

        .nav-group-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(255, 255, 255, 0.55);
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 18px;
            border-radius: var(--radius-sm);
            border: 1px solid transparent;
            color: rgba(255, 255, 255, 0.85);
            font-weight: 500;
            font-size: 15px;
            background: transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-item.is-hidden {
            display: none;
        }

        .nav-group.is-collapsed {
            display: none;
        }

        .nav-item i {
            font-size: 18px;
        }

        .nav-item.active,
        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .nav-item.active {
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(18px);
        }

        .sidebar-footer {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .sidebar-stats {
            background: rgba(15, 23, 42, 0.55);
            padding: 18px;
            border-radius: var(--radius-md);
            display: grid;
            gap: 12px;
        }

        .sidebar-stats h4 {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
        }

        .sidebar-stats strong {
            font-size: 20px;
            color: white;
        }

        .btn {
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: 15px;
            font-weight: 500;
            border-radius: 12px;
            padding: 12px 18px;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            box-shadow: 0 18px 35px rgba(99, 102, 241, 0.35);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 20px 45px rgba(99, 102, 241, 0.45);
        }

        .btn-outline {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
        }

        .btn-outline:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-ghost {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
        }

        .main-content {
            padding: 36px 48px;
            position: relative;
            overflow-x: hidden;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 24px;
            margin-bottom: 32px;
        }

        .topbar h2 {
            font-size: 26px;
            font-weight: 600;
        }

        .topbar-sub {
            color: var(--text-muted);
            margin-top: 6px;
            font-size: 15px;
        }

        .topbar-actions {
            display: flex;
            align-items: center;
            gap: 18px;
        }

        .search-wrapper {
            position: relative;
        }

        .search-wrapper input {
            background: var(--surface);
            border-radius: 14px;
            border: 1px solid var(--border);
            padding: 12px 16px 12px 42px;
            width: 320px;
            box-shadow: var(--shadow);
            outline: none;
            font-size: 15px;
        }

        .search-wrapper i {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        .search-results {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            border: 1px solid rgba(99, 102, 241, 0.12);
            box-shadow: 0 25px 45px rgba(15, 23, 42, 0.12);
            padding: 16px;
            display: none;
            z-index: 20;
        }

        .search-results.active {
            display: block;
        }

        .search-group + .search-group {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed rgba(148, 163, 184, 0.3);
        }

        .search-group-title {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .search-result {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .search-result:hover {
            background: rgba(99, 102, 241, 0.08);
        }

        .search-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
        }

        .section {
            display: none;
            animation: fadeIn 0.2s ease;
        }

        .section.active {
            display: block;
        }

        .section-header {
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            gap: 24px;
            margin-bottom: 24px;
        }

        .section-header h2 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .section-header p {
            color: var(--text-muted);
            font-size: 15px;
        }

        .section-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(var(--metrics-columns, auto-fit), minmax(var(--metric-card-min, 220px), 1fr));
            gap: 18px;
            margin-bottom: 24px;
        }

        .metric-card {
            background: var(--surface);
            border-radius: var(--radius-md);
            padding: 20px;
            display: flex;
            gap: 16px;
            align-items: center;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .metric-icon {
            width: 54px;
            height: 54px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: var(--primary-dark);
            background: var(--primary-soft);
        }

        .metric-label {
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 600;
        }

        .metric-sub {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .metric-progress {
            margin-left: auto;
            width: 72px;
            height: 72px;
            border-radius: 50%;
            background: conic-gradient(var(--primary) var(--angle), rgba(148, 163, 184, 0.35) 0);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: var(--primary-dark);
        }

        .process-overview {
            display: grid;
            gap: 16px;
        }

        .process-summary {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding: 16px 18px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.18);
            background: rgba(99, 102, 241, 0.08);
        }

        .process-summary-value {
            font-size: 28px;
            font-weight: 600;
            color: var(--primary-dark);
            display: inline-flex;
            align-items: baseline;
            gap: 6px;
        }

        .process-summary-value span {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-muted);
        }

        .process-summary-label {
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .process-summary-target {
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-dark);
            background: rgba(99, 102, 241, 0.16);
            padding: 6px 10px;
            border-radius: 999px;
        }

        .process-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 14px;
        }

        .process-item {
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(99, 102, 241, 0.06);
            padding: 14px 16px;
            display: grid;
            gap: 10px;
        }

        .process-item-top {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
        }

        .process-item-label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }

        .process-item-value {
            font-size: 24px;
            font-weight: 600;
        }

        .process-item-note {
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .process-hotlist {
            margin-top: 4px;
            padding-top: 12px;
            border-top: 1px dashed rgba(99, 102, 241, 0.2);
            display: grid;
            gap: 10px;
        }

        .process-hotlist-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }

        .process-hotlist-item {
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(255, 255, 255, 0.85);
            padding: 14px 16px;
            display: grid;
            gap: 8px;
        }

        .process-hotlist-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .process-hotlist-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .process-hotlist-actions {
            margin-top: 4px;
        }

        .feature-usage {
            display: grid;
            gap: 12px;
        }

        .feature-item {
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(99, 102, 241, 0.06);
            padding: 14px 16px;
            display: grid;
            gap: 10px;
        }

        .feature-item-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
        }

        .feature-label {
            font-size: 15px;
            font-weight: 600;
        }

        .feature-meta {
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .feature-progress {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .feature-progress .progress-track {
            flex: 1;
            height: 8px;
        }

        .feature-progress span {
            font-size: 12px;
            color: var(--text-muted);
            min-width: 48px;
            text-align: right;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(var(--dashboard-columns, auto-fit), minmax(var(--dashboard-card-min, 320px), 1fr));
            gap: 20px;
        }

        .card {
            background: var(--surface);
            border-radius: var(--radius-lg);
            padding: 22px 24px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .chart-card {
            display: grid;
            gap: 16px;
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 260px;
        }

        .chart-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .chart-summary span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.18);
            color: inherit;
            font-weight: 500;
        }

        .chart-summary span strong {
            font-weight: 600;
            color: inherit;
        }

        .chart-summary span.positive {
            background: rgba(34, 197, 94, 0.18);
            color: #166534;
        }

        .chart-summary span.info {
            background: rgba(14, 165, 233, 0.18);
            color: #0c4a6e;
        }

        .chart-summary span.negative {
            background: rgba(239, 68, 68, 0.18);
            color: #b91c1c;
        }

        @media (max-width: 768px) {
            .chart-container {
                height: 220px;
            }

            .contact-insights-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .contact-insights-source {
                align-self: flex-start;
            }
        }

        .custom-chart-toolbar {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        .custom-chart-toolbar h3 {
            margin-bottom: 6px;
        }

        .custom-chart-toolbar-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .custom-charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            width: 100%;
        }

        .custom-chart-item {
            display: grid;
            gap: 12px;
            padding: 16px;
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.78);
            border: 1px solid rgba(99, 102, 241, 0.12);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.35);
            position: relative;
        }

        body.layout-compact .custom-chart-item {
            padding: 12px;
        }

        .custom-chart-item-header {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            align-items: flex-start;
        }

        .custom-chart-item-header h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .custom-chart-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .custom-chart-actions button {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: none;
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 13px;
            cursor: pointer;
            background: rgba(99, 102, 241, 0.08);
            color: var(--primary-dark);
            transition: background 0.2s ease, color 0.2s ease;
        }

        .custom-chart-actions button i {
            font-size: 13px;
        }

        .custom-chart-actions button:hover {
            background: rgba(99, 102, 241, 0.16);
            color: var(--primary);
        }

        .custom-chart-actions button.danger {
            background: rgba(239, 68, 68, 0.1);
            color: #b91c1c;
        }

        .custom-chart-actions button.danger:hover {
            background: rgba(239, 68, 68, 0.18);
            color: #dc2626;
        }

        .custom-chart-canvas {
            position: relative;
            height: 240px;
        }

        body.layout-compact .custom-chart-canvas {
            height: 200px;
        }

        .custom-chart-summary-info {
            font-size: 13px;
            color: var(--text-muted);
        }

        .custom-chart-empty {
            border: 1px dashed rgba(99, 102, 241, 0.35);
            border-radius: var(--radius-md);
            padding: 28px 24px;
            text-align: center;
            color: var(--text-muted);
            background: rgba(255, 255, 255, 0.75);
        }

        .custom-chart-empty strong {
            display: block;
            font-size: 16px;
            color: var(--text);
            margin-bottom: 6px;
        }

        .custom-chart-empty p {
            margin-bottom: 16px;
        }

        .custom-chart-options-grid {
            display: grid;
            gap: 14px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .custom-chart-option {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .custom-chart-option label {
            font-weight: 500;
            font-size: 13px;
            color: var(--text);
        }

        .custom-chart-option select,
        .custom-chart-option input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            font-size: 14px;
            background: white;
            color: var(--text);
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .custom-chart-option select:focus,
        .custom-chart-option input[type="number"]:focus {
            outline: none;
            border-color: rgba(99, 102, 241, 0.55);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.12);
        }

        .custom-chart-option .option-description {
            font-size: 12px;
            color: var(--text-muted);
        }

        .custom-chart-checkbox {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(148, 163, 184, 0.12);
            color: var(--text);
        }

        .custom-chart-checkbox input {
            margin-top: 2px;
            accent-color: var(--primary);
        }

        .custom-chart-checkbox span {
            flex: 1;
            font-size: 13px;
        }

        .custom-chart-checkbox small {
            display: block;
            margin-top: 4px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .custom-chart-toggle-list {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 6px;
        }

        .custom-chart-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary-dark);
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .custom-chart-toggle input {
            accent-color: var(--primary);
        }

        .custom-chart-toggle[data-disabled="true"] {
            opacity: 0.5;
            pointer-events: none;
        }

        .custom-chart-toggle:hover {
            background: rgba(99, 102, 241, 0.18);
            color: var(--primary);
        }

        @media (max-width: 900px) {
            .custom-chart-toolbar-actions {
                width: 100%;
                justify-content: flex-start;
            }
        }

        .layout-draggable {
            cursor: grab;
            transition: transform 0.2s ease, opacity 0.2s ease;
        }

        .layout-draggable.is-dragging {
            opacity: 0.65;
            cursor: grabbing;
        }

        [data-layout-area] {
            position: relative;
        }

        [data-layout-area].is-drag-over {
            outline: 2px dashed rgba(99, 102, 241, 0.45);
            outline-offset: 6px;
        }

        .layout-hidden {
            display: none !important;
        }

        body.layout-compact .dashboard-grid {
            gap: 16px;
        }

        body.layout-compact .metrics-grid {
            gap: 14px;
        }

        body.layout-compact .card {
            padding: 18px 20px;
        }

        body.layout-compact .metric-card {
            padding: 16px;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 18px;
        }

        .settings-card {
            display: grid;
            gap: 14px;
        }

        .setting-control {
            display: grid;
            gap: 10px;
        }

        .setting-label {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
        }

        .setting-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .option-pill {
            position: relative;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
        }

        .option-pill input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .option-pill span {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            border-radius: 999px;
            border: 1px solid rgba(99, 102, 241, 0.16);
            background: rgba(99, 102, 241, 0.08);
            transition: border 0.2s ease, background 0.2s ease, color 0.2s ease;
        }

        .option-pill input:focus + span {
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.18);
        }

        .option-pill input:checked + span {
            border-color: rgba(99, 102, 241, 0.45);
            background: rgba(99, 102, 241, 0.2);
            color: var(--primary-dark);
        }

        .setting-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            font-size: 14px;
        }

        .setting-toggle input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .setting-toggle-indicator {
            width: 42px;
            height: 24px;
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.35);
            position: relative;
            transition: background 0.2s ease;
        }

        .setting-toggle-indicator::after {
            content: "";
            position: absolute;
            top: 3px;
            left: 4px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18);
            transition: transform 0.2s ease;
        }

        .setting-toggle input:checked + .setting-toggle-indicator {
            background: rgba(99, 102, 241, 0.45);
        }

        .setting-toggle input:checked + .setting-toggle-indicator::after {
            transform: translateX(16px);
        }

        .setting-toggle-label {
            font-weight: 500;
        }

        .setting-slider {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .setting-slider input[type="range"] {
            flex: 1;
        }

        .setting-slider-value {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-muted);
            min-width: 52px;
            text-align: right;
        }

        .settings-order-columns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .settings-order-list {
            margin: 0;
            padding-left: 18px;
            display: grid;
            gap: 6px;
            font-size: 14px;
        }

        .settings-order-list li {
            list-style: decimal inside;
            padding: 6px 10px;
            border-radius: 10px;
            background: rgba(99, 102, 241, 0.08);
            border: 1px solid rgba(99, 102, 241, 0.16);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .settings-order-list li.is-hidden {
            opacity: 0.6;
            font-style: italic;
        }

        .settings-tag {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            padding: 2px 8px;
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.26);
        }

        .setting-checkbox-list {
            display: grid;
            gap: 10px;
        }

        .setting-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .setting-checkbox input {
            width: 16px;
            height: 16px;
        }

        .card h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 14px;
        }

        .card-feature-overview p {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .feature-note {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px 14px;
            border-radius: var(--radius-md);
            background: rgba(14, 165, 233, 0.12);
            color: #0c4a6e;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 16px;
        }

        .feature-note i {
            font-size: 16px;
            margin-top: 2px;
        }

        .feature-groups {
            display: grid;
            gap: 12px;
        }

        .feature-group {
            background: rgba(99, 102, 241, 0.06);
            border-radius: var(--radius-md);
            padding: 14px 16px;
            border: 1px solid rgba(99, 102, 241, 0.14);
            display: grid;
            gap: 8px;
        }

        .feature-group-title {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text);
        }

        .feature-list {
            margin: 0;
            padding-left: 18px;
            display: grid;
            gap: 6px;
            color: var(--text-muted);
            font-size: 14px;
            line-height: 1.5;
        }

        .stage-distribution {
            display: grid;
            gap: 14px;
        }

        .stage-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .stage-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .stage-bar {
            width: 160px;
            height: 8px;
            border-radius: 6px;
            background: rgba(148, 163, 184, 0.25);
            overflow: hidden;
        }

        .stage-bar span {
            display: block;
            height: 100%;
            border-radius: 6px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.8), rgba(79, 70, 229, 0.9));
        }

        .timeline {
            display: grid;
            gap: 16px;
        }

        .timeline-item {
            display: flex;
            gap: 14px;
            padding: 12px 14px;
            background: rgba(99, 102, 241, 0.06);
            border-radius: 12px;
        }

        .timeline-icon {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(99, 102, 241, 0.12);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-dark);
        }

        .timeline-content {
            flex: 1;
        }

        .timeline-time {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .upcoming-list {
            display: grid;
            gap: 12px;
        }

        .upcoming-item {
            display: flex;
            gap: 14px;
            align-items: center;
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid rgba(99, 102, 241, 0.1);
        }

        .badge {
            font-size: 12px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 999px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .badge-warning {
            background: rgba(245, 158, 11, 0.12);
            color: #b45309;
        }

        .badge-danger {
            background: rgba(239, 68, 68, 0.12);
            color: #b91c1c;
        }

        .badge-success {
            background: rgba(34, 197, 94, 0.12);
            color: #15803d;
        }

        .badge-primary {
            background: rgba(99, 102, 241, 0.18);
            color: var(--primary-dark);
        }

        .badge-info {
            background: rgba(14, 165, 233, 0.18);
            color: #0369a1;
        }

        .badge-neutral {
            background: rgba(148, 163, 184, 0.2);
            color: #334155;
        }

        .pipeline {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 18px;
        }

        .pipeline-metrics {
            margin-bottom: 24px;
        }

        .pipeline-insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 18px;
            margin-top: 26px;
        }

        .pipeline-activity-card {
            margin-top: 20px;
        }

        .stage-status-list,
        .priority-list,
        .owner-summary {
            display: grid;
            gap: 12px;
        }

        .stage-row {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 14px 16px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(248, 250, 255, 0.78);
        }

        .stage-info {
            display: grid;
            gap: 6px;
            flex: 1;
        }

        .stage-name {
            font-weight: 600;
            font-size: 15px;
        }

        .stage-meta {
            font-size: 13px;
            color: var(--text-muted);
        }

        .stage-risk {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: #b45309;
            background: rgba(245, 158, 11, 0.18);
            border-radius: 999px;
            padding: 4px 10px;
            width: fit-content;
        }

        .stage-risk-danger {
            color: #b91c1c;
            background: rgba(239, 68, 68, 0.16);
        }

        .stage-progress {
            display: grid;
            gap: 6px;
            min-width: 150px;
            text-align: right;
        }

        .stage-share {
            font-weight: 600;
            font-size: 14px;
        }

        .stage-progress-track {
            width: 100%;
            height: 8px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.12);
            overflow: hidden;
        }

        .stage-progress-value {
            display: block;
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
        }

        .stage-progress span {
            font-size: 12px;
            color: var(--text-muted);
        }

        .priority-item {
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.14);
            background: rgba(99, 102, 241, 0.06);
            padding: 16px;
            display: grid;
            gap: 10px;
        }

        .priority-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .priority-title {
            font-weight: 600;
            font-size: 15px;
        }

        .priority-meta {
            font-size: 13px;
            color: var(--text-muted);
        }

        .priority-flags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .priority-flag {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            border-radius: 999px;
            padding: 4px 10px;
        }

        .priority-flag.danger {
            background: rgba(239, 68, 68, 0.15);
            color: #b91c1c;
        }

        .priority-flag.warning {
            background: rgba(245, 158, 11, 0.18);
            color: #92400e;
        }

        .priority-flag.info {
            background: rgba(14, 165, 233, 0.18);
            color: #0c4a6e;
        }

        .owner-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(248, 250, 255, 0.78);
            padding: 14px 16px;
        }

        .owner-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .owner-metrics {
            display: grid;
            gap: 6px;
            min-width: 160px;
            text-align: right;
        }

        .owner-progress-track {
            width: 100%;
            height: 8px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.12);
            overflow: hidden;
        }

        .owner-progress-value {
            display: block;
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
        }

        .owner-metrics .metric-sub {
            margin-top: 0;
        }

        .priority-actions {
            display: flex;
            justify-content: flex-end;
        }

        .priority-actions .btn-small-primary {
            white-space: nowrap;
        }

        .pipeline-metrics .metric-card {
            background: rgba(255, 255, 255, 0.95);
        }

        .pipeline-metrics .metric-icon {
            background: rgba(99, 102, 241, 0.12);
        }

        .pipeline-column {
            background: rgba(255, 255, 255, 0.92);
            border-radius: var(--radius-md);
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            min-height: 360px;
        }

        .column-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .column-head h4 {
            font-size: 16px;
            font-weight: 600;
        }

        .column-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .column-body {
            display: grid;
            gap: 12px;
            flex: 1;
        }

        .column-body.drop-active {
            outline: 2px dashed rgba(99, 102, 241, 0.5);
            outline-offset: -10px;
            background: rgba(99, 102, 241, 0.05);
        }

        .deal-card {
            background: rgba(248, 250, 255, 0.85);
            border-radius: 18px;
            padding: 16px;
            display: grid;
            gap: 14px;
            border: 1px solid rgba(99, 102, 241, 0.14);
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .deal-card:active {
            cursor: grabbing;
        }

        .deal-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 30px rgba(99, 102, 241, 0.18);
        }

        .deal-card-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .deal-updated {
            font-size: 12px;
            color: var(--text-muted);
        }

        .deal-owner-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .deal-owner {
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .deal-owner strong {
            font-size: 15px;
        }

        .deal-owner-sub {
            font-size: 12px;
            color: var(--text-muted);
        }

        .deal-stage {
            font-size: 12px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.15);
            color: var(--primary-dark);
        }

        .deal-title {
            font-weight: 600;
            font-size: 16px;
        }

        .deal-meta-line {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 16px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .deal-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .deal-info {
            display: grid;
            gap: 4px;
        }

        .deal-info-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
        }

        .deal-info-value {
            font-size: 14px;
            font-weight: 600;
        }

        .deal-card-bottom {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .deal-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .deal-badge {
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            background: rgba(15, 23, 42, 0.08);
            color: var(--text);
            font-weight: 500;
        }

        .deal-badge.badge-outline {
            background: rgba(99, 102, 241, 0.08);
            border: 1px solid rgba(99, 102, 241, 0.2);
            color: var(--primary-dark);
        }

        .tag {
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            background: rgba(15, 23, 42, 0.08);
            color: var(--text);
        }

        .deal-readiness {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 8px;
            min-width: 180px;
        }

        .deal-readiness-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .deal-readiness-bar {
            position: relative;
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.15);
            overflow: hidden;
        }

        .deal-readiness-bar span {
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: linear-gradient(90deg, #6366f1 0%, #22d3ee 100%);
        }

        .deal-readiness-value {
            font-weight: 600;
            font-size: 13px;
            color: var(--primary-dark);
        }

        .avatar {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(34, 211, 238, 0.3));
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: var(--primary-dark);
        }

        .avatar-lg {
            width: 54px;
            height: 54px;
            font-size: 20px;
        }

        .empty-state {
            padding: 18px;
            border: 1px dashed rgba(99, 102, 241, 0.2);
            border-radius: 16px;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
        }

        .contacts-table {
            display: grid;
            background: var(--surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .table-head,
        .table-row {
            display: grid;
            grid-template-columns: 2.2fr 1.4fr 1.4fr 1.2fr 1fr 1fr;
            padding: 16px 22px;
            align-items: center;
            gap: 12px;
        }

        .table-head {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
            background: rgba(99, 102, 241, 0.06);
            border-top-left-radius: var(--radius-lg);
            border-top-right-radius: var(--radius-lg);
        }

        .table-row {
            border-top: 1px solid rgba(148, 163, 184, 0.18);
            transition: background 0.2s ease;
        }

        .table-row:hover {
            background: rgba(99, 102, 241, 0.08);
        }

        .contact-insights-card {
            margin-top: 22px;
            display: grid;
            gap: 20px;
        }

        .contact-insights-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .contact-insights-header h3 {
            margin-bottom: 8px;
        }

        .contact-insights-header .metric-sub {
            margin: 0;
        }

        .contact-insights-source {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(14, 165, 233, 0.12);
            color: #0c4a6e;
            font-size: 12px;
            font-weight: 600;
        }

        .contact-insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
        }

        .contact-insight-item {
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: flex-start;
            gap: 12px;
            padding: 16px;
            border-radius: var(--radius-md);
            background: rgba(148, 163, 184, 0.12);
            border: 1px solid rgba(148, 163, 184, 0.24);
        }

        .contact-insight-icon {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.16), rgba(99, 102, 241, 0.32));
            color: var(--primary-dark);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .contact-insight-item h4 {
            font-size: 15px;
            font-weight: 600;
            margin: 0;
        }

        .contact-insight-item p {
            margin: 0;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-muted);
        }

        .chip-accent {
            background: rgba(59, 130, 246, 0.18);
            color: #1d4ed8;
        }

        .chip-ghost {
            background: rgba(148, 163, 184, 0.16);
            color: var(--text-muted);
        }

        .table-row.is-active {
            background: rgba(99, 102, 241, 0.12);
            border-left: 3px solid rgba(99, 102, 241, 0.6);
        }

        .contact-detail-layout {
            margin-top: 22px;
            display: grid;
            gap: 20px;
            grid-template-columns: minmax(0, 340px) minmax(0, 1fr);
            align-items: start;
        }

        .contact-profile-card,
        .contact-timeline-card {
            display: grid;
            gap: 18px;
        }

        .contact-profile-header {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 16px;
            align-items: center;
        }

        .contact-profile-header h3 {
            margin: 0;
            font-size: 20px;
        }

        .contact-profile-header .metric-sub {
            margin: 4px 0 0;
        }

        .contact-meta-list {
            display: grid;
            gap: 10px;
        }

        .contact-meta-item {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            align-items: start;
            font-size: 14px;
        }

        .contact-meta-item i {
            color: var(--primary-dark);
            margin-top: 4px;
        }

        .contact-profile-section {
            border-top: 1px solid var(--border);
            padding-top: 14px;
        }

        .contact-profile-section:first-of-type {
            border-top: none;
            padding-top: 0;
        }

        .contact-profile-section h4 {
            margin: 0 0 8px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
        }

        .contact-automation-grid {
            display: grid;
            gap: 12px;
        }

        .contact-automation-item {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            padding: 14px;
            border-radius: 14px;
            background: rgba(14, 165, 233, 0.12);
            border: 1px solid rgba(14, 165, 233, 0.24);
        }

        .contact-automation-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.22), rgba(99, 102, 241, 0.24));
            color: #0c4a6e;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .contact-automation-item h4 {
            margin: 0;
            font-size: 15px;
            font-weight: 600;
        }

        .contact-automation-item p {
            margin: 6px 0 0;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-muted);
        }

        .contact-automation-meta {
            margin: 10px 0 0;
            padding: 0;
            list-style: none;
            display: grid;
            gap: 6px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .contact-automation-meta li strong {
            color: var(--text);
        }

        .contact-profile-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .contact-actions-section {
            display: grid;
            gap: 12px;
        }

        .contact-quick-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .contact-action-button {
            border: none;
            background: rgba(99, 102, 241, 0.12);
            color: var(--primary-dark);
            border-radius: 12px;
            padding: 10px 16px;
            font-size: 13px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }

        .contact-action-button i {
            font-size: 14px;
        }

        .contact-action-button:hover {
            background: rgba(99, 102, 241, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.15);
        }

        .contact-action-button.is-active {
            background: var(--primary);
            color: white;
            box-shadow: 0 12px 26px rgba(99, 102, 241, 0.32);
        }

        .contact-action-button.is-active i {
            color: white;
        }

        .contact-timeline-composer {
            margin: 18px 0 22px;
            padding: 18px;
            border-radius: 18px;
            border: 1px solid rgba(99, 102, 241, 0.18);
            background: rgba(255, 255, 255, 0.72);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
            display: grid;
            gap: 14px;
        }

        .composer-hint {
            margin: 0;
            font-size: 13px;
            color: var(--text-muted);
        }

        .composer-action-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .composer-form {
            display: grid;
            gap: 14px;
        }

        .composer-field-grid {
            display: grid;
            gap: 12px;
        }

        .composer-field label {
            display: grid;
            gap: 8px;
        }

        .composer-label {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .composer-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .composer-footer .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            padding: 10px 18px;
            border-radius: 12px;
        }

        .composer-meta {
            font-size: 13px;
            color: var(--text-muted);
            min-height: 18px;
        }

        .composer-meta.is-success {
            color: var(--success);
        }

        .composer-meta.is-error {
            color: var(--danger);
        }

        .contact-timeline-header {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 12px;
        }

        .contact-timeline-header h3 {
            margin: 0;
        }

        .contact-timeline-header p {
            margin: 0;
            font-size: 13px;
            color: var(--text-muted);
        }

        .contact-timeline-list {
            display: grid;
            gap: 14px;
        }

        .contact-timeline-item {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 14px;
            align-items: start;
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(99, 102, 241, 0.08);
            border: 1px solid rgba(99, 102, 241, 0.16);
        }

        .contact-timeline-icon {
            width: 38px;
            height: 38px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.18), rgba(34, 211, 238, 0.22));
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-dark);
            font-size: 16px;
        }

        .contact-timeline-body {
            display: grid;
            gap: 8px;
        }

        .contact-timeline-body strong {
            font-size: 15px;
        }

        .contact-timeline-meta {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            flex-wrap: wrap;
            gap: 6px 12px;
        }

        .contact-timeline-empty {
            padding: 18px;
            text-align: center;
            background: rgba(148, 163, 184, 0.12);
            border-radius: 12px;
            color: var(--text-muted);
            font-size: 13px;
        }

        @media (max-width: 1024px) {
            .contact-detail-layout {
                grid-template-columns: 1fr;
            }
        }

        .projects-table {
            display: grid;
            background: var(--surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .projects-table .table-head,
        .projects-table .table-row {
            grid-template-columns: 2.4fr 1.6fr 1.1fr 1fr 1fr 1.4fr;
        }

        .project-main {
            display: grid;
            gap: 6px;
        }

        .project-main strong {
            font-size: 15px;
        }

        .project-sub {
            font-size: 13px;
            color: var(--text-muted);
        }

        .project-updated {
            font-size: 12px;
            color: var(--text-muted);
        }

        .project-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .project-tags .tag {
            background: rgba(99, 102, 241, 0.12);
            color: var(--primary-dark);
        }

        .project-team {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .project-member-chip {
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.12);
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-dark);
        }

        .project-owner {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .project-owner strong {
            display: block;
        }

        .project-owner span {
            display: block;
            font-size: 12px;
            color: var(--text-muted);
        }

        .avatar-sm {
            width: 30px;
            height: 30px;
            font-size: 14px;
        }

        .probability-pill {
            position: relative;
            border-radius: 999px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 12px;
            font-weight: 600;
            font-size: 13px;
            color: var(--primary-dark);
            background: rgba(99, 102, 241, 0.12);
            overflow: hidden;
        }

        .probability-pill::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(79, 70, 229, 0.45));
            width: var(--fill, 0%);
            border-radius: inherit;
            transform-origin: left center;
        }

        .probability-pill span {
            position: relative;
            z-index: 1;
        }

        .probability-pill.is-low {
            color: #b45309;
            background: rgba(245, 158, 11, 0.16);
        }

        .probability-pill.is-low::before {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.26), rgba(217, 119, 6, 0.45));
        }

        .probability-pill.is-high {
            color: #166534;
            background: rgba(34, 197, 94, 0.18);
        }

        .probability-pill.is-high::before {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(22, 163, 74, 0.5));
        }

        .probability-filter {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 14px;
            box-shadow: var(--shadow);
        }

        .probability-filter input[type="range"] {
            width: 120px;
            accent-color: var(--primary);
        }

        .probability-value-badge {
            font-weight: 600;
            font-size: 13px;
            color: var(--primary-dark);
        }

        .project-insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 18px;
            margin-bottom: 24px;
        }

        .project-stage-list,
        .project-risk-list,
        .project-team-load,
        .project-updates-list {
            display: grid;
            gap: 12px;
        }

        .project-stage-row,
        .project-team-row {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 14px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(248, 250, 255, 0.78);
        }

        .project-stage-row {
            justify-content: space-between;
        }

        .project-stage-info,
        .project-team-info {
            display: grid;
            gap: 4px;
            flex: 1;
        }

        .project-stage-progress,
        .project-team-progress {
            display: grid;
            gap: 6px;
            min-width: 160px;
        }

        .project-stage-progress {
            grid-template-columns: 1fr auto;
            align-items: center;
        }

        .project-stage-track,
        .project-team-progress-track {
            width: 100%;
            height: 8px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.12);
            overflow: hidden;
        }

        .project-stage-fill,
        .project-team-progress-fill {
            display: block;
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
        }

        .project-stage-chip {
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-dark);
            background: rgba(99, 102, 241, 0.18);
            padding: 6px 10px;
            border-radius: 999px;
        }

        .project-risk-item {
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(248, 250, 255, 0.78);
            padding: 14px 16px;
            display: grid;
            gap: 10px;
        }

        .project-risk-item.warning {
            border-color: rgba(245, 158, 11, 0.32);
            background: rgba(254, 243, 199, 0.55);
        }

        .project-risk-item.critical {
            border-color: rgba(239, 68, 68, 0.35);
            background: rgba(254, 226, 226, 0.6);
        }

        .project-risk-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .project-risk-flags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .project-risk-flag {
            font-size: 12px;
            font-weight: 600;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.12);
            color: var(--primary-dark);
        }

        .project-risk-flag.is-warning {
            background: rgba(245, 158, 11, 0.18);
            color: #92400e;
        }

        .project-risk-flag.is-critical {
            background: rgba(239, 68, 68, 0.18);
            color: #b91c1c;
        }

        .project-risk-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .project-risk-meta i {
            margin-right: 6px;
            color: rgba(239, 68, 68, 0.7);
        }

        .project-risk-score {
            font-weight: 600;
            font-size: 13px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(239, 68, 68, 0.16);
            color: #b91c1c;
        }

        .project-risk-item.warning .project-risk-score {
            background: rgba(245, 158, 11, 0.16);
            color: #b45309;
        }

        .project-team-row .metric-sub {
            margin-top: 0;
        }

        .project-updates-card {
            margin-bottom: 24px;
        }

        .project-updates-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 16px;
        }

        .project-updates-header .metric-sub {
            margin-top: 4px;
        }

        .project-updates-counter {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.12);
            color: var(--primary-dark);
        }

        .project-update-item {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            padding: 12px 14px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(248, 250, 255, 0.9);
        }

        .project-update-bullet {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-top: 6px;
            background: linear-gradient(135deg, var(--primary), var(--accent));
        }

        .project-update-body {
            display: grid;
            gap: 6px;
        }

        .project-update-body p {
            margin: 0;
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .project-update-footer {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .project-update-footer i {
            margin-right: 6px;
            color: var(--primary);
        }

        .input-hint {
            font-size: 12px;
            color: var(--text-muted);
        }

        .contact-main {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .contact-info {
            display: grid;
            gap: 4px;
        }

        .contact-sub {
            font-size: 13px;
            color: var(--text-muted);
        }

        .status-badge {
            padding: 6px 10px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .status-lead {
            background: rgba(99, 102, 241, 0.18);
            color: #4338ca;
        }

        .status-potential {
            background: rgba(14, 165, 233, 0.15);
            color: #0c4a6e;
        }

        .status-customer {
            background: rgba(34, 197, 94, 0.18);
            color: #166534;
        }

        .status-vip {
            background: rgba(234, 179, 8, 0.2);
            color: #92400e;
        }

        .status-partner {
            background: rgba(249, 115, 22, 0.15);
            color: #9a3412;
        }

        .status-active {
            background: rgba(34, 197, 94, 0.15);
            color: #15803d;
        }

        .status-cold {
            background: rgba(148, 163, 184, 0.22);
            color: #475569;
        }

        .task-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 320px;
            gap: 20px;
            align-items: start;
        }

        .task-main {
            display: grid;
            gap: 18px;
        }

        .task-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 16px 18px;
            box-shadow: var(--shadow);
        }

        .task-search {
            position: relative;
            flex: 1 1 220px;
            max-width: 380px;
        }

        .task-search i {
            position: absolute;
            top: 50%;
            left: 14px;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        .task-search input {
            width: 100%;
            border: 1px solid rgba(99, 102, 241, 0.18);
            border-radius: 12px;
            padding: 10px 12px 10px 38px;
            font-size: 14px;
            outline: none;
            background: rgba(248, 250, 255, 0.9);
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .task-search input:focus {
            border-color: rgba(99, 102, 241, 0.4);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }

        .task-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: flex-end;
        }

        .task-filter {
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 9px 12px;
            font-size: 13px;
            background: rgba(248, 250, 255, 0.9);
            color: var(--text);
            min-width: 140px;
        }

        .task-filter:focus {
            outline: none;
            border-color: rgba(99, 102, 241, 0.45);
        }

        .task-filter-reset {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(99, 102, 241, 0.22);
            border-radius: 12px;
            padding: 9px 14px;
            font-size: 13px;
            font-weight: 600;
            background: rgba(99, 102, 241, 0.12);
            color: var(--primary-dark);
            cursor: pointer;
            transition: background 0.2s ease, border 0.2s ease;
        }

        .task-filter-reset:hover {
            background: rgba(99, 102, 241, 0.18);
            border-color: rgba(99, 102, 241, 0.32);
        }

        .task-filter-reset i {
            font-size: 14px;
        }

        .task-process-summary {
            background: rgba(255, 255, 255, 0.95);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            padding: 18px 20px;
            box-shadow: var(--shadow);
            display: grid;
            gap: 12px;
        }

        .process-summary-main {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .process-summary-title {
            font-size: 20px;
            font-weight: 700;
        }

        .process-summary-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            padding: 8px 12px;
            border-radius: 999px;
            background: rgba(34, 197, 94, 0.16);
            color: #15803d;
            font-weight: 600;
        }

        .process-summary-indicator.has-warning {
            background: rgba(239, 68, 68, 0.18);
            color: #b91c1c;
        }

        .process-summary-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .process-summary-filter {
            margin-top: -4px;
        }

        .task-board {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 18px;
        }

        .task-sidebar {
            display: grid;
            gap: 16px;
        }

        .task-sidebar-card {
            display: grid;
            gap: 14px;
        }

        .task-sidebar-header h3 {
            margin-bottom: 6px;
        }

        .task-summary-grid {
            display: grid;
            gap: 12px;
        }

        .task-summary-card {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            padding: 14px 16px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.14);
            background: rgba(248, 250, 255, 0.9);
        }

        .task-summary-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(99, 102, 241, 0.16);
            color: var(--primary-dark);
            font-size: 16px;
        }

        .task-summary-icon-warning {
            background: rgba(245, 158, 11, 0.18);
            color: #b45309;
        }

        .task-summary-icon-success {
            background: rgba(34, 197, 94, 0.18);
            color: #15803d;
        }

        .task-summary-icon-info {
            background: rgba(14, 165, 233, 0.18);
            color: #0c4a6e;
        }

        .task-summary-label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            font-weight: 600;
            color: var(--text-muted);
        }

        .task-summary-value {
            font-size: 20px;
            font-weight: 700;
            margin: 4px 0;
        }

        .task-flow-list,
        .task-workload-list,
        .task-feature-list {
            display: grid;
            gap: 12px;
        }

        .task-flow-item,
        .task-workload-item,
        .task-feature-item {
            border: 1px solid rgba(99, 102, 241, 0.14);
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.92);
            padding: 12px 14px;
            display: grid;
            gap: 8px;
        }

        .task-flow-header,
        .task-workload-header,
        .task-feature-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .task-workload-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .task-feature-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .task-feature-icon {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(99, 102, 241, 0.12);
            color: var(--primary-dark);
        }

        .task-feature-value {
            font-weight: 700;
            font-size: 18px;
        }

        .task-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            background: rgba(99, 102, 241, 0.12);
            color: var(--text);
        }

        .task-pill i {
            font-size: 12px;
        }

        .task-pill-info {
            background: rgba(14, 165, 233, 0.14);
            color: #0c4a6e;
        }

        .task-pill-warning {
            background: rgba(245, 158, 11, 0.16);
            color: #b45309;
        }

        .task-pill-danger {
            background: rgba(239, 68, 68, 0.16);
            color: #b91c1c;
        }

        .task-pill-muted {
            background: rgba(148, 163, 184, 0.16);
            color: #1f2937;
        }

        @media (max-width: 1280px) {
            .task-layout {
                grid-template-columns: 1fr;
            }

            .task-sidebar {
                grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .task-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .task-filters {
                width: 100%;
                justify-content: flex-start;
            }

            .task-filter {
                flex: 1 1 auto;
            }

            .task-sidebar {
                grid-template-columns: 1fr;
            }
        }

        .task-column {
            background: rgba(255, 255, 255, 0.95);
            border-radius: var(--radius-md);
            padding: 18px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            display: grid;
            gap: 12px;
        }

        .task-column-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .task-column-header h4 {
            font-size: 16px;
            font-weight: 600;
        }

        .task-column-header span {
            font-size: 13px;
            color: var(--text-muted);
        }

        .task-items {
            display: grid;
            gap: 12px;
        }

        .task-card {
            background: rgba(99, 102, 241, 0.06);
            border-radius: 16px;
            padding: 14px 16px;
            display: grid;
            gap: 10px;
            border: 1px solid rgba(99, 102, 241, 0.12);
        }

        .task-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .task-title {
            font-weight: 600;
            font-size: 15px;
        }

        .task-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .task-actions {
            display: flex;
            gap: 10px;
        }

        .task-actions button {
            border: none;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .btn-small-primary {
            background: rgba(79, 70, 229, 0.16);
            color: var(--primary-dark);
        }

        .btn-small-primary:hover {
            background: rgba(79, 70, 229, 0.24);
        }

        .btn-small-muted {
            background: rgba(148, 163, 184, 0.16);
            color: #1f2937;
        }

        .btn-small-muted:hover {
            background: rgba(148, 163, 184, 0.24);
        }

        .priority {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 999px;
        }

        .priority-high {
            background: rgba(239, 68, 68, 0.18);
            color: #b91c1c;
        }

        .priority-medium {
            background: rgba(245, 158, 11, 0.18);
            color: #b45309;
        }

        .priority-low {
            background: rgba(34, 197, 94, 0.18);
            color: #15803d;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 18px;
        }

        .call-center-card {
            display: grid;
            gap: 18px;
        }

        .call-center-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .call-center-header h3 {
            margin-bottom: 6px;
        }

        .call-center-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 13px;
            font-weight: 600;
            background: rgba(148, 163, 184, 0.18);
            color: #475569;
        }

        .call-center-status .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: currentColor;
        }

        .call-center-status.online {
            background: rgba(34, 197, 94, 0.2);
            color: #166534;
        }

        .call-center-status.offline {
            background: rgba(239, 68, 68, 0.2);
            color: #b91c1c;
        }

        .call-center-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .call-center-metric {
            display: grid;
            gap: 8px;
            padding: 16px;
            border-radius: 16px;
            border: 1px solid rgba(99, 102, 241, 0.14);
            background: rgba(255, 255, 255, 0.92);
        }

        .call-center-metric .metric-label {
            font-size: 12px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .call-center-metric .metric-value {
            font-size: 22px;
            font-weight: 600;
        }

        .call-center-metric .metric-sub {
            font-size: 12px;
        }

        .call-center-queues {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .call-center-queue {
            border: 1px solid rgba(148, 163, 184, 0.28);
            border-radius: 14px;
            padding: 12px 14px;
            background: rgba(148, 163, 184, 0.12);
            display: grid;
            gap: 6px;
        }

        .call-center-chart {
            display: grid;
            gap: 12px;
        }

        .call-center-chart-head {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        .call-center-chart-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .call-center-chart .chart-container {
            height: 240px;
        }

        .call-center-quality {
            display: grid;
            gap: 12px;
        }

        .call-center-quality-head {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .call-quality-feed {
            display: grid;
            gap: 12px;
        }

        .call-quality-item {
            border-radius: 16px;
            border: 1px solid rgba(99, 102, 241, 0.14);
            background: rgba(255, 255, 255, 0.92);
            padding: 16px;
            display: grid;
            gap: 10px;
        }

        .call-quality-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .call-quality-sentiment {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
        }

        .call-quality-sentiment.positive {
            color: #166534;
        }

        .call-quality-sentiment.negative {
            color: #b91c1c;
        }

        .call-quality-sentiment.neutral {
            color: #1f2937;
        }

        .call-quality-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .call-quality-tag {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            background: rgba(79, 70, 229, 0.16);
            color: var(--primary-dark);
        }

        .call-quality-empty {
            padding: 16px;
            border-radius: 14px;
            border: 1px dashed rgba(148, 163, 184, 0.4);
            background: rgba(148, 163, 184, 0.12);
            color: var(--text-muted);
            text-align: center;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .call-center-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .call-center-chart .chart-container {
                height: 220px;
            }
        }

        .role-dashboard-card {
            display: grid;
            gap: 16px;
        }

        .role-dashboard-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .role-dashboard-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .role-dashboard-tab {
            border: 1px solid rgba(99, 102, 241, 0.3);
            background: rgba(79, 70, 229, 0.08);
            color: var(--primary-dark);
            padding: 8px 14px;
            border-radius: 999px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }

        .role-dashboard-tab[aria-selected="true"],
        .role-dashboard-tab.active {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.16), rgba(79, 70, 229, 0.3));
            color: #312e81;
            border-color: rgba(79, 70, 229, 0.4);
        }

        .role-dashboard-content {
            display: grid;
            gap: 14px;
        }

        .role-dashboard-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .role-metric {
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(99, 102, 241, 0.14);
            display: grid;
            gap: 6px;
        }

        .role-metric strong {
            font-size: 20px;
            color: #1f2937;
        }

        .role-dashboard-insights {
            display: grid;
            gap: 8px;
            padding-left: 18px;
        }

        .role-dashboard-insights li {
            font-size: 13px;
            color: var(--text-muted);
        }

        .report-builder-card {
            display: grid;
            gap: 16px;
        }

        .report-builder-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .report-builder-controls {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            align-items: end;
        }

        .report-control label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .report-control select {
            width: 100%;
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 10px 12px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
        }

        .report-summary {
            padding: 12px;
            border-radius: 12px;
            background: rgba(99, 102, 241, 0.08);
            color: #312e81;
            font-weight: 500;
        }

        .report-preview {
            border: 1px solid rgba(148, 163, 184, 0.24);
            border-radius: 14px;
            overflow: hidden;
        }

        .report-preview-head,
        .report-row {
            display: grid;
            gap: 10px;
            padding: 12px 16px;
        }

        .report-preview-head {
            background: rgba(148, 163, 184, 0.14);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            font-weight: 600;
            color: #475569;
        }

        .report-row:nth-child(even) {
            background: rgba(255, 255, 255, 0.92);
        }

        .report-row:nth-child(odd) {
            background: rgba(248, 250, 252, 0.9);
        }

        .report-row span {
            font-size: 14px;
            color: #1f2937;
        }

        .report-row span.align-right {
            text-align: right;
        }

        .report-export-status {
            font-size: 12px;
            color: var(--text-muted);
        }

        .forecasting-card {
            display: grid;
            gap: 16px;
        }

        .forecasting-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .forecasting-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .forecasting-metric {
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(79, 70, 229, 0.08);
            border: 1px solid rgba(79, 70, 229, 0.18);
            display: grid;
            gap: 6px;
        }

        .forecasting-metric strong {
            font-size: 20px;
            color: #1f2937;
        }

        .forecasting-table {
            border: 1px solid rgba(148, 163, 184, 0.24);
            border-radius: 14px;
            overflow: hidden;
        }

        .forecasting-head,
        .forecasting-row {
            display: grid;
            gap: 12px;
            padding: 12px 16px;
        }

        .forecasting-head {
            background: rgba(148, 163, 184, 0.14);
            font-size: 12px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            font-weight: 600;
            color: #475569;
        }

        .forecasting-row {
            background: rgba(255, 255, 255, 0.92);
            font-size: 14px;
            color: #1f2937;
        }

        .forecasting-row:nth-child(odd) {
            background: rgba(248, 250, 252, 0.9);
        }

        .forecasting-row span.align-right {
            text-align: right;
        }

        .report-empty,
        .forecasting-empty {
            padding: 16px;
            color: var(--text-muted);
            text-align: center;
        }

        .progress-list {
            display: grid;
            gap: 14px;
        }

        .progress-item {
            display: grid;
            gap: 6px;
        }

        .progress-track {
            width: 100%;
            height: 10px;
            border-radius: 8px;
            background: rgba(148, 163, 184, 0.2);
            overflow: hidden;
        }

        .progress-value {
            height: 100%;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.85), rgba(79, 70, 229, 0.95));
        }

        .lead-focus-list {
            display: grid;
            gap: 12px;
        }

        .lead-focus-item {
            padding: 14px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(99, 102, 241, 0.14);
            display: grid;
            gap: 6px;
        }

        .focus-meta {
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-manager {
            display: grid;
            gap: 18px;
        }

        .file-sources {
            background: var(--surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 20px;
            display: grid;
            gap: 16px;
        }

        .file-sources-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .file-sources-header h3 {
            font-size: 16px;
            margin-bottom: 4px;
        }

        .file-sources-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-sources-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 14px;
        }

        .file-source-card {
            border: 1px solid rgba(99, 102, 241, 0.12);
            border-radius: var(--radius-md);
            background: rgba(99, 102, 241, 0.04);
            padding: 16px;
            display: grid;
            gap: 12px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .file-source-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
            background: rgba(99, 102, 241, 0.08);
        }

        .file-source-card.active {
            border-color: rgba(99, 102, 241, 0.45);
            box-shadow: 0 12px 24px rgba(99, 102, 241, 0.18);
            background: rgba(99, 102, 241, 0.1);
        }

        .file-source-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .file-source-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(79, 70, 229, 0.12);
            color: var(--primary-dark);
            font-size: 18px;
        }

        .file-source-title strong {
            display: block;
            font-size: 15px;
        }

        .file-source-status {
            margin-left: auto;
            font-size: 12px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 999px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .file-source-status.status-online {
            background: rgba(34, 197, 94, 0.16);
            color: #15803d;
        }

        .file-source-status.status-offline {
            background: rgba(148, 163, 184, 0.18);
            color: #475569;
        }

        .file-source-status.status-syncing {
            background: rgba(14, 165, 233, 0.16);
            color: #0e7490;
        }

        .file-source-body {
            display: grid;
            gap: 10px;
        }

        .file-source-path {
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-source-stats {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 10px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-source-stats strong {
            display: block;
            font-size: 16px;
            color: var(--text);
        }

        .file-source-updated {
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-source-footer {
            display: flex;
            justify-content: flex-end;
        }

        .file-actions {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }

        .file-actions select {
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--surface);
            padding: 10px 14px;
            font-size: 14px;
            box-shadow: var(--shadow);
        }

        .file-actions select:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .file-search {
            position: relative;
        }

        .file-search input {
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 10px 14px 10px 40px;
            font-size: 14px;
            background: var(--surface);
            box-shadow: var(--shadow);
            min-width: 240px;
        }

        .file-search i {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        .file-status {
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .file-summary-card {
            background: rgba(99, 102, 241, 0.08);
            border-radius: var(--radius-md);
            padding: 12px 16px;
            display: grid;
            gap: 6px;
            min-width: 180px;
        }

        .file-summary-card strong {
            font-size: 16px;
        }

        .file-summary-card span {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
        }

        .file-summary-card small {
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-process-dashboard {
            display: grid;
            gap: 18px;
        }

        .file-process-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 14px;
        }

        .file-process-card {
            border: 1px solid rgba(99, 102, 241, 0.14);
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.94);
            padding: 16px 18px;
            display: grid;
            gap: 8px;
        }

        .file-process-icon {
            width: 40px;
            height: 40px;
            border-radius: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(99, 102, 241, 0.12);
            color: var(--primary-dark);
            font-size: 18px;
        }

        .file-process-value {
            font-size: 24px;
            font-weight: 700;
        }

        .file-process-label {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
        }

        .file-process-note {
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .file-usage-layout {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }

        .file-usage-card {
            background: var(--surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 18px;
            display: grid;
            gap: 16px;
        }

        .file-usage-header h3 {
            margin-bottom: 4px;
            font-size: 16px;
        }

        .file-status-list,
        .file-feature-list {
            display: grid;
            gap: 12px;
        }

        .file-status-item {
            display: grid;
            gap: 8px;
            border: 1px solid rgba(99, 102, 241, 0.12);
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.92);
            padding: 12px 14px;
        }

        .file-status-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .file-status-header strong {
            font-size: 18px;
        }

        .file-status-meta {
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .file-status-badge.status-online {
            background: rgba(34, 197, 94, 0.16);
            color: #15803d;
        }

        .file-status-badge.status-syncing {
            background: rgba(14, 165, 233, 0.18);
            color: #0c4a6e;
        }

        .file-status-badge.status-offline {
            background: rgba(148, 163, 184, 0.22);
            color: #475569;
        }

        .file-feature-item {
            border: 1px solid rgba(99, 102, 241, 0.12);
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.92);
            padding: 14px 16px;
            display: grid;
            gap: 10px;
        }

        .file-feature-top {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
        }

        .file-feature-info {
            display: grid;
            gap: 6px;
            flex: 1 1 auto;
        }

        .file-feature-info strong {
            font-size: 15px;
        }

        .file-feature-meta {
            font-size: 13px;
            color: var(--text-muted);
            margin: 0;
        }

        .file-feature-value {
            font-weight: 700;
            font-size: 20px;
            align-self: center;
            white-space: nowrap;
        }

        .file-feature-icon,
        .file-activity-icon {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(99, 102, 241, 0.12);
            color: var(--primary-dark);
            flex-shrink: 0;
        }

        .file-activity-card {
            background: var(--surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 18px;
            display: grid;
            gap: 16px;
        }

        .file-activity-timeline {
            display: grid;
            gap: 12px;
        }

        .file-activity-item {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            padding: 12px 14px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(99, 102, 241, 0.12);
            background: rgba(255, 255, 255, 0.9);
        }

        .file-activity-info {
            display: grid;
            gap: 6px;
            flex: 1;
        }

        .file-activity-info strong {
            font-size: 14px;
        }

        .file-activity-info p {
            margin: 0;
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-activity-time {
            font-size: 12px;
            color: var(--text-muted);
        }

        .tone-primary {
            background: rgba(99, 102, 241, 0.16) !important;
            color: var(--primary-dark) !important;
        }

        .tone-success {
            background: rgba(34, 197, 94, 0.18) !important;
            color: #15803d !important;
        }

        .tone-info {
            background: rgba(14, 165, 233, 0.18) !important;
            color: #0c4a6e !important;
        }

        .tone-warning {
            background: rgba(245, 158, 11, 0.18) !important;
            color: #b45309 !important;
        }

        .tone-muted {
            background: rgba(148, 163, 184, 0.22) !important;
            color: #475569 !important;
        }

        @media (max-width: 768px) {
            .file-process-grid {
                grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            }
            .file-usage-layout {
                grid-template-columns: 1fr;
            }
        }

        .file-monitor-guide {
            background: var(--surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 20px;
            display: grid;
            gap: 16px;
        }

        .file-monitor-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .file-monitor-header h3 {
            font-size: 16px;
            margin: 0 0 6px;
        }

        .file-monitor-header p {
            margin: 0;
            font-size: 14px;
            color: var(--text-muted);
        }

        .file-monitor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 14px;
        }

        .file-monitor-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            background: rgba(99, 102, 241, 0.08);
            border-radius: var(--radius-md);
            padding: 12px 14px;
        }

        .file-monitor-item i {
            color: var(--primary-dark);
            font-size: 18px;
            margin-top: 2px;
        }

        .file-monitor-item strong {
            display: block;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .file-monitor-item p {
            margin: 0;
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-monitor-guide code {
            background: rgba(99, 102, 241, 0.12);
            border-radius: 6px;
            padding: 2px 6px;
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 12px;
        }

        .file-monitor-list {
            margin: 0;
            padding-left: 20px;
            display: grid;
            gap: 8px;
            font-size: 14px;
            color: var(--text-muted);
        }

        .file-monitor-list li {
            line-height: 1.5;
        }

        .file-monitor-list strong {
            color: var(--text);
        }

        .file-monitor-note {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            background: rgba(34, 197, 94, 0.12);
            border-radius: var(--radius-md);
            padding: 12px 14px;
        }

        .file-monitor-note i {
            color: var(--success);
            font-size: 18px;
            margin-top: 2px;
        }

        .file-monitor-note p {
            margin: 0;
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-monitor-footer {
            display: flex;
            justify-content: flex-start;
        }

        .file-monitor-footer a {
            color: var(--primary-dark);
            font-weight: 600;
            text-decoration: none;
        }

        .file-monitor-footer a:hover {
            text-decoration: underline;
        }

        .file-tree {
            background: var(--surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .file-tree-head,
        .file-entry {
            display: grid;
            grid-template-columns: minmax(0, 2.5fr) minmax(0, 1fr) minmax(0, 1.1fr);
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
        }

        .file-tree-head div:nth-child(2),
        .file-tree-head div:nth-child(3),
        .file-entry div:nth-child(2),
        .file-entry div:nth-child(3) {
            text-align: right;
        }

        .file-tree-head {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
            background: rgba(99, 102, 241, 0.06);
        }

        .file-tree-body {
            max-height: 460px;
            overflow-y: auto;
        }

        .file-entry {
            border-top: 1px solid rgba(148, 163, 184, 0.18);
            font-size: 14px;
        }

        .file-entry:hover {
            background: rgba(99, 102, 241, 0.08);
        }

        .file-name {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-left: calc(var(--level, 0) * 20px);
            word-break: break-word;
        }

        .file-name i {
            width: 20px;
            text-align: center;
            color: var(--primary-dark);
        }

        .file-name[data-type="directory"] i {
            color: #f59e0b;
        }

        .file-entry .file-meta {
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-entry mark {
            background: rgba(99, 102, 241, 0.18);
            color: inherit;
            padding: 0 2px;
            border-radius: 4px;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.55);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 24px;
            z-index: 50;
            backdrop-filter: blur(12px);
        }

        .modal.active {
            display: flex;
        }

        .modal-dialog {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 28px;
            width: min(680px, 90vw);
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(99, 102, 241, 0.15);
            box-shadow: 0 30px 60px rgba(15, 23, 42, 0.18);
        }

        .modal-dialog.wide {
            width: min(860px, 92vw);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .modal-header h3 {
            font-size: 20px;
            font-weight: 600;
        }

        .modal-close {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            border: none;
            background: rgba(15, 23, 42, 0.08);
            cursor: pointer;
            font-size: 18px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px 18px;
        }

        .form-group {
            display: grid;
            gap: 8px;
        }

        .form-group.full {
            grid-column: 1 / -1;
        }

        .form-hint {
            font-size: 12px;
            color: var(--text-muted);
            margin: -4px 0 0;
        }

        .form-hint strong {
            color: var(--primary-dark);
        }

        .input-with-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .input-with-indicator input[type="range"] {
            flex: 1;
        }

        .input-indicator {
            min-width: 56px;
            text-align: right;
            font-weight: 600;
            color: var(--primary-dark);
        }

        label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        input, select, textarea {
            width: 100%;
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            padding: 12px 14px;
            font-size: 15px;
            font-family: inherit;
            background: rgba(248, 250, 255, 0.9);
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: rgba(99, 102, 241, 0.6);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 110px;
        }

        .file-dropzone {
            border: 1px dashed rgba(99, 102, 241, 0.35);
            border-radius: 16px;
            background: rgba(99, 102, 241, 0.05);
            padding: 20px;
            display: grid;
            gap: 12px;
            justify-items: center;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .file-input-hidden {
            display: none;
        }

        .file-dropzone:hover,
        .file-dropzone.has-files {
            border-color: rgba(79, 70, 229, 0.55);
            background: rgba(99, 102, 241, 0.09);
        }

        .file-dropzone:focus-visible {
            outline: 3px solid rgba(99, 102, 241, 0.35);
            outline-offset: 3px;
        }

        .file-dropzone.dragover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.14);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.12);
        }

        .file-dropzone-content {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .file-dropzone-text {
            display: grid;
            gap: 6px;
            text-align: left;
        }

        .file-dropzone-actions {
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-dropzone-actions .file-browse-btn {
            margin: 0 6px;
        }

        .file-dropzone i {
            font-size: 24px;
            color: var(--primary-dark);
        }

        .file-dropzone strong {
            display: block;
            font-size: 15px;
            margin-bottom: 6px;
        }

        .file-browse-btn {
            border: none;
            background: rgba(79, 70, 229, 0.16);
            color: var(--primary-dark);
            padding: 6px 14px;
            border-radius: 999px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            display: inline-flex;
            align-items: center;
            pointer-events: auto;
        }

        .file-browse-btn:hover,
        .file-browse-btn:focus {
            background: rgba(79, 70, 229, 0.26);
            outline: none;
        }

        .upload-hint {
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-list {
            display: grid;
            gap: 10px;
            margin-top: 12px;
        }

        .file-item {
            display: grid;
            grid-template-columns: minmax(0, 1fr) auto;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(99, 102, 241, 0.08);
            border: 1px solid rgba(99, 102, 241, 0.12);
        }

        .file-item-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .file-icon {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.8);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-dark);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.18);
        }

        .file-meta {
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-progress {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-progress-track {
            flex: 1;
            height: 6px;
            border-radius: 999px;
            background: rgba(79, 70, 229, 0.16);
            overflow: hidden;
        }

        .file-progress-value {
            height: 100%;
            width: 0%;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.85), rgba(129, 140, 248, 0.95));
            transition: width 0.2s ease;
        }

        .file-progress-label {
            font-size: 12px;
            color: var(--text-muted);
            min-width: 38px;
            text-align: right;
        }

        .upload-progress {
            display: none;
            align-items: center;
            gap: 12px;
            justify-content: space-between;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(99, 102, 241, 0.16);
            background: rgba(99, 102, 241, 0.08);
            font-size: 12px;
            color: var(--text-muted);
        }

        .upload-progress.active {
            display: flex;
        }

        .upload-progress strong {
            color: var(--primary-dark);
        }

        .upload-progress-track {
            flex: 1;
            height: 6px;
            border-radius: 999px;
            background: rgba(79, 70, 229, 0.16);
            overflow: hidden;
        }

        .upload-progress-value {
            height: 100%;
            width: 0%;
            background: linear-gradient(135deg, rgba(129, 140, 248, 0.95), rgba(56, 189, 248, 0.9));
            transition: width 0.2s ease;
        }

        .file-remove {
            border: none;
            background: rgba(15, 23, 42, 0.12);
            color: var(--text);
            width: 30px;
            height: 30px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .file-remove:hover,
        .file-remove:focus {
            background: rgba(15, 23, 42, 0.18);
            outline: none;
        }

        .file-empty {
            font-size: 13px;
            color: var(--text-muted);
            padding: 8px 0;
        }

        .modal-actions {
            margin-top: 24px;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .lead-details {
            display: grid;
            gap: 18px;
        }

        .lead-highlights {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 14px;
        }

        .highlight-card {
            background: rgba(99, 102, 241, 0.06);
            border-radius: 16px;
            padding: 14px 16px;
            display: grid;
            gap: 6px;
            border: 1px solid rgba(99, 102, 241, 0.12);
        }

        .highlight-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
        }

        .highlight-value {
            font-size: 18px;
            font-weight: 600;
        }

        .lead-columns {
            display: grid;
            grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
            gap: 18px;
        }

        .info-grid {
            display: grid;
            gap: 12px;
        }

        .info-item {
            display: grid;
            gap: 4px;
        }

        .info-label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
        }

        .info-value {
            font-size: 15px;
            font-weight: 500;
        }

        .attachment-list {
            display: grid;
            gap: 10px;
            margin-top: 6px;
        }

        .attachment-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(248, 250, 255, 0.9);
            border: 1px solid rgba(99, 102, 241, 0.14);
            text-decoration: none;
            color: inherit;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .attachment-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(99, 102, 241, 0.18);
            background: rgba(255, 255, 255, 0.98);
        }

        .attachment-icon {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(99, 102, 241, 0.12);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-dark);
        }

        .attachment-details {
            display: grid;
            gap: 4px;
        }

        .attachment-details strong {
            font-size: 14px;
            font-weight: 600;
        }

        .attachment-meta {
            font-size: 12px;
            color: var(--text-muted);
        }

        .attachment-item i.fa-download {
            margin-left: auto;
            color: var(--primary-dark);
        }

        .notes-list {
            display: grid;
            gap: 12px;
            margin-top: 12px;
        }

        .note-item {
            padding: 12px 14px;
            background: rgba(148, 163, 184, 0.12);
            border-radius: 12px;
            display: grid;
            gap: 6px;
        }

        .note-meta {
            font-size: 12px;
            color: var(--text-muted);
        }

        .timeline-list {
            display: grid;
            gap: 10px;
        }

        .timeline-entry {
            border-left: 2px solid rgba(99, 102, 241, 0.3);
            padding-left: 12px;
            margin-left: 6px;
        }

        .timeline-entry strong {
            display: block;
            font-weight: 600;
        }

        .timeline-entry span {
            color: var(--text-muted);
            font-size: 12px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 6px;
        }

        .chip {
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(99, 102, 241, 0.12);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .role-layout {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 18px;
        }

        .role-definition-grid {
            display: grid;
            gap: 12px;
        }

        .role-card {
            border: 1px solid rgba(99, 102, 241, 0.18);
            border-radius: var(--radius-md);
            background: rgba(99, 102, 241, 0.06);
            padding: 16px 18px;
            display: grid;
            gap: 10px;
        }

        .role-card h4 {
            font-size: 15px;
            margin: 0;
        }

        .role-card p {
            margin: 0;
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .role-permissions {
            display: grid;
            gap: 6px;
            margin: 0;
            padding-left: 18px;
            color: var(--text-muted);
            font-size: 13px;
        }

        .role-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(79, 70, 229, 0.18);
            color: var(--primary-dark);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .role-warning {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px 14px;
            border-radius: var(--radius-md);
            background: rgba(239, 68, 68, 0.14);
            color: #991b1b;
            font-size: 13px;
            line-height: 1.5;
        }

        .role-table {
            display: grid;
            gap: 10px;
        }

        .role-row {
            display: grid;
            grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr) minmax(0, 1.6fr);
            gap: 12px;
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(148, 163, 184, 0.3);
            align-items: center;
        }

        .role-member {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .role-member-details strong {
            display: block;
        }

        .role-member-details .role-meta {
            display: block;
            margin-top: 2px;
        }

        .role-row.role-head {
            background: rgba(99, 102, 241, 0.1);
            border-color: rgba(99, 102, 241, 0.2);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            font-weight: 600;
        }

        .role-row select {
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            padding: 8px 10px;
            font-size: 14px;
            background: rgba(248, 250, 255, 0.9);
        }

        .role-row select:focus {
            outline: none;
            border-color: rgba(99, 102, 241, 0.6);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.12);
        }

        .role-permission-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .role-permission-tag {
            background: rgba(15, 23, 42, 0.08);
            color: var(--text);
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
        }

        .role-meta {
            font-size: 12px;
            color: var(--text-muted);
        }

        .role-summary {
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.6;
        }

        .role-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
            margin-top: 12px;
        }

        .role-form .form-group {
            margin: 0;
        }

        .role-form textarea {
            min-height: 90px;
        }

        .probability-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
        }

        .probability-value {
            font-weight: 600;
            color: var(--primary-dark);
            min-width: 56px;
        }

        .probability-control input[type="range"] {
            flex: 1;
            accent-color: var(--primary);
        }

        .divider {
            height: 1px;
            background: rgba(148, 163, 184, 0.25);
            margin: 14px 0;
        }

        .table-row.row-highlight {
            animation: projectRowHighlight 1.6s ease;
        }

        @keyframes projectRowHighlight {
            0% {
                background: rgba(99, 102, 241, 0.18);
            }
            100% {
                background: transparent;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 1200px) {
            .app-layout {
                grid-template-columns: 240px 1fr;
            }

            .main-content {
                padding: 32px;
            }

            .table-head,
            .table-row {
                grid-template-columns: 2fr 1.4fr 1.4fr 1fr 1fr;
            }

            .table-row .contact-sub {
                display: none;
            }

            .file-tree-head,
            .file-entry {
                grid-template-columns: minmax(0, 2.2fr) minmax(0, 0.9fr) minmax(0, 1fr);
            }
        }

        @media (max-width: 980px) {
            .app-layout {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: sticky;
                top: 0;
                height: auto;
                border-bottom-left-radius: var(--radius-lg);
                border-bottom-right-radius: var(--radius-lg);
            }

            .main-content {
                padding: 28px;
            }

            .topbar {
                flex-direction: column;
                align-items: flex-start;
            }

            .topbar-actions {
                width: 100%;
                flex-wrap: wrap;
            }

            .search-wrapper input {
                width: 100%;
            }

            .dashboard-grid {
                --dashboard-columns: 1;
            }

            .metrics-grid {
                --metrics-columns: 1;
            }

            .pipeline {
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            }

            .pipeline-insights-grid {
                grid-template-columns: 1fr;
            }

            .stage-row {
                flex-direction: column;
                align-items: stretch;
            }

            .stage-progress {
                text-align: left;
                min-width: 0;
            }

            .lead-columns {
                grid-template-columns: 1fr;
            }

            .table-head,
            .table-row {
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 10px;
            }

            .table-head div:nth-child(n+3),
            .table-row div:nth-child(n+3) {
                display: none;
            }

            .file-actions {
                flex-direction: column;
                align-items: stretch;
            }

            .file-search input {
                width: 100%;
                min-width: 0;
            }

            .file-sources {
                padding: 18px;
            }

            .file-sources-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }

        @media (max-width: 640px) {
            .main-content {
                padding: 24px;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .priority-item {
                padding: 14px;
            }

            .owner-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .owner-metrics {
                text-align: left;
                width: 100%;
            }

            .task-board {
                grid-template-columns: 1fr;
            }

            .search-results {
                right: auto;
                width: calc(100vw - 64px);
            }

            .file-tree-head,
            .file-entry {
                grid-template-columns: minmax(0, 2fr) minmax(0, 0.8fr) minmax(0, 0.9fr);
            }

            .file-summary {
                flex-direction: column;
            }

            .file-sources-grid {
                grid-template-columns: 1fr;
            }

            .file-source-stats {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .process-summary {
                flex-direction: column;
                align-items: flex-start;
            }

            .process-summary-target {
                align-self: flex-start;
            }

            .feature-progress span {
                min-width: 40px;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <aside class="sidebar">
            <div class="sidebar-inner">
                <div class="brand">
                    <div class="brand-logo">
                        <i class="fa-solid fa-sparkles"></i>
                    </div>
                    <div>
                        <h1>HomeFlow CRM</h1>
                        <p>Ваш персональний центр керування</p>
                    </div>
                </div>

                <div class="nav-controls">
                    <div class="nav-search">
                        <i class="fa-solid fa-magnifying-glass" aria-hidden="true"></i>
                        <input type="search" id="navSearch" placeholder="Шукати модуль..." aria-label="Пошук по меню">
                    </div>
                    <select id="navFilter" class="nav-filter" aria-label="Фільтр модулів">
                        <option value="all">Усі модулі</option>
                        <option value="sales">Продажі</option>
                        <option value="operations">Операційні</option>
                        <option value="analytics">Аналітика</option>
                        <option value="admin">Адміністрування</option>
                    </select>
                </div>

                <nav class="nav" id="mainNav">
                    <div class="nav-group" data-group="core">
                        <div class="nav-group-label">Головне</div>
                        <button class="nav-item active" data-section-target="dashboardSection" data-nav-category="sales analytics" data-nav-keywords="дашборд показники аналітика огляд">
                            <i class="fa-solid fa-chart-line" aria-hidden="true"></i>
                            Дашборд
                        </button>
                        <button class="nav-item" data-section-target="pipelineSection" data-nav-category="sales" data-nav-keywords="воронка продажів ліди процес">
                            <i class="fa-solid fa-diagram-project" aria-hidden="true"></i>
                            Воронка продажів
                        </button>
                        <button class="nav-item" data-section-target="projectsSection" data-nav-category="sales operations" data-nav-keywords="проекти угоди бюджет">
                            <i class="fa-solid fa-briefcase" aria-hidden="true"></i>
                            Проекти
                        </button>
                    </div>

                    <div class="nav-group" data-group="clients">
                        <div class="nav-group-label">Клієнти та робота</div>
                        <button class="nav-item" data-section-target="contactsSection" data-nav-category="sales" data-nav-keywords="контакти клієнти партнери база">
                            <i class="fa-solid fa-user-group" aria-hidden="true"></i>
                            Контакти
                        </button>
                        <button class="nav-item" data-section-target="tasksSection" data-nav-category="operations sales" data-nav-keywords="завдання планер дії">
                            <i class="fa-solid fa-square-check" aria-hidden="true"></i>
                            Завдання
                        </button>
                    </div>

                    <div class="nav-group" data-group="operations">
                        <div class="nav-group-label">Операційні</div>
                        <button class="nav-item" data-section-target="filesSection" data-nav-category="operations" data-nav-keywords="файли документи сховище drag">
                            <i class="fa-solid fa-folder-tree" aria-hidden="true"></i>
                            Файли
                        </button>
                    </div>

                    <div class="nav-group" data-group="analytics">
                        <div class="nav-group-label">Аналітика</div>
                        <button class="nav-item" data-section-target="analyticsSection" data-nav-category="analytics" data-nav-keywords="інсайти звіти конверсія">
                            <i class="fa-solid fa-magnifying-glass-chart" aria-hidden="true"></i>
                            Інсайти
                        </button>
                    </div>

                    <div class="nav-group" data-group="admin">
                        <div class="nav-group-label">Адміністрування</div>
                        <button class="nav-item" data-section-target="rolesSection" data-nav-category="admin" data-nav-keywords="ролі права доступ команда">
                            <i class="fa-solid fa-user-shield" aria-hidden="true"></i>
                            Ролі та доступи
                        </button>
                        <button class="nav-item" data-section-target="settingsSection" data-nav-category="admin" data-nav-keywords="налаштування макет вигляд блоки">
                            <i class="fa-solid fa-sliders" aria-hidden="true"></i>
                            Налаштування
                        </button>
                    </div>
                </nav>

                <div class="sidebar-footer">
                    <div class="sidebar-stats">
                        <div>
                            <h4>Активні угоди</h4>
                            <strong id="sidebarDeals">0</strong>
                        </div>
                        <div>
                            <h4>Воронка</h4>
                            <strong id="sidebarPipeline">0 ₴</strong>
                        </div>
                    </div>
                    <button class="btn btn-outline" id="resetDataBtn">
                        <i class="fa-solid fa-rotate"></i>
                        Скинути демо-дані
                    </button>
                </div>
            </div>
        </aside>

        <main class="main-content">
            <header class="topbar">
                <div>
                    <h2>Вітаю у вашій сучасній CRM</h2>
                    <p class="topbar-sub">Контролюйте угоди, контакти й задачі з одного місця</p>
                </div>
                <div class="topbar-actions">
                    <div class="search-wrapper" id="globalSearchWrapper">
                        <i class="fa-solid fa-magnifying-glass"></i>
                        <input type="text" id="globalSearch" placeholder="Пошук угод, контактів, задач...">
                        <div class="search-results" id="searchResults"></div>
                    </div>
                    <button class="btn btn-primary" id="openLeadModalBtn">
                        <i class="fa-solid fa-plus"></i>
                        Новий лід
                    </button>
                </div>
            </header>

            <section id="dashboardSection" class="section active">
                <div class="section-header">
                    <div>
                        <h2>Огляд показників</h2>
                        <p>Ключові метрики вашої системи продажів у реальному часі</p>
                    </div>
                    <div class="section-actions">
                        <button class="btn btn-small-muted" id="refreshDashboardBtn">
                            <i class="fa-solid fa-arrows-rotate"></i>
                            Оновити
                        </button>
                    </div>
                </div>

                <div class="metrics-grid" id="metricCards" data-layout-area="metrics"></div>

                <div class="dashboard-grid" data-layout-area="dashboard">
                    <div class="card" data-block-id="dashboard-stage">
                        <h3>Розподіл воронки</h3>
                        <div class="stage-distribution" id="stageDistribution"></div>
                    </div>
                    <div class="card" data-block-id="dashboard-upcoming">
                        <h3>Майбутні активності</h3>
                        <div class="upcoming-list" id="upcomingActivities"></div>
                    </div>
                    <div class="card" data-block-id="dashboard-activity">
                        <h3>Останні оновлення</h3>
                        <div class="timeline" id="activityTimeline"></div>
                    </div>
                    <div class="card" data-block-id="dashboard-forecast">
                        <h3>Прогноз доходу</h3>
                        <div id="forecastCard"></div>
                    </div>
                    <div class="card chart-card" data-block-id="dashboard-sales-performance">
                        <h3>Динаміка продажів</h3>
                        <div class="chart-container">
                            <canvas id="salesPerformanceChart" aria-label="Динаміка прогнозованих та закритих угод за місяцями" role="img"></canvas>
                        </div>
                        <div class="chart-summary" id="salesPerformanceSummary"></div>
                    </div>
                    <div class="card chart-card" data-block-id="dashboard-team-productivity">
                        <h3>Продуктивність команди</h3>
                        <div class="chart-container">
                            <canvas id="teamProductivityChart" aria-label="Розподіл завдань команди за статусами" role="img"></canvas>
                        </div>
                        <div class="chart-summary" id="teamProductivitySummary"></div>
                    </div>
                    <div class="card chart-card" data-block-id="dashboard-custom-charts">
                        <div class="custom-chart-toolbar">
                            <div>
                                <h3>Користувацькі графіки</h3>
                                <p class="metric-sub">Створюйте власні аналітичні віджети, комбінуйте показники та обирайте будь-які типи діаграм.</p>
                            </div>
                            <div class="custom-chart-toolbar-actions">
                                <button class="btn btn-small-primary" id="addCustomChartBtn" type="button">
                                    <i class="fa-solid fa-plus"></i>
                                    Новий графік
                                </button>
                            </div>
                        </div>
                        <div id="customChartsContainer" class="custom-charts-grid" aria-live="polite"></div>
                    </div>
                    <div class="card" data-block-id="dashboard-process">
                        <h3>Контроль процесів</h3>
                        <div class="process-overview" id="processOverview"></div>
                    </div>
                    <div class="card" data-block-id="dashboard-feature-usage">
                        <h3>Залученість функціоналу</h3>
                        <div class="feature-usage" id="featureUsage"></div>
                    </div>
                    <div class="card card-feature-overview" data-block-id="dashboard-feature-overview">
                        <h3>Основні блоки майбутньої CRM</h3>
                        <p>Облік контактів та лідів — серце системи. Базові модулі поєднують клієнтську базу, календар та нагадування з таск-менеджером і конструктором звітів, а також інтерактивною панеллю моніторингу.</p>
                        <div class="feature-note">
                            <i class="fa-solid fa-user-shield" aria-hidden="true"></i>
                            <span>Розподіл ролей гарантує, що кожен користувач бачить лише власні завдання та контрагентів, зберігаючи фокус команди та безпеку даних.</span>
                        </div>
                        <div class="feature-groups">
                            <div class="feature-group">
                                <div class="feature-group-title">Базова функціональність</div>
                                <ul class="feature-list">
                                    <li>Contact management — структурований каталог клієнтів, партнерів та лідів.</li>
                                    <li>Reminders — персональні нагадування для запланованих активностей.</li>
                                    <li>Calendar — синхронізований календар зустрічей та ключових подій.</li>
                                    <li>Task manager — таск-менеджер для відстеження прогресу по кожній можливості.</li>
                                    <li>Report generator — генератор звітів із потрібними аналітичними зрізами.</li>
                                    <li>Dashboard — дашборд для моментального огляду статусу продажів.</li>
                                </ul>
                            </div>
                            <div class="feature-group">
                                <div class="feature-group-title">Основна функціональність</div>
                                <ul class="feature-list">
                                    <li>Система обміну файлами для безпечної співпраці над документами.</li>
                                    <li>Відстеження процесів, що показує вузькі місця у воронці та проектних потоках.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="pipelineSection" class="section">
                <div class="section-header">
                    <div>
                        <h2>Воронка продажів</h2>
                        <p>Відстежуйте стан кожної можливості та працюйте з ними інтерактивно</p>
                    </div>
                    <div class="section-actions">
                        <select id="pipelineOwnerFilter">
                            <option value="all">Всі менеджери</option>
                        </select>
                        <button class="btn btn-primary" id="addPipelineLeadBtn">
                            <i class="fa-solid fa-plus"></i>
                            Додати угоду
                        </button>
                    </div>
                </div>
                <div class="metrics-grid pipeline-metrics" id="pipelineMetrics"></div>
                <div class="pipeline" id="pipelineBoard"></div>
                <div class="pipeline-insights-grid">
                    <div class="card">
                        <h3>Статус етапів</h3>
                        <div class="stage-status-list" id="pipelineStageStatus"></div>
                    </div>
                    <div class="card">
                        <h3>Фокус уваги</h3>
                        <div class="priority-list" id="pipelinePriorityList"></div>
                    </div>
                    <div class="card">
                        <h3>Командне навантаження</h3>
                        <div class="owner-summary" id="pipelineOwnerSummary"></div>
                    </div>
                </div>
                <div class="card pipeline-activity-card">
                    <h3>Активність по воронці</h3>
                    <div class="timeline-list" id="pipelineActivityTimeline"></div>
                </div>
            </section>

            <section id="projectsSection" class="section">
                <div class="section-header">
                    <div>
                        <h2>Портфель проектів</h2>
                        <p>Контролюйте статус угод, команду та ймовірність успіху</p>
                    </div>
                    <div class="section-actions">
                        <input type="text" id="projectSearch" placeholder="Пошук проектів...">
                        <select id="projectStageFilter">
                            <option value="all">Всі етапи</option>
                        </select>
                        <div class="probability-filter">
                            <label for="projectProbabilityRange">Ймовірність</label>
                            <input type="range" id="projectProbabilityRange" min="0" max="100" step="5" value="0">
                            <span class="probability-value-badge" id="projectProbabilityValue">0%+</span>
                        </div>
                        <button class="btn btn-primary" id="openProjectModalBtn">
                            <i class="fa-solid fa-plus"></i>
                            Новий проект
                        </button>
                    </div>
                </div>
                <div class="metrics-grid" id="projectMetrics"></div>
                <div class="project-insights-grid">
                    <div class="card">
                        <h3>Картина за етапами</h3>
                        <div class="project-stage-list" id="projectStageBreakdown"></div>
                    </div>
                    <div class="card">
                        <h3>Фокус ризиків</h3>
                        <div class="project-risk-list" id="projectRiskList"></div>
                    </div>
                    <div class="card">
                        <h3>Навантаження команди</h3>
                        <div class="project-team-load" id="projectTeamLoad"></div>
                    </div>
                </div>
                <div class="card project-updates-card">
                    <div class="project-updates-header">
                        <div>
                            <h3>Останні оновлення</h3>
                            <p class="metric-sub">Слідкуйте за нотатками та активністю, щоб не втратити контекст</p>
                        </div>
                        <span class="project-updates-counter" id="projectUpdatesCount">0 записів</span>
                    </div>
                    <div class="project-updates-list" id="projectUpdates"></div>
                </div>
                <div class="projects-table">
                    <div class="table-head">
                        <div>Проект</div>
                        <div>Команда</div>
                        <div>Бюджет</div>
                        <div>Етап</div>
                        <div>Ймовірність</div>
                        <div>Менеджер</div>
                    </div>
                    <div id="projectsTable"></div>
                </div>
            </section>

            <section id="contactsSection" class="section">
                <div class="section-header">
                    <div>
                        <h2>Контактна база</h2>
                        <p>Усі клієнти, партнери та ключові особи у вашій екосистемі</p>
                    </div>
                    <div class="section-actions">
                        <input type="text" id="contactSearch" placeholder="Швидкий пошук...">
                        <input type="text" id="contactTagFilter" placeholder="Мітки (через кому)" list="contactTagOptions">
                        <datalist id="contactTagOptions"></datalist>
                        <select id="contactStatusFilter">
                            <option value="all">Всі категорії</option>
                            <option value="lead">Ліди</option>
                            <option value="potential">Потенційні клієнти</option>
                            <option value="customer">Клієнти</option>
                            <option value="vip">VIP‑клієнти</option>
                            <option value="partner">Партнери</option>
                        </select>
                        <button class="btn btn-primary" id="openContactModalBtn">
                            <i class="fa-solid fa-user-plus"></i>
                            Новий контакт
                        </button>
                    </div>
                </div>
                <div class="contacts-table">
                    <div class="table-head">
                        <div>Контакт</div>
                        <div>Компанія</div>
                        <div>Електронна пошта</div>
                        <div>Телефон</div>
                        <div>Категорія</div>
                        <div>Відповідальний</div>
                    </div>
                    <div id="contactsTable"></div>
                </div>

                <div class="contact-detail-layout" aria-live="polite">
                    <div class="card contact-profile-card" id="contactProfileCard">
                        <div class="contact-timeline-empty">Оберіть контакт, щоб побачити профіль клієнта.</div>
                    </div>
                    <div class="card contact-timeline-card" id="contactTimelineCard">
                        <div class="contact-timeline-empty">Історія взаємодій з'явиться після вибору контакту.</div>
                    </div>
                </div>

                <div class="card contact-insights-card" aria-labelledby="contactManagementTitle">
                    <div class="contact-insights-header">
                        <div>
                            <h3 id="contactManagementTitle">Контакт-менеджмент</h3>
                            <p class="metric-sub">Ключові практики ведення клієнтської бази за рекомендаціями NetSuite.</p>
                        </div>
                        <span class="contact-insights-source">
                            <i class="fa-solid fa-circle-info" aria-hidden="true"></i>
                            На основі рекомендацій NetSuite
                        </span>
                    </div>
                    <div class="contact-insights-grid">
                        <div class="contact-insight-item">
                            <span class="contact-insight-icon" aria-hidden="true">
                                <i class="fa-solid fa-address-book"></i>
                            </span>
                            <div>
                                <h4>Єдина база контактів</h4>
                                <p>CRM зберігає повний профіль клієнта: ім’я, контактні дані, адресу, соціальні мережі та історію взаємодій. Така база стає єдиним джерелом правди для маркетингу й продажів і допомагає персоналізувати комунікації.</p>
                            </div>
                        </div>
                        <div class="contact-insight-item">
                            <span class="contact-insight-icon" aria-hidden="true">
                                <i class="fa-solid fa-handshake-simple"></i>
                            </span>
                            <div>
                                <h4>Облік взаємодій</h4>
                                <p>Листування, дзвінки, зустрічі та інші контакти логуються прямо в картці клієнта, а Zoom Contact Center (zoom.com) автоматично зберігає записи, теги й фолоу-ап стратегії.</p>
                            </div>
                        </div>
                        <div class="contact-insight-item">
                            <span class="contact-insight-icon" aria-hidden="true">
                                <i class="fa-solid fa-envelope-open-text"></i>
                            </span>
                            <div>
                                <h4>Автооновлення контактів</h4>
                                <p>Імпорт з електронних скриньок і веб-форм за рекомендаціями Discover CRM (discovercrm.com) автоматично створює та оновлює записи без ручного введення.</p>
                            </div>
                        </div>
                        <div class="contact-insight-item">
                            <span class="contact-insight-icon" aria-hidden="true">
                                <i class="fa-solid fa-circle-nodes"></i>
                            </span>
                            <div>
                                <h4>Збагачення профілю</h4>
                                <p>API-інтеграції з бізнес-довідниками й маркетинговими платформами (Discover CRM) додають галузь, розмір компанії та соціальні профілі без додаткових зусиль.</p>
                            </div>
                        </div>
                        <div class="contact-insight-item">
                            <span class="contact-insight-icon" aria-hidden="true">
                                <i class="fa-solid fa-file-contract"></i>
                            </span>
                            <div>
                                <h4>Менеджер документів</h4>
                                <p>Пропозиції, контракти та рахунки зберігаються в картці клієнта з можливістю заповнювати, погоджувати й надсилати документи безпосередньо з CRM.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="tasksSection" class="section">
                <div class="section-header">
                    <div>
                        <h2>Планер дій</h2>
                        <p>Пріоритетні задачі команди з можливістю швидкого оновлення статусу</p>
                    </div>
                    <div class="section-actions">
                        <button class="btn btn-primary" id="openTaskModalBtn">
                            <i class="fa-solid fa-circle-plus"></i>
                            Нове завдання
                        </button>
                    </div>
                </div>
                <div class="task-layout">
                    <div class="task-main">
                        <div class="task-controls">
                            <div class="task-search">
                                <i class="fa-solid fa-magnifying-glass"></i>
                                <input type="search" id="taskSearchInput" placeholder="Пошук у задачах..." aria-label="Пошук задач">
                            </div>
                            <div class="task-filters">
                                <select id="taskOwnerFilter" class="task-filter" aria-label="Фільтр за відповідальним">
                                    <option value="all">Вся команда</option>
                                </select>
                                <select id="taskPriorityFilter" class="task-filter" aria-label="Фільтр за пріоритетом">
                                    <option value="all">Всі пріоритети</option>
                                    <option value="high">Високий</option>
                                    <option value="medium">Середній</option>
                                    <option value="low">Низький</option>
                                </select>
                                <select id="taskDueFilter" class="task-filter" aria-label="Фільтр за дедлайном">
                                    <option value="all">Всі дедлайни</option>
                                    <option value="overdue">Прострочені</option>
                                    <option value="today">На сьогодні</option>
                                    <option value="week">На 7 днів</option>
                                    <option value="done">Завершені</option>
                                </select>
                                <button type="button" class="task-filter-reset" id="resetTaskFilters">
                                    <i class="fa-solid fa-filter-circle-xmark"></i>
                                    Скинути
                                </button>
                            </div>
                        </div>
                        <div class="task-process-summary" id="taskProcessSummary"></div>
                        <div class="task-board" id="taskBoard"></div>
                    </div>
                    <aside class="task-sidebar">
                        <div class="card task-sidebar-card">
                            <div class="task-sidebar-header">
                                <h3>Моніторинг процесів</h3>
                                <p class="metric-sub">Оновлюється під час роботи з задачами</p>
                            </div>
                            <div class="task-summary-grid" id="taskSummaryGrid"></div>
                        </div>
                        <div class="card task-sidebar-card">
                            <h3>Розподіл по статусах</h3>
                            <div class="task-flow-list" id="taskFlowBreakdown"></div>
                        </div>
                        <div class="card task-sidebar-card">
                            <h3>Навантаження команди</h3>
                            <div class="task-workload-list" id="taskTeamWorkload"></div>
                        </div>
                        <div class="card task-sidebar-card">
                            <h3>Залученість функціоналу</h3>
                            <div class="task-feature-list" id="taskFeatureInsights"></div>
                        </div>
                    </aside>
                </div>
            </section>

            <section id="filesSection" class="section">
                <div class="section-header">
                    <div>
                        <h2>Файловий оглядач</h2>
                        <p>Підключайте локальні папки (наприклад D:\O), щоб швидко переглядати маркетингові матеріали.</p>
                    </div>
                    <div class="section-actions">
                        <span class="file-status" id="fileScanStatus"></span>
                    </div>
                </div>
                <div class="file-manager">
                    <div class="file-actions">
                        <button class="btn btn-primary" id="connectFolderBtn">
                            <i class="fa-solid fa-folder-open"></i>
                            Підключити папку
                        </button>
                        <input type="file" id="folderInput" class="file-input-hidden" webkitdirectory aria-label="Обрати локальну папку">
                        <select id="folderSnapshotsSelect" aria-label="Збережені папки"></select>
                        <div class="file-search">
                            <i class="fa-solid fa-magnifying-glass"></i>
                            <input type="text" id="fileSearchInput" placeholder="Пошук у вибраній папці...">
                        </div>
                    </div>
                    <div class="file-sources">
                        <div class="file-sources-header">
                            <div>
                                <h3>Підключені джерела</h3>
                                <p class="metric-sub">Локальні папки та хмарні каталоги, доступні для швидкого огляду.</p>
                            </div>
                            <div class="file-sources-actions">
                                <button class="btn btn-small-muted" id="addCloudSourceBtn">
                                    <i class="fa-solid fa-cloud-plus"></i>
                                    Додати хмарний каталог
                                </button>
                            </div>
                        </div>
                        <div class="file-sources-grid" id="fileSourceGrid"></div>
                    </div>
                    <div class="file-summary" id="fileSummary"></div>
                    <div class="file-process-dashboard">
                        <div class="file-process-grid" id="fileProcessGrid" aria-live="polite"></div>
                        <div class="file-usage-layout">
                            <section class="file-usage-card">
                                <div class="file-usage-header">
                                    <h3>Моніторинг процесів</h3>
                                    <p class="metric-sub">Контролюйте стан синхронізації та підключень</p>
                                </div>
                                <div class="file-status-list" id="fileProcessStatusList"></div>
                            </section>
                            <section class="file-usage-card">
                                <div class="file-usage-header">
                                    <h3>Використання функціоналу</h3>
                                    <p class="metric-sub">Відстежуйте ключові можливості файлового модуля</p>
                                </div>
                                <div class="file-feature-list" id="fileFeatureUsage"></div>
                            </section>
                        </div>
                        <section class="file-activity-card">
                            <div class="file-usage-header">
                                <h3>Журнал активності</h3>
                                <p class="metric-sub">Останні сканування та синхронізації каталогів</p>
                            </div>
                            <div class="file-activity-timeline" id="fileActivityTimeline"></div>
                        </section>
                    </div>
                    <div class="file-monitor-guide" aria-labelledby="fileMonitorTitle">
                        <div class="file-monitor-header">
                            <div>
                                <h3 id="fileMonitorTitle">Моніторинг змін у файловій системі</h3>
                                <p>Python-бібліотека <strong>watchdog</strong> фіксує створення, модифікацію, переміщення та видалення файлів у реальному часі. Рішення працює на Windows, macOS і Linux, тому команда всюди отримує однаковий контроль.</p>
                            </div>
                            <span class="badge badge-info">
                                <i class="fa-brands fa-python" aria-hidden="true"></i>
                                Watchdog
                            </span>
                        </div>
                        <div class="file-monitor-grid">
                            <div class="file-monitor-item">
                                <i class="fa-solid fa-eye" aria-hidden="true"></i>
                                <div>
                                    <strong>Observer</strong>
                                    <p>Слухає вибрані каталоги та миттєво сповіщає про створення, переміщення чи видалення файлів.</p>
                                </div>
                            </div>
                            <div class="file-monitor-item">
                                <i class="fa-solid fa-code-branch" aria-hidden="true"></i>
                                <div>
                                    <strong>FileSystemEventHandler</strong>
                                    <p>Перевизначайте методи <code>on_created</code>, <code>on_modified</code>, <code>on_deleted</code> і <code>on_moved</code>, щоб автоматично логувати активність у CRM.</p>
                                </div>
                            </div>
                        </div>
                        <ul class="file-monitor-list">
                            <li><strong>Кілька каталогів.</strong> Додавайте будь-яку кількість шляхів до одного Observer, щоб синхронно відстежувати робочі папки команди.</li>
                            <li><strong>Фільтри за розширеннями.</strong> Реагуйте лише на важливі формати (наприклад, <code>.docx</code> або <code>.pdf</code>), щоб уникати шуму.</li>
                            <li><strong>Власні сценарії.</strong> Обробники подій легко доповнити записом у базу CRM, відправкою сповіщень чи запуском інтеграцій.</li>
                        </ul>
                        <div class="file-monitor-note">
                            <i class="fa-solid fa-database" aria-hidden="true"></i>
                            <p>Зберігайте журнал подій безпосередньо у CRM, щоб менеджери миттєво бачили нові документи, оновлення договірних файлів та видалення матеріалів.</p>
                        </div>
                        <div class="file-monitor-footer">
                            <a href="https://pythonsnacks.com" target="_blank" rel="noopener">Докладніше про watchdog на pythonsnacks.com</a>
                        </div>
                    </div>
                    <div class="file-tree">
                        <div class="file-tree-head">
                            <div>Елемент</div>
                            <div>Розмір</div>
                            <div>Оновлено</div>
                        </div>
                        <div class="file-tree-body" id="fileTreeBody"></div>
                    </div>
                </div>
            </section>

            <section id="analyticsSection" class="section">
                <div class="section-header">
                    <div>
                        <h2>Глибинні інсайти</h2>
                        <p>Показники ефективності команди та здоров'я воронки</p>
                    </div>
                    <div class="section-actions">
                        <span class="badge badge-success" id="insightUpdated"></span>
                    </div>
                </div>
                <div class="analytics-grid">
                    <div class="card call-center-card" id="callCenterAnalyticsCard">
                        <div class="call-center-header">
                            <div>
                                <h3>Контакт-центр Zoom</h3>
                                <p class="metric-sub">Live KPI, AI-транскрипції та контроль навантаження</p>
                            </div>
                            <div class="call-center-status offline" id="callCenterStatus">
                                <span class="status-dot" aria-hidden="true"></span>
                                <span id="callCenterStatusLabel">Очікуємо дані…</span>
                            </div>
                        </div>
                        <div class="call-center-metrics" data-call-metrics>
                            <div class="call-quality-empty">Ініціалізація даних контакт-центру…</div>
                        </div>
                        <div class="call-center-queues" data-call-queues></div>
                        <div class="call-center-chart">
                            <div class="call-center-chart-head">
                                <div>
                                    <h4>Навантаження та сервісний рівень</h4>
                                    <p class="metric-sub">Дані надходять із Zoom Contact Center в режимі реального часу</p>
                                </div>
                                <div class="call-center-chart-actions">
                                    <div class="chart-summary" id="callCenterChartSummary"></div>
                                    <button type="button" class="btn btn-small-muted" id="callCenterRefreshBtn">
                                        <i class="fa-solid fa-rotate-right" aria-hidden="true"></i>
                                        Оновити
                                    </button>
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="callCenterVolumeChart" aria-label="Динаміка дзвінків контакт-центру" role="img"></canvas>
                            </div>
                        </div>
                        <div class="call-center-quality">
                            <div class="call-center-quality-head">
                                <h4>AI-інсайти по розмовах</h4>
                                <p class="metric-sub">Розпізнавання мови, емоцій та ключових питань</p>
                            </div>
                            <div class="call-quality-feed" data-quality-feed>
                                <div class="call-quality-empty">Очікуємо на перші розмови для аналізу…</div>
                            </div>
                        </div>
                    </div>
                    <div class="card role-dashboard-card">
                        <div class="role-dashboard-header">
                            <div>
                                <h3>Рольові дашборди</h3>
                                <p class="metric-sub">Готові перегляди для продажу, маркетингу та підтримки за рекомендаціями NetSuite.</p>
                            </div>
                            <span class="badge badge-info">
                                <i class="fa-solid fa-chart-simple" aria-hidden="true"></i>
                                NetSuite
                            </span>
                        </div>
                        <div class="role-dashboard-tabs" role="tablist" aria-label="Рольові дашборди">
                            <button type="button" class="role-dashboard-tab" data-role-dashboard="sales" aria-selected="true">Продажі</button>
                            <button type="button" class="role-dashboard-tab" data-role-dashboard="marketing" aria-selected="false">Маркетинг</button>
                            <button type="button" class="role-dashboard-tab" data-role-dashboard="support" aria-selected="false">Підтримка</button>
                        </div>
                        <div class="role-dashboard-content" id="roleDashboardContent" aria-live="polite"></div>
                    </div>
                    <div class="card">
                        <h3>Конверсія по етапах</h3>
                        <div class="progress-list" id="conversionInsights"></div>
                    </div>
                    <div class="card">
                        <h3>Продуктивність менеджерів</h3>
                        <div class="progress-list" id="teamPerformance"></div>
                    </div>
                    <div class="card">
                        <h3>Угоди, що потребують уваги</h3>
                        <div class="lead-focus-list" id="leadFocus"></div>
                    </div>
                    <div class="card">
                        <h3>Темп закриття</h3>
                        <div id="velocityInsights"></div>
                    </div>
                    <div class="card report-builder-card">
                        <div class="report-builder-header">
                            <div>
                                <h3>Гнучкі звіти й фільтри</h3>
                                <p class="metric-sub">Збирайте будь-які зрізи даних, групуйте за періодами, каналами чи сегментами клієнтів та експортуйте результати.</p>
                            </div>
                        </div>
                        <div class="report-builder-controls">
                            <div class="report-control">
                                <label for="reportDataset">Дані</label>
                                <select id="reportDataset">
                                    <option value="leads">Угоди</option>
                                    <option value="projects">Проекти</option>
                                    <option value="support">Підтримка</option>
                                </select>
                            </div>
                            <div class="report-control">
                                <label for="reportPeriod">Період</label>
                                <select id="reportPeriod"></select>
                            </div>
                            <div class="report-control">
                                <label for="reportGrouping">Групування</label>
                                <select id="reportGrouping"></select>
                            </div>
                            <div class="report-control">
                                <label for="reportFilter">Фільтр</label>
                                <select id="reportFilter"></select>
                            </div>
                            <button class="btn btn-small-primary" type="button" id="reportExportBtn">
                                <i class="fa-solid fa-file-export" aria-hidden="true"></i>
                                Експорт CSV
                            </button>
                        </div>
                        <div class="report-summary" id="reportSummary"></div>
                        <div class="report-preview">
                            <div class="report-preview-head" id="reportPreviewHead"></div>
                            <div id="reportPreviewBody"></div>
                        </div>
                        <div class="report-export-status" id="reportExportStatus" aria-live="polite"></div>
                    </div>
                    <div class="card forecasting-card">
                        <div class="forecasting-header">
                            <div>
                                <h3>Прогнозування</h3>
                                <p class="metric-sub">Автоматичне зважування угод за expected close date та close probability — підхід support.monday.com.</p>
                            </div>
                            <span class="badge badge-info">
                                <i class="fa-solid fa-sparkles" aria-hidden="true"></i>
                                support.monday.com
                            </span>
                        </div>
                        <div class="forecasting-summary" id="forecastingSummary"></div>
                        <div class="forecasting-table">
                            <div class="forecasting-head" id="forecastingHead"></div>
                            <div id="forecastingTable"></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="rolesSection" class="section">
                <div class="section-header">
                    <div>
                        <h2>Ролі та доступи</h2>
                        <p>Розподіляйте відповідальність та обмежуйте доступ до критичних дій</p>
                    </div>
                    <div class="section-actions">
                        <span class="badge badge-info" id="currentUserBadge">
                            <i class="fa-solid fa-user" aria-hidden="true"></i>
                            <span id="currentUserName">Користувач</span>
                        </span>
                    </div>
                </div>

                <div class="role-layout">
                    <div class="card">
                        <h3>Модель доступу</h3>
                        <p class="role-summary">CRM містить набір рекомендованих ролей: Owner, Manager, Storekeeper та Support. Кожна роль має власні межі видимості даних і дозволів на зміни.</p>
                        <div class="role-definition-grid" id="roleDefinitionGrid"></div>
                        <div class="role-warning" role="alert">
                            <i class="fa-solid fa-triangle-exclamation" aria-hidden="true"></i>
                            <span>Менеджери не можуть призначити собі роль Owner. Передача прав власника доступна лише чинному Owner або адміністратору.</span>
                        </div>
                    </div>
                    <div class="card">
                        <h3>Ролі команди</h3>
                        <p class="role-summary">Призначте кожному учаснику відповідну роль та перегляньте дозволи.</p>
                        <div class="role-table" id="roleAssignmentsTable"></div>
                    </div>
                </div>

                <div class="card">
                    <h3>Створити кастомну роль</h3>
                    <p class="role-summary">Додайте власну роль для окремих відділів. Базові права можна успадкувати з існуючих ролей.</p>
                    <form id="customRoleForm" class="role-form">
                        <div class="form-group">
                            <label for="customRoleName">Назва ролі</label>
                            <input type="text" id="customRoleName" placeholder="Наприклад, Analyst" required>
                        </div>
                        <div class="form-group">
                            <label for="customRoleBase">Базувати на</label>
                            <select id="customRoleBase"></select>
                        </div>
                        <div class="form-group full">
                            <label for="customRoleNotes">Доступні дії</label>
                            <textarea id="customRoleNotes" placeholder="Опишіть, що може робити ця роль."></textarea>
                        </div>
                        <div class="modal-actions">
                            <button type="submit" class="btn btn-small-primary">Зберегти роль</button>
                        </div>
                    </form>
                </div>
            </section>

            <section id="settingsSection" class="section">
                <div class="section-header">
                    <div>
                        <h2>Налаштування інтерфейсу</h2>
                        <p>Керуйте розміщенням блоків та зовнішнім виглядом головної панелі</p>
                    </div>
                </div>
                <div class="settings-grid">
                    <div class="card settings-card">
                        <h3>Макет дашборду</h3>
                        <p class="metric-sub">Перетягуйте картки прямо на дашборді або зафіксуйте бажану кількість колонок.</p>
                        <div class="setting-control">
                            <span class="setting-label">Колонки дашборду</span>
                            <div class="setting-options" role="radiogroup" aria-label="Кількість колонок дашборду">
                                <label class="option-pill"><input type="radio" name="dashboardColumns" value="auto"><span>Авто</span></label>
                                <label class="option-pill"><input type="radio" name="dashboardColumns" value="1"><span>1</span></label>
                                <label class="option-pill"><input type="radio" name="dashboardColumns" value="2"><span>2</span></label>
                                <label class="option-pill"><input type="radio" name="dashboardColumns" value="3"><span>3</span></label>
                                <label class="option-pill"><input type="radio" name="dashboardColumns" value="4"><span>4</span></label>
                            </div>
                        </div>
                        <div class="setting-control">
                            <span class="setting-label">Колонки швидких метрик</span>
                            <div class="setting-options" role="radiogroup" aria-label="Кількість колонок швидких метрик">
                                <label class="option-pill"><input type="radio" name="metricsColumns" value="auto"><span>Авто</span></label>
                                <label class="option-pill"><input type="radio" name="metricsColumns" value="1"><span>1</span></label>
                                <label class="option-pill"><input type="radio" name="metricsColumns" value="2"><span>2</span></label>
                                <label class="option-pill"><input type="radio" name="metricsColumns" value="3"><span>3</span></label>
                                <label class="option-pill"><input type="radio" name="metricsColumns" value="4"><span>4</span></label>
                            </div>
                        </div>
                        <div class="setting-control">
                            <span class="setting-label">Мінімальна ширина карток дашборду</span>
                            <div class="setting-slider">
                                <input type="range" id="dashboardMinWidthSlider" min="260" max="420" step="10" aria-label="Мінімальна ширина карток дашборду">
                                <span class="setting-slider-value" id="dashboardMinWidthValue"></span>
                            </div>
                        </div>
                        <div class="setting-control">
                            <span class="setting-label">Мінімальна ширина швидких метрик</span>
                            <div class="setting-slider">
                                <input type="range" id="metricsMinWidthSlider" min="180" max="320" step="10" aria-label="Мінімальна ширина метрик">
                                <span class="setting-slider-value" id="metricsMinWidthValue"></span>
                            </div>
                        </div>
                        <label class="setting-toggle">
                            <input type="checkbox" id="compactLayoutToggle">
                            <span class="setting-toggle-indicator" aria-hidden="true"></span>
                            <span class="setting-toggle-label">Компактний режим карток</span>
                        </label>
                        <p class="metric-sub">Компактний режим зменшує відступи та дозволяє вмістити більше інформації на екран.</p>
                    </div>
                    <div class="card settings-card">
                        <h3>Видимість блоків</h3>
                        <p class="metric-sub">Увімкніть лише найважливіші для вас картки. Приховані елементи можна повернути будь-коли.</p>
                        <div class="settings-order-columns">
                            <div>
                                <h4>Дашборд</h4>
                                <div class="setting-checkbox-list" id="dashboardVisibilityControls"></div>
                            </div>
                            <div>
                                <h4>Швидкі метрики</h4>
                                <div class="setting-checkbox-list" id="metricsVisibilityControls"></div>
                            </div>
                        </div>
                    </div>
                    <div class="card settings-card">
                        <h3>Поточний порядок</h3>
                        <p class="metric-sub">Перетягніть блоки на сторінці або скористайтесь кнопкою нижче, щоб повернути стандартний вигляд.</p>
                        <div class="settings-order-columns">
                            <div>
                                <h4>Дашборд</h4>
                                <ol class="settings-order-list" id="dashboardOrderPreview"></ol>
                            </div>
                            <div>
                                <h4>Швидкі метрики</h4>
                                <ol class="settings-order-list" id="metricsOrderPreview"></ol>
                            </div>
                        </div>
                        <button type="button" class="btn btn-small-muted" id="resetLayoutBtn">
                            <i class="fa-solid fa-arrows-rotate"></i>
                            Скинути макет
                        </button>
                    </div>
                </div>
            </section>
        </main>
    </div>
    <!-- Модальні вікна -->
    <div class="modal" id="addLeadModal">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3>Новий лід</h3>
                <button class="modal-close" type="button" data-close>&times;</button>
            </div>
            <form id="leadForm" class="form-grid">
                <div class="form-group">
                    <label for="leadTitle">Назва можливості</label>
                    <input type="text" id="leadTitle" placeholder="Наприклад, Розробка CRM для NovaPay" required>
                </div>
                <div class="form-group">
                    <label for="leadCompany">Компанія</label>
                    <input type="text" id="leadCompany" placeholder="Компанія або бренд" required>
                </div>
                <div class="form-group">
                    <label for="leadValue">Бюджет, ₴</label>
                    <input type="number" id="leadValue" min="0" step="1000" required>
                </div>
                <div class="form-group">
                    <label for="leadStage">Етап</label>
                    <select id="leadStage" required></select>
                </div>
                <div class="form-group">
                    <label for="leadProbability">Ймовірність, %</label>
                    <input type="number" id="leadProbability" min="0" max="100" step="5" value="30">
                </div>
                <div class="form-group">
                    <label for="leadExpectedClose">Очікувана дата закриття</label>
                    <input type="date" id="leadExpectedClose">
                </div>
                <div class="form-group">
                    <label for="leadSource">Джерело ліда</label>
                    <select id="leadSource" required></select>
                    <p class="form-hint" id="leadRoutingHint"></p>
                </div>
                <div class="form-group">
                    <label for="leadOwner">Менеджер</label>
                    <select id="leadOwner" required></select>
                </div>
                <div class="form-group">
                    <label for="leadQualification">Кваліфікація</label>
                    <select id="leadQualification"></select>
                </div>
                <div class="form-group">
                    <label for="leadScore">Готовність до купівлі, %</label>
                    <div class="input-with-indicator">
                        <input type="range" id="leadScore" min="0" max="100" step="5" value="50">
                        <span class="input-indicator" id="leadScoreValue">50%</span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="leadContactName">Контактна особа</label>
                    <input type="text" id="leadContactName" placeholder="Ім'я та прізвище">
                </div>
                <div class="form-group">
                    <label for="leadContactEmail">Email</label>
                    <input type="email" id="leadContactEmail" placeholder="name@company.ua">
                </div>
                <div class="form-group">
                    <label for="leadContactPhone">Телефон</label>
                    <input type="tel" id="leadContactPhone" placeholder="+380">
                </div>
                <div class="form-group full">
                    <label for="leadTags">Мітки</label>
                    <input type="text" id="leadTags" placeholder="Введіть через кому: Терміново, VIP">
                </div>
                <div class="form-group full">
                    <label for="leadFiles">Файли та папки</label>
                    <div class="file-dropzone" id="leadFileDropzone" role="button" tabindex="0" aria-describedby="leadFileHint">
                        <input type="file" id="leadFiles" class="file-input-hidden" multiple webkitdirectory aria-label="Додати файли та папки до ліда">
                        <div class="file-dropzone-content">
                            <i class="fa-solid fa-cloud-arrow-up"></i>
                            <div class="file-dropzone-text">
                                <strong>Перетягніть сюди файли</strong>
                                <div class="file-dropzone-actions">або <button type="button" class="file-browse-btn" id="leadFileBrowseBtn">оберіть</button> на пристрої</div>
                                <p class="upload-hint" id="leadFileHint">Можна завантажувати декілька файлів та цілі папки (Chrome, Edge).</p>
                            </div>
                        </div>
                    </div>
                    <div class="upload-progress" id="leadUploadProgress" role="status" aria-live="polite">
                        <strong id="leadUploadLabel">Готово</strong>
                        <div class="upload-progress-track">
                            <div class="upload-progress-value" id="leadUploadBar"></div>
                        </div>
                        <span id="leadUploadText">Очікування файлів…</span>
                    </div>
                    <div class="file-list" id="leadFileList"></div>
                </div>
                <div class="form-group full">
                    <label for="leadNotes">Примітка</label>
                    <textarea id="leadNotes" placeholder="Вкажіть додаткові деталі..."></textarea>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-small-muted" data-close>Скасувати</button>
                    <button type="submit" class="btn btn-primary">Зберегти</button>
                </div>
            </form>
        </div>
    </div>

    <div class="modal" id="addProjectModal">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3>Новий проект</h3>
                <button class="modal-close" type="button" data-close>&times;</button>
            </div>
            <form id="projectForm" class="form-grid">
                <div class="form-group">
                    <label for="projectName">Назва проекту</label>
                    <input type="text" id="projectName" placeholder="Наприклад, CRM для NovaPay" required>
                </div>
                <div class="form-group">
                    <label for="projectCompany">Компанія</label>
                    <input type="text" id="projectCompany" placeholder="Компанія або бренд" required>
                </div>
                <div class="form-group">
                    <label for="projectBudget">Бюджет, ₴</label>
                    <input type="number" id="projectBudget" min="0" step="1000" required>
                </div>
                <div class="form-group">
                    <label for="projectStage">Етап</label>
                    <select id="projectStage" required></select>
                </div>
                <div class="form-group">
                    <label for="projectProbability">Ймовірність успіху, %</label>
                    <input type="number" id="projectProbability" min="0" max="100" step="5" value="50" required>
                </div>
                <div class="form-group">
                    <label for="projectOwner">Відповідальний</label>
                    <select id="projectOwner" required></select>
                </div>
                <div class="form-group">
                    <label for="projectTeam">Команда</label>
                    <select id="projectTeam" multiple size="4"></select>
                    <span class="input-hint">Утримуйте Ctrl / Command, щоб обрати кілька учасників.</span>
                </div>
                <div class="form-group">
                    <label for="projectContact">Контактна особа</label>
                    <input type="text" id="projectContact" placeholder="Ім'я та посада">
                </div>
                <div class="form-group full">
                    <label for="projectTags">Мітки</label>
                    <input type="text" id="projectTags" placeholder="CRM, Запуск, VIP">
                </div>
                <div class="form-group full">
                    <label for="projectSummary">Короткий опис</label>
                    <textarea id="projectSummary" placeholder="Основні задачі або наступні кроки"></textarea>
                </div>
                <div class="form-group full">
                    <label for="projectFiles">Вкладення</label>
                    <div class="file-dropzone" id="projectFileDropzone" role="button" tabindex="0" aria-describedby="projectFileHint">
                        <input type="file" id="projectFiles" class="file-input-hidden" multiple aria-label="Додати файли до проекту">
                        <div class="file-dropzone-content">
                            <i class="fa-solid fa-cloud-arrow-up"></i>
                            <div class="file-dropzone-text">
                                <strong>Перетягніть документи проекту</strong>
                                <div class="file-dropzone-actions">або <button type="button" class="file-browse-btn" id="projectFileBrowseBtn">оберіть</button> вручну</div>
                                <p class="upload-hint" id="projectFileHint">Підтримуються бриф, кошториси, медіаплани та інші документи.</p>
                            </div>
                        </div>
                    </div>
                    <div class="upload-progress" id="projectUploadProgress" role="status" aria-live="polite">
                        <strong id="projectUploadLabel">Готово</strong>
                        <div class="upload-progress-track">
                            <div class="upload-progress-value" id="projectUploadBar"></div>
                        </div>
                        <span id="projectUploadText">Очікування файлів…</span>
                    </div>
                    <div class="file-list" id="projectFileList"></div>
                </div>
                <div class="form-group full">
                    <label for="projectNotes">Нотатки</label>
                    <textarea id="projectNotes" placeholder="Кожну думку вводьте з нового рядка"></textarea>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-small-muted" data-close>Скасувати</button>
                    <button type="submit" class="btn btn-primary">Додати проект</button>
                </div>
            </form>
        </div>
    </div>

    <div class="modal" id="addContactModal">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3>Новий контакт</h3>
                <button class="modal-close" type="button" data-close>&times;</button>
            </div>
            <form id="contactForm" class="form-grid">
                <div class="form-group">
                    <label for="contactName">ПІБ</label>
                    <input type="text" id="contactName" required>
                </div>
                <div class="form-group">
                    <label for="contactCompany">Компанія</label>
                    <input type="text" id="contactCompany" placeholder="Організація або бренд" required>
                </div>
                <div class="form-group">
                    <label for="contactRole">Роль</label>
                    <input type="text" id="contactRole" placeholder="Посада або роль">
                </div>
                <div class="form-group">
                    <label for="contactEmail">Email</label>
                    <input type="email" id="contactEmail">
                </div>
                <div class="form-group">
                    <label for="contactPhone">Телефон</label>
                    <input type="tel" id="contactPhone">
                </div>
                <div class="form-group">
                    <label for="contactStatus">Категорія</label>
                    <select id="contactStatus"></select>
                </div>
                <div class="form-group">
                    <label for="contactLifecycle">Життєвий цикл</label>
                    <select id="contactLifecycle">
                        <option value="prospect">Потенційний клієнт</option>
                        <option value="customer">Чинний клієнт</option>
                        <option value="expansion">Розвиток співпраці</option>
                        <option value="advocate">Лояльний клієнт</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="contactOwner">Менеджер</label>
                    <select id="contactOwner"></select>
                </div>
                <div class="form-group">
                    <label for="contactChannel">Бажаний канал</label>
                    <select id="contactChannel">
                        <option value="email">Email</option>
                        <option value="phone">Телефон</option>
                        <option value="video">Відеозв'язок</option>
                        <option value="chat">Чат/месенджер</option>
                        <option value="portal">Портал підтримки</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="contactWebsite">Вебсайт</label>
                    <input type="url" id="contactWebsite" placeholder="https://">
                </div>
                <div class="form-group">
                    <label for="contactLinkedin">LinkedIn</label>
                    <input type="url" id="contactLinkedin" placeholder="https://linkedin.com/...">
                </div>
                <div class="form-group">
                    <label for="contactTimezone">Часовий пояс</label>
                    <input type="text" id="contactTimezone" placeholder="Europe/Kyiv">
                </div>
                <div class="form-group full">
                    <label for="contactStreet">Адреса</label>
                    <input type="text" id="contactStreet" placeholder="Вулиця, будинок, офіс">
                </div>
                <div class="form-group">
                    <label for="contactCity">Місто</label>
                    <input type="text" id="contactCity" placeholder="Місто">
                </div>
                <div class="form-group">
                    <label for="contactCountry">Країна</label>
                    <input type="text" id="contactCountry" placeholder="Країна">
                </div>
                <div class="form-group">
                    <label for="contactPostal">Поштовий код</label>
                    <input type="text" id="contactPostal" placeholder="01001">
                </div>
                <div class="form-group">
                    <label for="contactIndustry">Індустрія</label>
                    <input type="text" id="contactIndustry" placeholder="Сфера діяльності">
                </div>
                <div class="form-group">
                    <label for="contactEmployees">К-сть працівників</label>
                    <input type="number" id="contactEmployees" min="0" step="1">
                </div>
                <div class="form-group">
                    <label for="contactRevenue">Річний оборот, ₴</label>
                    <input type="number" id="contactRevenue" min="0" step="1000">
                </div>
                <div class="form-group full">
                    <label for="contactSegments">Додаткові категорії</label>
                    <select id="contactSegments" multiple></select>
                    <p class="form-hint">Утримуйте <strong>Ctrl/Cmd</strong>, щоб обрати декілька сегментів.</p>
                </div>
                <div class="form-group full">
                    <label for="contactTags">Мітки</label>
                    <input type="text" id="contactTags" placeholder="VIP, Рекомендація">
                    <p class="form-hint">Використовуйте мітки для швидкого пошуку та динамічних добірок.</p>
                </div>
                <div class="form-group full">
                    <label for="contactFiles">Вкладення</label>
                    <div class="file-dropzone" id="contactFileDropzone" role="button" tabindex="0" aria-describedby="contactFileHint">
                        <input type="file" id="contactFiles" class="file-input-hidden" multiple aria-label="Додати файли до контакту">
                        <div class="file-dropzone-content">
                            <i class="fa-solid fa-cloud-arrow-up"></i>
                            <div class="file-dropzone-text">
                                <strong>Прикріпіть документи клієнта</strong>
                                <div class="file-dropzone-actions">або <button type="button" class="file-browse-btn" id="contactFileBrowseBtn">оберіть</button> вручну</div>
                                <p class="upload-hint" id="contactFileHint">Завантажте договори, презентації чи листування.</p>
                            </div>
                        </div>
                    </div>
                    <div class="upload-progress" id="contactUploadProgress" role="status" aria-live="polite">
                        <strong id="contactUploadLabel">Готово</strong>
                        <div class="upload-progress-track">
                            <div class="upload-progress-value" id="contactUploadBar"></div>
                        </div>
                        <span id="contactUploadText">Очікування файлів…</span>
                    </div>
                    <div class="file-list" id="contactFileList"></div>
                </div>
                <div class="form-group full">
                    <label for="contactNotes">Нотатка</label>
                    <textarea id="contactNotes" placeholder="Основні домовленості або наступні кроки"></textarea>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-small-muted" data-close>Скасувати</button>
                    <button type="submit" class="btn btn-primary">Додати контакт</button>
                </div>
            </form>
        </div>
    </div>

    <div class="modal" id="addTaskModal">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3>Нове завдання</h3>
                <button class="modal-close" type="button" data-close>&times;</button>
            </div>
            <form id="taskForm" class="form-grid">
                <div class="form-group">
                    <label for="taskTitle">Назва</label>
                    <input type="text" id="taskTitle" placeholder="Наприклад, Підготувати презентацію" required>
                </div>
                <div class="form-group">
                    <label for="taskOwner">Відповідальний</label>
                    <select id="taskOwner" required></select>
                </div>
                <div class="form-group">
                    <label for="taskDueDate">Термін</label>
                    <input type="date" id="taskDueDate" required>
                </div>
                <div class="form-group">
                    <label for="taskPriority">Пріоритет</label>
                    <select id="taskPriority">
                        <option value="high">Високий</option>
                        <option value="medium">Середній</option>
                        <option value="low">Низький</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="taskStatus">Статус</label>
                    <select id="taskStatus">
                        <option value="todo">До виконання</option>
                        <option value="inProgress">В роботі</option>
                        <option value="done">Завершено</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="taskLead">Пов'язаний лід</label>
                    <select id="taskLead">
                        <option value="">Без прив'язки</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="taskTags">Мітки</label>
                    <input type="text" id="taskTags" placeholder="Наприклад, Follow-up, Пріоритет">
                </div>
                <div class="form-group full">
                    <label for="taskDescription">Коментар</label>
                    <textarea id="taskDescription" placeholder="Опишіть наступні кроки..."></textarea>
                </div>
                <div class="form-group full">
                    <label for="taskFiles">Додати файли</label>
                    <div class="file-dropzone" id="taskFileDropzone" role="button" tabindex="0" aria-describedby="taskFileHint">
                        <input type="file" id="taskFiles" class="file-input-hidden" multiple aria-label="Додати файли до завдання">
                        <div class="file-dropzone-content">
                            <i class="fa-solid fa-cloud-arrow-up"></i>
                            <div class="file-dropzone-text">
                                <strong>Перетягніть матеріали для завдання</strong>
                                <div class="file-dropzone-actions">або <button type="button" class="file-browse-btn" id="taskFileBrowseBtn">оберіть</button> вручну</div>
                                <p class="upload-hint" id="taskFileHint">Додавайте бриф, шаблони листів чи зображення.</p>
                            </div>
                        </div>
                    </div>
                    <div class="upload-progress" id="taskUploadProgress" role="status" aria-live="polite">
                        <strong id="taskUploadLabel">Готово</strong>
                        <div class="upload-progress-track">
                            <div class="upload-progress-value" id="taskUploadBar"></div>
                        </div>
                        <span id="taskUploadText">Очікування файлів…</span>
                    </div>
                    <div class="file-list" id="taskFileList"></div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-small-muted" data-close>Скасувати</button>
                    <button type="submit" class="btn btn-primary">Додати завдання</button>
                </div>
            </form>
        </div>
    </div>

    <div class="modal" id="leadDetailsModal">
        <div class="modal-dialog wide">
            <div class="modal-header">
                <h3 id="leadDetailsTitle">Деталі угоди</h3>
                <button class="modal-close" type="button" data-close>&times;</button>
            </div>
            <div class="lead-details" id="leadDetailsContent"></div>
        </div>
    </div>

    <div class="modal" id="customChartModal">
        <div class="modal-dialog wide">
            <div class="modal-header">
                <h3 id="customChartModalTitle">Новий графік</h3>
                <button class="modal-close" type="button" data-close>&times;</button>
            </div>
            <form id="customChartForm" class="form-grid">
                <input type="hidden" id="customChartId">
                <div class="form-group">
                    <label for="customChartTitle">Назва графіка</label>
                    <input type="text" id="customChartTitle" placeholder="Наприклад, Динаміка нових угод" required>
                </div>
                <div class="form-group">
                    <label for="customChartMetric">Показник</label>
                    <select id="customChartMetric" required></select>
                    <p class="metric-sub" id="customChartMetricHint"></p>
                </div>
                <div class="form-group">
                    <label for="customChartType">Тип діаграми</label>
                    <select id="customChartType" required></select>
                </div>
                <div class="form-group">
                    <label for="customChartPalette">Кольорова схема</label>
                    <select id="customChartPalette"></select>
                </div>
                <div class="form-group full" id="customChartOptionsSection">
                    <label>Налаштування показника</label>
                    <div id="customChartOptions" class="custom-chart-options-grid"></div>
                </div>
                <div class="form-group full">
                    <label>Додаткові параметри відображення</label>
                    <div class="custom-chart-toggle-list" id="customChartToggleList"></div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-small-muted" data-close>Скасувати</button>
                    <button type="submit" class="btn btn-primary">Зберегти графік</button>
                </div>
            </form>
        </div>
    </div>
    <script>
        const STORAGE_KEY = 'homeCRMData_v2';
        const STAGES = ['Новий', 'Кваліфікація', 'Пропозиція', 'Переговори', 'Угода', 'Втрачено'];
        const PROJECT_STAGES = ['Ініціація', 'Discovery', 'Планування', 'Розробка', 'Тестування', 'Запуск', 'Підтримка'];
        const TASK_COLUMNS = [
            { id: 'todo', title: 'До виконання' },
            { id: 'inProgress', title: 'В роботі' },
            { id: 'done', title: 'Завершено' }
        ];
        const TASK_PRIORITY_LABELS = {
            high: 'Високий',
            medium: 'Середній',
            low: 'Низький'
        };
        const TASK_STATUS_LABELS = TASK_COLUMNS.reduce((map, column) => {
            map[column.id] = column.title;
            return map;
        }, {});
        const TASK_FILTER_DEFAULTS = {
            search: '',
            owner: 'all',
            priority: 'all',
            due: 'all'
        };
        const TEAM_MEMBERS = ['Марина', 'Олександр', 'Вікторія', 'Дмитро'];
        const CURRENT_USER = {
            name: 'Марина',
            role: 'manager'
        };
        const ROLE_DEFINITIONS = [
            {
                id: 'owner',
                name: 'Owner',
                badge: 'Owner',
                description: 'Повний контроль над CRM, може оновлювати налаштування та передавати права.',
                permissions: [
                    'Керування ролями та правами доступу',
                    'Редагування бюджетів і фінансових звітів',
                    'Перегляд усіх проектів та файлів'
                ],
                limitations: ['Тільки один користувач у компанії']
            },
            {
                id: 'manager',
                name: 'Sales Manager',
                badge: 'Manager',
                description: 'Веде комунікацію з клієнтами, контролює воронку продажів і задачі.',
                permissions: [
                    'Створення та редагування лідів і проектів',
                    'Планування та виконання задач команди',
                    'Завантаження файлів у своїх проектах'
                ],
                limitations: ['Не може змінювати роль Owner', 'Без доступу до системних налаштувань']
            },
            {
                id: 'storekeeper',
                name: 'Storekeeper',
                badge: 'Storekeeper',
                description: 'Опікується технічною документацією та ресурсами, контролює файлові бібліотеки.',
                permissions: [
                    'Доступ до файлового архіву',
                    'Оновлення статусів постачань',
                    'Коментування задач'
                ],
                limitations: ['Не бачить фінансові показники']
            },
            {
                id: 'support',
                name: 'Support',
                badge: 'Support',
                description: 'Працює зі зверненнями клієнтів і допомагає менеджерам.',
                permissions: [
                    'Перегляд контактів і нотаток',
                    'Створення задач на звернення клієнтів'
                ],
                limitations: ['Без права змінювати бюджети та етапи угод']
            }
        ];
        const CONTACT_SEGMENT_OPTIONS = [
            { id: 'lead', label: 'Лід' },
            { id: 'potential', label: 'Потенційний клієнт' },
            { id: 'customer', label: 'Чинний клієнт' },
            { id: 'vip', label: 'VIP-клієнт' },
            { id: 'partner', label: 'Партнер' }
        ];

        const CONTACT_SEGMENT_SET = new Set(CONTACT_SEGMENT_OPTIONS.map(option => option.id));

        const STATUS_LABELS = CONTACT_SEGMENT_OPTIONS.reduce((map, option) => {
            map[option.id] = option.label;
            return map;
        }, {
            active: 'Активний клієнт',
            cold: 'Холодний контакт',
            inactive: 'Неактивний контакт'
        });

        const CONTACT_LIFECYCLE_LABELS = {
            prospect: 'Потенційний клієнт',
            customer: 'Чинний клієнт',
            expansion: 'Розвиток співпраці',
            advocate: 'Лояльний клієнт',
            churned: 'Втрачений клієнт'
        };

        const CONTACT_CHANNEL_LABELS = {
            email: 'Email',
            phone: 'Телефон',
            video: 'Відеозв\'язок',
            chat: 'Чат/месенджер',
            portal: 'Портал підтримки',
            system: 'CRM'
        };
        const CONTACT_CHANNEL_ALIASES = {
            телефон: 'phone',
            дзвінок: 'phone',
            phone: 'phone',
            voice: 'phone',
            call: 'phone',
            email: 'email',
            лист: 'email',
            пошта: 'email',
            'електронна пошта': 'email',
            портал: 'portal',
            'портал підтримки': 'portal',
            portal: 'portal',
            чат: 'chat',
            messenger: 'chat',
            месенджер: 'chat',
            video: 'video',
            відео: 'video',
            zoom: 'video',
            crm: 'system',
            system: 'system',
            внутрішній: 'system'
        };

        const CONTACT_INTERACTION_TYPE_LABELS = {
            call: 'Дзвінок',
            email: 'Лист',
            meeting: 'Зустріч',
            note: 'Нотатка',
            chat: 'Чат',
            task: 'Завдання',
            ticket: 'Запит',
            update: 'Оновлення',
            success: 'Успіх'
        };

        const CONTACT_INTERACTION_ICONS = {
            call: 'fa-solid fa-phone',
            email: 'fa-solid fa-envelope',
            meeting: 'fa-solid fa-handshake-simple',
            note: 'fa-solid fa-note-sticky',
            chat: 'fa-solid fa-comments',
            task: 'fa-solid fa-circle-check',
            ticket: 'fa-solid fa-life-ring',
            update: 'fa-solid fa-arrow-trend-up',
            success: 'fa-solid fa-star'
        };

        const CALL_CENTER_ENDPOINTS = {
            summary: '/kpi/summary',
            history: '/kpi/history',
            quality: '/quality/recent',
            kpiStream: '/ws/kpi',
            qualityStream: '/ws/quality'
        };

        const CALL_CENTER_SENTIMENT_LABELS = {
            positive: 'Позитивно',
            negative: 'Негативно',
            neutral: 'Нейтрально'
        };

        const callCenterState = {
            initialized: false,
            metricsContainer: null,
            queuesContainer: null,
            qualityContainer: null,
            statusBadge: null,
            statusLabel: null,
            chartCanvas: null,
            chartInstance: null,
            chartSummary: null,
            refreshButton: null,
            kpiSocket: null,
            qualitySocket: null,
            reconnectHandle: null
        };

        const callCenterHistoryCache = [];
        let callCenterLastSummary = null;
        let callCenterLastQuality = [];

        const SUPPORT_STATUS_LABELS = {
            open: 'В роботі',
            inProgress: 'В процесі',
            resolved: 'Закрито',
            backlog: 'Backlog'
        };

        const SUPPORT_PRIORITY_LABELS = {
            high: 'Високий',
            medium: 'Середній',
            low: 'Низький'
        };

        const LEAD_SEGMENT_LABELS = {
            enterprise: 'Enterprise (≥50 тис. ₴)',
            mid: 'Mid-market (20–50 тис. ₴)',
            smb: 'SMB (<20 тис. ₴)'
        };

        const LEAD_SOURCE_OPTIONS = [
            { id: 'web', label: 'Вебформа', description: 'Автоматичне захоплення з сайту (netsuite.com)' },
            { id: 'email', label: 'Email-кампанія', description: 'Відповідь на розсилку або лист' },
            { id: 'event', label: 'Подія/виставка', description: 'Нетворкінг або демо' },
            { id: 'referral', label: 'Рекомендація клієнта', description: 'Передано партнером чи клієнтом' },
            { id: 'inbound', label: 'Вхідний дзвінок', description: 'Телефонний запит у відділ продажів' },
            { id: 'partner', label: 'Партнерський канал', description: 'Реселери чи інтегратори' }
        ];

        const LEAD_SOURCE_LABELS = LEAD_SOURCE_OPTIONS.reduce((map, option) => {
            map[option.id] = option.label;
            return map;
        }, {});

        const LEAD_QUALIFICATION_OPTIONS = [
            { id: 'new', label: 'Новий запит', description: 'Потрібна первинна кваліфікація' },
            { id: 'mql', label: 'Marketing Qualified (MQL)', description: 'Лід відповідає ICP та зацікавлений' },
            { id: 'sql', label: 'Sales Qualified (SQL)', description: 'Підтверджена потреба, готуємо пропозицію' },
            { id: 'hot', label: 'Hot lead', description: 'Активні переговори й очікуване закриття' }
        ];

        const LEAD_QUALIFICATION_LABELS = LEAD_QUALIFICATION_OPTIONS.reduce((map, option) => {
            map[option.id] = option.label;
            return map;
        }, {});

        const LEAD_ROUTING_RULES = {
            web: 'Марина',
            email: 'Вікторія',
            event: 'Олександр',
            referral: 'Дмитро',
            inbound: 'Марина',
            partner: 'Олександр',
            default: 'Марина'
        };

        const LEAD_STAGE_SCORE_RULES = [
            { stage: 'Кваліфікація', minScore: 40 },
            { stage: 'Пропозиція', minScore: 55 },
            { stage: 'Переговори', minScore: 75 }
        ];

        const LEAD_AUTOMATION_CLOSE_RULE = { stage: 'Угода', probability: 90 };
        const LEAD_REMINDER_DAYS = [7, 3, 1];
        const LEAD_SCORE_DEFAULT = 50;
        const STAGE_INDEX = STAGES.reduce((map, stage, index) => {
            map[stage] = index;
            return map;
        }, {});

        const REPORT_PERIOD_OPTIONS = [
            { id: '30d', label: 'Останні 30 днів', days: 30 },
            { id: '90d', label: 'Квартал (90 днів)', days: 90 },
            { id: '365d', label: 'Рік', days: 365 },
            { id: 'all', label: 'Весь час', days: null }
        ];

        const roleDashboardState = {
            active: 'sales',
            initialized: false
        };

        const reportBuilderState = {
            dataset: 'leads',
            period: '90d',
            grouping: 'stage',
            filter: 'all',
            initialized: false,
            lastReport: null
        };

        const REPORT_DATASET_DEFAULT = 'leads';
        const REPORT_PERIOD_DEFAULT = '90d';

        const REPORT_CONFIGS = {
            leads: {
                id: 'leads',
                label: 'Продажі',
                entity: 'Угоди',
                defaultGrouping: 'stage',
                defaultFilter: 'all',
                timeField: 'createdAt',
                groupings: {
                    stage: 'Етап воронки',
                    owner: 'Менеджер',
                    segment: 'Сегмент клієнта',
                    month: 'Місяць створення'
                },
                filters: {
                    all: 'Всі ліди',
                    hot: 'Гарячі (ймовірність ≥60%)',
                    cold: 'Холодні (ймовірність <30%)',
                    lost: 'Втрачено'
                },
                getRecords: () => Array.isArray(crmData?.leads) ? crmData.leads.slice() : [],
                applyFilter: (records, filter) => filterLeads(records, filter),
                buildReport: (records, grouping) => buildLeadsReport(records, grouping)
            },
            projects: {
                id: 'projects',
                label: 'Маркетинг та delivery',
                entity: 'Проекти',
                defaultGrouping: 'stage',
                defaultFilter: 'all',
                timeField: 'updatedAt',
                groupings: {
                    stage: 'Етап проекту',
                    owner: 'Відповідальний',
                    tag: 'Напрям/мітка',
                    month: 'Місяць оновлення'
                },
                filters: {
                    all: 'Всі проекти',
                    marketing: 'Маркетингові кампанії',
                    delivery: 'Впровадження та підтримка',
                    highProbability: 'Ймовірність ≥70%'
                },
                getRecords: () => Array.isArray(crmData?.projects) ? crmData.projects.slice() : [],
                applyFilter: (records, filter) => filterProjects(records, filter),
                buildReport: (records, grouping) => buildProjectsReport(records, grouping)
            },
            support: {
                id: 'support',
                label: 'Підтримка',
                entity: 'Тікети',
                defaultGrouping: 'status',
                defaultFilter: 'all',
                timeField: 'createdAt',
                groupings: {
                    status: 'Статус',
                    channel: 'Канал звернення',
                    priority: 'Пріоритет',
                    owner: 'Виконавець'
                },
                filters: {
                    all: 'Всі звернення',
                    open: 'Активні звернення',
                    backlog: 'Backlog',
                    resolved: 'Закриті',
                    high: 'Високий пріоритет'
                },
                getRecords: () => Array.isArray(crmData?.supportTickets) ? crmData.supportTickets.slice() : [],
                applyFilter: (records, filter) => filterSupportTickets(records, filter),
                buildReport: (records, grouping) => buildSupportReport(records, grouping)
            }
        };

        const MAX_ATTACHMENT_SIZE = 1.5 * 1024 * 1024; // 1.5 МБ
        const MAX_TOTAL_ATTACHMENTS_SIZE = 4 * 1024 * 1024; // 4 МБ
        const FILE_LIBRARY_LIMIT = 6;
        const attachmentAreas = {};
        const MODAL_ATTACHMENT_AREAS = {
            addLeadModal: ['lead'],
            addProjectModal: ['project'],
            addContactModal: ['contact'],
            addTaskModal: ['task']
        };
        const navigationState = { search: '', filter: 'all' };
        let applyNavigationFilters = () => {};

        const PREFERENCES_KEY = 'homeCRMPreferences_v1';
        const DASHBOARD_BLOCK_IDS = [
            'dashboard-stage',
            'dashboard-upcoming',
            'dashboard-activity',
            'dashboard-forecast',
            'dashboard-sales-performance',
            'dashboard-team-productivity',
            'dashboard-process',
            'dashboard-feature-usage',
            'dashboard-feature-overview'
        ];
        const METRIC_BLOCK_IDS = [
            'metric-active-deals',
            'metric-pipeline-value',
            'metric-win-rate',
            'metric-today-tasks'
        ];
        const DASHBOARD_BLOCK_LABELS = {
            'dashboard-stage': 'Розподіл воронки',
            'dashboard-upcoming': 'Майбутні активності',
            'dashboard-activity': 'Останні оновлення',
            'dashboard-forecast': 'Прогноз доходу',
            'dashboard-sales-performance': 'Динаміка продажів',
            'dashboard-team-productivity': 'Продуктивність команди',
            'dashboard-process': 'Контроль процесів',
            'dashboard-feature-usage': 'Залученість функціоналу',
            'dashboard-feature-overview': 'Огляд можливостей'
        };
        const METRIC_BLOCK_LABELS = {
            'metric-active-deals': 'Активні угоди',
            'metric-pipeline-value': 'Вартість воронки',
            'metric-win-rate': 'Win rate',
            'metric-today-tasks': 'Завдання на сьогодні'
        };
        const METRIC_RENDERERS = {
            'metric-active-deals': stats => `
                <div class="metric-icon">
                    <i class="fa-solid fa-fire"></i>
                </div>
                <div>
                    <div class="metric-label">Активні угоди</div>
                    <div class="metric-value">${stats.activeLeadsCount}</div>
                    <div class="metric-sub">${stats.hotDealsCount} гарячих можливостей</div>
                </div>
            `,
            'metric-pipeline-value': stats => `
                <div class="metric-icon">
                    <i class="fa-solid fa-coins"></i>
                </div>
                <div>
                    <div class="metric-label">Вартість воронки</div>
                    <div class="metric-value">${formatCurrency(stats.pipelineValue)}</div>
                    <div class="metric-sub">${formatCurrency(stats.expectedRevenue)} прогнозовано</div>
                </div>
            `,
            'metric-win-rate': stats => `
                <div>
                    <div class="metric-label">Win rate</div>
                    <div class="metric-value">${stats.winRate}%</div>
                    <div class="metric-sub">${stats.wonDealsCount} виграно / ${stats.lostDealsCount} втрачено</div>
                </div>
                <div class="metric-progress" style="--angle: ${Math.max(0, Math.min(100, stats.winRate)) * 3.6}deg">${stats.winRate}%</div>
            `,
            'metric-today-tasks': stats => `
                <div class="metric-icon">
                    <i class="fa-solid fa-calendar-day"></i>
                </div>
                <div>
                    <div class="metric-label">Завдання на сьогодні</div>
                    <div class="metric-value">${stats.tasksDueToday}</div>
                    <div class="metric-sub">${stats.activeTasksCount} активних задач</div>
                </div>
            `
        };
        const DEFAULT_PREFERENCES = {
            layout: {
                dashboardOrder: [...DASHBOARD_BLOCK_IDS],
                metricsOrder: [...METRIC_BLOCK_IDS],
                dashboardColumns: 'auto-fit',
                metricsColumns: 'auto-fit',
                dashboardCardMin: 320,
                metricCardMin: 220,
                compactMode: false,
                hiddenDashboardBlocks: [],
                hiddenMetricBlocks: []
            },
            customCharts: []
        };
        const CHART_TYPE_LABELS = {
            bar: 'Стовпчаста діаграма',
            line: 'Лінійний графік',
            doughnut: 'Кільцева діаграма',
            polarArea: 'Полярна діаграма',
            radar: 'Радарна діаграма'
        };
        const CUSTOM_CHART_PALETTES = {
            aurora: {
                label: 'Aurora',
                description: 'Фіолетово-бірюзова гама для ключових KPI.',
                colors: ['#6366F1', '#22D3EE', '#34D399', '#FBBF24', '#F472B6', '#A855F7', '#0EA5E9']
            },
            sunrise: {
                label: 'Sunrise',
                description: 'Теплі відтінки для маркетингових показників.',
                colors: ['#F97316', '#F59E0B', '#FACC15', '#EAB308', '#FB7185', '#EF4444', '#FCD34D']
            },
            ocean: {
                label: 'Ocean',
                description: 'Холодна палітра для показників ефективності.',
                colors: ['#0EA5E9', '#0284C7', '#38BDF8', '#14B8A6', '#0F766E', '#2563EB', '#22D3EE']
            },
            forest: {
                label: 'Forest',
                description: 'Насичені зелені кольори для контрольних метрик.',
                colors: ['#22C55E', '#16A34A', '#4ADE80', '#65A30D', '#84CC16', '#15803D', '#166534']
            },
            graphite: {
                label: 'Graphite',
                description: 'Урбаністична монохромна палітра.',
                colors: ['#1F2937', '#374151', '#4B5563', '#6B7280', '#9CA3AF', '#D1D5DB', '#111827']
            }
        };
        const CUSTOM_CHART_TOGGLES = [
            { id: 'showLegend', label: 'Показувати легенду', default: true },
            { id: 'showGrid', label: 'Сітка осей', default: true, types: ['bar', 'line', 'radar'] },
            { id: 'showTooltip', label: 'Підказки при наведенні', default: true },
            { id: 'smoothLines', label: 'Плавні лінії', default: true, types: ['line'] },
            { id: 'fillArea', label: 'Заповнювати під кривою', default: false, types: ['line'] }
        ];
        const CUSTOM_CHART_DATASETS = [
            {
                id: 'pipelineStage',
                label: 'Розподіл угод за етапами',
                description: 'Порівняйте обсяг угод у кожному етапі воронки продажів.',
                allowedTypes: ['bar', 'doughnut', 'polarArea'],
                defaultType: 'bar',
                options: [
                    {
                        id: 'valueMode',
                        type: 'select',
                        label: 'Метрика',
                        default: 'value',
                        choices: [
                            { value: 'value', label: 'Сума угод, ₴' },
                            { value: 'count', label: 'Кількість угод' }
                        ]
                    },
                    {
                        id: 'includeLost',
                        type: 'checkbox',
                        label: 'Показувати етап «Втрачено»',
                        default: false
                    },
                    {
                        id: 'sort',
                        type: 'select',
                        label: 'Сортування',
                        default: 'pipeline',
                        choices: [
                            { value: 'pipeline', label: 'Як у воронці' },
                            { value: 'desc', label: 'За спаданням значення' }
                        ]
                    }
                ],
                compute: computePipelineStageDataset
            },
            {
                id: 'revenueTrend',
                label: 'Динаміка продажів',
                description: 'Дивіться, як змінюються продажі та планові показники за місяцями.',
                allowedTypes: ['line', 'bar'],
                defaultType: 'line',
                options: [
                    {
                        id: 'range',
                        type: 'select',
                        label: 'Період',
                        default: '6',
                        choices: [
                            { value: '3', label: '3 місяці' },
                            { value: '6', label: '6 місяців' },
                            { value: '12', label: '12 місяців' }
                        ]
                    },
                    {
                        id: 'metric',
                        type: 'select',
                        label: 'Показник',
                        default: 'wonValue',
                        choices: [
                            { value: 'wonValue', label: 'Виграно, ₴' },
                            { value: 'wonCount', label: 'Виграно, шт.' },
                            { value: 'newLeads', label: 'Нові ліди' },
                            { value: 'pipelineValue', label: 'Очікуваний прогноз, ₴' }
                        ]
                    },
                    {
                        id: 'comparison',
                        type: 'checkbox',
                        label: 'Показувати план-факт',
                        default: true,
                        description: 'Додає другий ряд для порівняння прогнозу та факту.'
                    }
                ],
                compute: computeRevenueTrendDataset
            },
            {
                id: 'ownerPerformance',
                label: 'Результати менеджерів',
                description: 'Аналізуйте індивідуальні досягнення команди продажів.',
                allowedTypes: ['bar', 'line', 'radar'],
                defaultType: 'bar',
                options: [
                    {
                        id: 'metric',
                        type: 'select',
                        label: 'Метрика',
                        default: 'pipelineValue',
                        choices: [
                            { value: 'pipelineValue', label: 'Активна воронка, ₴' },
                            { value: 'wonValue', label: 'Виграно, ₴' },
                            { value: 'dealCount', label: 'Кількість угод' },
                            { value: 'winRate', label: 'Win rate, %' }
                        ]
                    },
                    {
                        id: 'limit',
                        type: 'select',
                        label: 'Кількість менеджерів',
                        default: 'all',
                        choices: [
                            { value: 'all', label: 'Вся команда' },
                            { value: '3', label: 'Топ-3' },
                            { value: '5', label: 'Топ-5' }
                        ]
                    },
                    {
                        id: 'showLost',
                        type: 'checkbox',
                        label: 'Враховувати втрачені угоди у підрахунку',
                        default: false
                    }
                ],
                compute: computeOwnerPerformanceDataset
            },
            {
                id: 'taskStatus',
                label: 'Задачі за категоріями',
                description: 'Баланс активних, завершених та пріоритетних задач.',
                allowedTypes: ['bar', 'doughnut', 'polarArea'],
                defaultType: 'doughnut',
                options: [
                    {
                        id: 'groupBy',
                        type: 'select',
                        label: 'Групування',
                        default: 'status',
                        choices: [
                            { value: 'status', label: 'За статусом' },
                            { value: 'priority', label: 'За пріоритетом' }
                        ]
                    },
                    {
                        id: 'includeDone',
                        type: 'checkbox',
                        label: 'Показувати завершені задачі',
                        default: true
                    },
                    {
                        id: 'onlyOverdue',
                        type: 'checkbox',
                        label: 'Лише прострочені задачі',
                        default: false
                    },
                    {
                        id: 'orientation',
                        type: 'select',
                        label: 'Орієнтація для стовпчиків',
                        default: 'vertical',
                        choices: [
                            { value: 'vertical', label: 'Вертикальна' },
                            { value: 'horizontal', label: 'Горизонтальна' }
                        ]
                    }
                ],
                compute: computeTaskStatusDataset
            },
            {
                id: 'taskOwnerWorkload',
                label: 'Навантаження команди задачами',
                description: 'Порівняйте кількість задач у кожного менеджера.',
                allowedTypes: ['bar', 'line'],
                defaultType: 'bar',
                options: [
                    {
                        id: 'status',
                        type: 'select',
                        label: 'Статус задач',
                        default: 'active',
                        choices: [
                            { value: 'active', label: 'Активні' },
                            { value: 'all', label: 'Усі' },
                            { value: 'done', label: 'Завершені' }
                        ]
                    },
                    {
                        id: 'limit',
                        type: 'select',
                        label: 'Показати',
                        default: 'all',
                        choices: [
                            { value: 'all', label: 'Вся команда' },
                            { value: '5', label: 'Топ-5' }
                        ]
                    },
                    {
                        id: 'orientation',
                        type: 'select',
                        label: 'Орієнтація',
                        default: 'vertical',
                        choices: [
                            { value: 'vertical', label: 'Вертикальна' },
                            { value: 'horizontal', label: 'Горизонтальна' }
                        ]
                    }
                ],
                compute: computeTaskOwnerWorkloadDataset
            },
            {
                id: 'contactStatus',
                label: 'Контактна база за статусом',
                description: 'Структура клієнтів, партнерів та потенційних контактів.',
                allowedTypes: ['doughnut', 'bar', 'polarArea'],
                defaultType: 'doughnut',
                options: [
                    {
                        id: 'owner',
                        type: 'select',
                        label: 'Менеджер',
                        default: 'all',
                        choices: ({ crmData }) => {
                            const contacts = Array.isArray(crmData?.contacts) ? crmData.contacts : [];
                            const owners = Array.from(new Set(contacts.map(contact => contact.owner).filter(Boolean)))
                                .sort((a, b) => a.localeCompare(b, 'uk', { sensitivity: 'base' }));
                            return [
                                { value: 'all', label: 'Вся команда' },
                                ...owners.map(owner => ({ value: owner, label: owner }))
                            ];
                        }
                    }
                ],
                compute: computeContactStatusDataset
            }
        ];
        const DASHBOARD_CARD_WIDTH_RANGE = { min: 260, max: 420 };
        const METRIC_CARD_WIDTH_RANGE = { min: 180, max: 320 };
        let uiPreferences = null;

        let crmData = null;
        let activeLeadId = null;
        let pipelineFilterOwner = 'all';
        let contactStatusFilter = 'all';
        let contactTagFilter = [];
        let activeContactId = null;
        let projectStageFilter = 'all';
        let projectMinProbability = 0;
        let projectSearchTerm = '';
        let leadOwnerManuallySelected = false;
        let searchTimer = null;
        let activeFileSnapshotId = null;
        let activeFileSourceId = null;
        let pendingFileSourceId = null;
        const contactComposerState = new Map();
        let fileSearchTerm = '';
        let isScanningFolder = false;
        let taskFilters = { ...TASK_FILTER_DEFAULTS };
        let salesPerformanceChart = null;
        let teamProductivityChart = null;
        const customChartInstances = new Map();
        let customChartForm = null;
        let customChartIdInput = null;
        let customChartTitleInput = null;
        let customChartMetricSelect = null;
        let customChartTypeSelect = null;
        let customChartPaletteSelect = null;
        let customChartOptionsContainer = null;
        let customChartOptionsSection = null;
        let customChartToggleList = null;
        let customChartMetricHint = null;
        let customChartModalTitle = null;

        const persistentStorage = (() => {
            try {
                if (typeof window === 'undefined' || !('localStorage' in window)) {
                    return null;
                }
                const storage = window.localStorage;
                const testKey = '__homecrm_test__';
                storage.setItem(testKey, '1');
                storage.removeItem(testKey);
                return storage;
            } catch (error) {
                console.warn('Локальне сховище недоступне. Дані CRM зберігатимуться лише поточної сесії.', error);
                return null;
            }
        })();
        let canPersistData = !!persistentStorage;

        function cloneDefaultPreferences() {
            return JSON.parse(JSON.stringify(DEFAULT_PREFERENCES));
        }

        function normalizeOrder(order, defaults) {
            const result = Array.isArray(order) ? order.filter(id => defaults.includes(id)) : [];
            defaults.forEach(id => {
                if (!result.includes(id)) {
                    result.push(id);
                }
            });
            return result;
        }

        function normalizeHidden(list, defaults) {
            const set = new Set();
            (Array.isArray(list) ? list : []).forEach(id => {
                if (defaults.includes(id)) {
                    set.add(id);
                }
            });
            return Array.from(set);
        }

        function normalizeColumns(value) {
            if (typeof value === 'number' && Number.isFinite(value)) {
                value = String(Math.round(value));
            }
            if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) {
                    return 'auto-fit';
                }
                if (trimmed === 'auto' || trimmed === 'auto-fit' || trimmed === 'auto-fill') {
                    return 'auto-fit';
                }
                const numeric = Number(trimmed);
                if (Number.isInteger(numeric) && numeric >= 1 && numeric <= 6) {
                    return String(numeric);
                }
            }
            return 'auto-fit';
        }

        function normalizeCardWidth(value, range, fallback) {
            const numeric = Number(value);
            if (Number.isFinite(numeric)) {
                const min = range?.min ?? fallback;
                const max = range?.max ?? fallback;
                return Math.min(max, Math.max(min, Math.round(numeric)));
            }
            return fallback;
        }

        function loadPreferences() {
            let preferences = cloneDefaultPreferences();
            let stored = null;

            if (persistentStorage && canPersistData) {
                try {
                    stored = persistentStorage.getItem(PREFERENCES_KEY);
                } catch (error) {
                    canPersistData = false;
                    console.warn('Не вдалося прочитати налаштування інтерфейсу.', error);
                }
            }

            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (parsed && typeof parsed === 'object') {
                        const layout = parsed.layout || {};
                        preferences.layout.dashboardOrder = normalizeOrder(layout.dashboardOrder, DASHBOARD_BLOCK_IDS);
                        preferences.layout.metricsOrder = normalizeOrder(layout.metricsOrder, METRIC_BLOCK_IDS);
                        preferences.layout.dashboardColumns = normalizeColumns(layout.dashboardColumns);
                        preferences.layout.metricsColumns = normalizeColumns(layout.metricsColumns);
                        preferences.layout.dashboardCardMin = normalizeCardWidth(
                            layout.dashboardCardMin,
                            DASHBOARD_CARD_WIDTH_RANGE,
                            DEFAULT_PREFERENCES.layout.dashboardCardMin
                        );
                        preferences.layout.metricCardMin = normalizeCardWidth(
                            layout.metricCardMin,
                            METRIC_CARD_WIDTH_RANGE,
                            DEFAULT_PREFERENCES.layout.metricCardMin
                        );
                        preferences.layout.compactMode = Boolean(layout.compactMode);
                        preferences.layout.hiddenDashboardBlocks = normalizeHidden(layout.hiddenDashboardBlocks, DASHBOARD_BLOCK_IDS);
                        preferences.layout.hiddenMetricBlocks = normalizeHidden(layout.hiddenMetricBlocks, METRIC_BLOCK_IDS);
                    }
                } catch (error) {
                    console.warn('Не вдалося розпарсити налаштування інтерфейсу, використовую стандартні значення.', error);
                }
            }

            return preferences;
        }

        function savePreferences() {
            if (!persistentStorage || !canPersistData) {
                return;
            }

            try {
                persistentStorage.setItem(PREFERENCES_KEY, JSON.stringify(uiPreferences));
            } catch (error) {
                canPersistData = false;
                console.warn('Не вдалося зберегти налаштування інтерфейсу.', error);
            }
        }

        function getLayoutOrder(areaId) {
            const defaults = areaId === 'dashboard' ? DASHBOARD_BLOCK_IDS : METRIC_BLOCK_IDS;
            const key = areaId === 'dashboard' ? 'dashboardOrder' : 'metricsOrder';
            const order = uiPreferences?.layout?.[key];
            return Array.isArray(order) ? normalizeOrder(order, defaults) : [...defaults];
        }

        function setLayoutOrder(areaId, order) {
            if (!uiPreferences || !uiPreferences.layout) {
                return;
            }
            const defaults = areaId === 'dashboard' ? DASHBOARD_BLOCK_IDS : METRIC_BLOCK_IDS;
            const key = areaId === 'dashboard' ? 'dashboardOrder' : 'metricsOrder';
            uiPreferences.layout[key] = normalizeOrder(order, defaults);
            savePreferences();
            updateLayoutOrderPreview();
        }

        function getHiddenBlocks(areaId) {
            if (!uiPreferences || !uiPreferences.layout) {
                return [];
            }
            const key = areaId === 'dashboard' ? 'hiddenDashboardBlocks' : 'hiddenMetricBlocks';
            return Array.isArray(uiPreferences.layout[key]) ? [...uiPreferences.layout[key]] : [];
        }

        function setBlockVisibility(areaId, blockId, isVisible) {
            if (!uiPreferences || !uiPreferences.layout) {
                return;
            }
            const defaults = areaId === 'dashboard' ? DASHBOARD_BLOCK_IDS : METRIC_BLOCK_IDS;
            if (!defaults.includes(blockId)) {
                return;
            }
            const key = areaId === 'dashboard' ? 'hiddenDashboardBlocks' : 'hiddenMetricBlocks';
            const hidden = new Set(getHiddenBlocks(areaId));
            if (isVisible) {
                hidden.delete(blockId);
            } else {
                hidden.add(blockId);
            }
            uiPreferences.layout[key] = Array.from(hidden);
            savePreferences();
            updateLayoutOrderPreview();
        }

        function getLayoutColumns(areaId) {
            const key = areaId === 'dashboard' ? 'dashboardColumns' : 'metricsColumns';
            return uiPreferences?.layout?.[key] || 'auto-fit';
        }

        function setLayoutColumns(areaId, value) {
            if (!uiPreferences || !uiPreferences.layout) {
                return;
            }
            const key = areaId === 'dashboard' ? 'dashboardColumns' : 'metricsColumns';
            const normalized = normalizeColumns(value);
            if (uiPreferences.layout[key] !== normalized) {
                uiPreferences.layout[key] = normalized;
                savePreferences();
                updateLayoutVariables();
                syncColumnControls();
            }
        }

        function getColumnInputValue(areaId) {
            const columns = getLayoutColumns(areaId);
            return columns === 'auto-fit' ? 'auto' : columns;
        }

        function setCompactMode(enabled) {
            if (!uiPreferences || !uiPreferences.layout) {
                return;
            }
            const normalized = Boolean(enabled);
            if (uiPreferences.layout.compactMode !== normalized) {
                uiPreferences.layout.compactMode = normalized;
                savePreferences();
                updateLayoutVariables();
                syncCompactToggle();
            }
        }

        function getCardMinWidth(areaId) {
            const key = areaId === 'dashboard' ? 'dashboardCardMin' : 'metricCardMin';
            const fallback = areaId === 'dashboard'
                ? DEFAULT_PREFERENCES.layout.dashboardCardMin
                : DEFAULT_PREFERENCES.layout.metricCardMin;
            const value = uiPreferences?.layout?.[key];
            return Number.isFinite(value) ? value : fallback;
        }

        function setCardMinWidth(areaId, value) {
            if (!uiPreferences || !uiPreferences.layout) {
                return;
            }
            const key = areaId === 'dashboard' ? 'dashboardCardMin' : 'metricCardMin';
            const fallback = areaId === 'dashboard'
                ? DEFAULT_PREFERENCES.layout.dashboardCardMin
                : DEFAULT_PREFERENCES.layout.metricCardMin;
            const range = areaId === 'dashboard' ? DASHBOARD_CARD_WIDTH_RANGE : METRIC_CARD_WIDTH_RANGE;
            const normalized = normalizeCardWidth(value, range, fallback);
            if (uiPreferences.layout[key] !== normalized) {
                uiPreferences.layout[key] = normalized;
                savePreferences();
                updateLayoutVariables();
                syncCardWidthControls();
            }
        }

        function updateLayoutVariables() {
            const root = document.documentElement;
            if (!root || !uiPreferences || !uiPreferences.layout) {
                return;
            }
            root.style.setProperty('--dashboard-columns', getLayoutColumns('dashboard'));
            root.style.setProperty('--metrics-columns', getLayoutColumns('metrics'));
            root.style.setProperty('--dashboard-card-min', `${getCardMinWidth('dashboard')}px`);
            root.style.setProperty('--metric-card-min', `${getCardMinWidth('metrics')}px`);
            if (document.body) {
                document.body.classList.toggle('layout-compact', Boolean(uiPreferences.layout.compactMode));
            }
        }

        function resetLayoutPreferences() {
            uiPreferences = cloneDefaultPreferences();
            savePreferences();
            updateLayoutVariables();
            renderDashboard();
            layoutManager.refreshArea('dashboard');
            layoutManager.refreshArea('metrics');
            renderVisibilityControls();
            syncColumnControls();
            syncCardWidthControls();
            syncCompactToggle();
            updateLayoutOrderPreview();
        }

        const defaultData = {
            leads: [
                {
                    id: 'lead-1',
                    name: 'Редизайн порталу NovaPay',
                    company: 'NovaPay',
                    stage: 'Кваліфікація',
                    value: 58000,
                    probability: 45,
                    source: 'web',
                    qualification: 'mql',
                    score: 58,
                    owner: 'Марина',
                    status: 'active',
                    expectedClose: '2024-07-10',
                    contact: {
                        id: 'contact-1',
                        person: 'Андрій Коваленко',
                        email: 'a.kovalenko@novapay.ua',
                        phone: '+380 67 123 45 67'
                    },
                    tags: ['High value', 'Веб'],
                    createdAt: '2024-05-18T09:24:00.000Z',
                    updatedAt: '2024-06-02T12:15:00.000Z',
                    notes: [
                        {
                            id: 'note-1',
                            text: 'Очікують детальний план робіт до кінця тижня.',
                            author: 'Марина',
                            date: '2024-06-02T12:15:00.000Z'
                        }
                    ],
                    timeline: [
                        { id: 'tl-1', text: 'Лід створено Марина', date: '2024-05-18T09:24:00.000Z' },
                        { id: 'tl-2', text: 'Стадія змінена на «Кваліфікація»', date: '2024-05-20T14:00:00.000Z' }
                    ],
                    attachments: [
                        {
                            id: 'file-brief-novapay',
                            name: 'Бриф NovaPay.txt',
                            path: 'NovaPay/Бриф NovaPay.txt',
                            size: 54,
                            type: 'text/plain',
                            lastModified: 1714640400000,
                            dataUrl: 'data:text/plain;base64,0JrQvtGA0L7RgtC60LjQuSDQsdGA0LjRhCDQv9C+INCy0LjQvNC+0LPQsNC8IE5vdmFQYXku'
                        }
                    ],
                    automation: {
                        remindersSent: [],
                        calendarSynced: false,
                        lastAutoStage: null
                    }
                },
                {
                    id: 'lead-2',
                    name: 'Автоматизація логістики Rozetka',
                    company: 'Rozetka',
                    stage: 'Пропозиція',
                    value: 72000,
                    probability: 55,
                    source: 'email',
                    qualification: 'sql',
                    score: 64,
                    owner: 'Олександр',
                    status: 'active',
                    expectedClose: '2024-07-25',
                    contact: {
                        id: 'contact-2',
                        person: 'Ірина Мельник',
                        email: 'i.melnyk@rozetka.ua',
                        phone: '+380 50 777 23 11'
                    },
                    tags: ['Автоматизація', 'Пріоритет'],
                    createdAt: '2024-05-10T08:42:00.000Z',
                    updatedAt: '2024-06-04T09:30:00.000Z',
                    notes: [
                        {
                            id: 'note-2',
                            text: 'Потрібно погодити комерційну пропозицію до 12 червня.',
                            author: 'Олександр',
                            date: '2024-06-01T11:00:00.000Z'
                        }
                    ],
                    timeline: [
                        { id: 'tl-3', text: 'Запит на автоматизацію логістики', date: '2024-05-10T08:42:00.000Z' },
                        { id: 'tl-4', text: 'Відправлено попередній кошторис', date: '2024-05-26T15:20:00.000Z' }
                    ],
                    attachments: [],
                    automation: {
                        remindersSent: [],
                        calendarSynced: false,
                        lastAutoStage: null
                    }
                },
                {
                    id: 'lead-3',
                    name: 'CRM для GreenBank',
                    company: 'GreenBank',
                    stage: 'Переговори',
                    value: 91000,
                    probability: 70,
                    source: 'event',
                    qualification: 'hot',
                    score: 82,
                    owner: 'Вікторія',
                    status: 'active',
                    expectedClose: '2024-08-05',
                    contact: {
                        id: 'contact-3',
                        person: 'Олег Данилюк',
                        email: 'o.danyliuk@greenbank.ua',
                        phone: '+380 63 555 14 78'
                    },
                    tags: ['Фінанси', 'Інтеграція'],
                    createdAt: '2024-04-28T10:00:00.000Z',
                    updatedAt: '2024-06-03T15:45:00.000Z',
                    notes: [
                        {
                            id: 'note-3',
                            text: 'Запросили інтеграцію з внутрішньою системою KYC.',
                            author: 'Вікторія',
                            date: '2024-06-03T15:45:00.000Z'
                        }
                    ],
                    timeline: [
                        { id: 'tl-5', text: 'Проведено демонстрацію продукту', date: '2024-05-14T13:30:00.000Z' },
                        { id: 'tl-6', text: 'Вікторія оновила стадію на «Переговори»', date: '2024-06-03T15:45:00.000Z' }
                    ],
                    attachments: [],
                    automation: {
                        remindersSent: [],
                        calendarSynced: false,
                        lastAutoStage: null
                    }
                },
                {
                    id: 'lead-4',
                    name: 'Digital-маркетинг для OKKO',
                    company: 'OKKO',
                    stage: 'Новий',
                    value: 26000,
                    probability: 25,
                    source: 'referral',
                    qualification: 'new',
                    score: 32,
                    owner: 'Дмитро',
                    status: 'active',
                    expectedClose: '2024-07-30',
                    contact: {
                        id: 'contact-4',
                        person: 'Світлана Романюк',
                        email: 's.romaniuk@okko.ua',
                        phone: '+380 44 123 90 12'
                    },
                    tags: ['Маркетинг'],
                    createdAt: '2024-06-05T09:15:00.000Z',
                    updatedAt: '2024-06-05T09:15:00.000Z',
                    notes: [],
                    timeline: [
                        { id: 'tl-7', text: 'Новий лід додано Дмитро', date: '2024-06-05T09:15:00.000Z' }
                    ],
                    attachments: [],
                    automation: {
                        remindersSent: [],
                        calendarSynced: false,
                        lastAutoStage: null
                    }
                },
                {
                    id: 'lead-5',
                    name: 'Мобільний додаток для Uklon',
                    company: 'Uklon',
                    stage: 'Угода',
                    value: 45000,
                    probability: 100,
                    source: 'partner',
                    qualification: 'hot',
                    score: 94,
                    owner: 'Марина',
                    status: 'won',
                    expectedClose: '2024-05-30',
                    closedAt: '2024-05-30T16:10:00.000Z',
                    contact: {
                        id: 'contact-5',
                        person: 'Роман Лещенко',
                        email: 'r.leshchenko@uklon.com',
                        phone: '+380 50 120 34 56'
                    },
                    tags: ['Мобільний', 'Гаряча'],
                    createdAt: '2024-04-02T08:25:00.000Z',
                    updatedAt: '2024-05-30T16:10:00.000Z',
                    notes: [
                        {
                            id: 'note-5',
                            text: 'Угода виграна, запускаємо реалізацію у липні.',
                            author: 'Марина',
                            date: '2024-05-30T16:10:00.000Z'
                        }
                    ],
                    timeline: [
                        { id: 'tl-8', text: 'Презентація рішень проведена', date: '2024-04-20T11:40:00.000Z' },
                        { id: 'tl-9', text: 'Угода виграна!', date: '2024-05-30T16:10:00.000Z' }
                    ],
                    attachments: [],
                    automation: {
                        remindersSent: [],
                        calendarSynced: true,
                        lastAutoStage: 'Угода'
                    }
                },
                {
                    id: 'lead-6',
                    name: 'Інтеграція ERP для Intertop',
                    company: 'Intertop',
                    stage: 'Втрачено',
                    value: 38000,
                    probability: 0,
                    source: 'inbound',
                    qualification: 'mql',
                    score: 18,
                    owner: 'Олександр',
                    status: 'lost',
                    expectedClose: '2024-05-15',
                    contact: {
                        id: 'contact-6',
                        person: 'Катерина Сніжко',
                        email: 'k.snizhko@intertop.ua',
                        phone: '+380 44 890 45 67'
                    },
                    tags: ['ERP', 'Конкурент'],
                    createdAt: '2024-03-18T09:00:00.000Z',
                    updatedAt: '2024-05-16T10:45:00.000Z',
                    notes: [
                        {
                            id: 'note-6',
                            text: 'Клієнт обрав рішення конкурента через ціну.',
                            author: 'Олександр',
                            date: '2024-05-16T10:45:00.000Z'
                        }
                    ],
                    timeline: [
                        { id: 'tl-10', text: 'Запит на інтеграцію ERP', date: '2024-03-18T09:00:00.000Z' },
                        { id: 'tl-11', text: 'Угоду втрачено', date: '2024-05-16T10:45:00.000Z' }
                    ],
                    attachments: [],
                    automation: {
                        remindersSent: ['2024-05-15|overdue'],
                        calendarSynced: true,
                        lastAutoStage: 'Втрачено'
                    }
                }
            ],
            projects: [
                {
                    id: 'project-1',
                    name: 'CRM NovaPay 2.0',
                    company: 'NovaPay',
                    stage: 'Розробка',
                    budget: 92000,
                    probability: 62,
                    owner: 'Марина',
                    team: ['Марина', 'Вікторія'],
                    contact: 'Андрій Коваленко',
                    tags: ['CRM', 'Фінтех'],
                    description: 'Розширення можливостей для партнерів і омніканальних продажів.',
                    notes: [
                        { id: 'pnote-1', text: 'Запуск discovery-воркшопу 10 червня.', author: 'Марина', date: '2024-06-02T10:00:00.000Z' },
                        { id: 'pnote-2', text: 'Погодити бюджет з фінансовим директором до 15 червня.', author: 'Вікторія', date: '2024-06-03T09:30:00.000Z' }
                    ],
                    attachments: [
                        {
                            id: 'pfile-brief-novapay',
                            name: 'NovaPay-roadmap.txt',
                            path: 'NovaPay/Роудмап/NovaPay-roadmap.txt',
                            size: 312,
                            type: 'text/plain',
                            lastModified: Date.parse('2024-05-20T10:00:00.000Z'),
                            dataUrl: 'data:text/plain;base64,UGxhbm5pbmcgZG9rdW1lbnQgZm9yIE5vdmFQYXk='
                        }
                    ],
                    createdAt: '2024-04-25T09:10:00.000Z',
                    updatedAt: '2024-06-04T13:20:00.000Z'
                },
                {
                    id: 'project-2',
                    name: 'Автоматизація логістики Rozetka',
                    company: 'Rozetka',
                    stage: 'Тестування',
                    budget: 78000,
                    probability: 68,
                    owner: 'Олександр',
                    team: ['Олександр', 'Дмитро'],
                    contact: 'Ірина Мельник',
                    tags: ['Supply chain', 'Інтеграція'],
                    description: 'Впровадження планувальника маршрутів та мобільного додатку кур’єра.',
                    notes: [
                        { id: 'pnote-3', text: 'Зібрати відгуки пілотної групи кур’єрів.', author: 'Олександр', date: '2024-06-01T11:40:00.000Z' }
                    ],
                    attachments: [
                        {
                            id: 'pfile-rozetka-scope',
                            name: 'Rozetka-scope.txt',
                            path: 'Rozetka/Scope/iteration-2.txt',
                            size: 198,
                            type: 'text/plain',
                            lastModified: Date.parse('2024-05-28T14:45:00.000Z'),
                            dataUrl: 'data:text/plain;base64,U2NvcGUgZm9yIExvZ2lzdGljcyBQaGFzZSAy'
                        }
                    ],
                    createdAt: '2024-04-12T08:35:00.000Z',
                    updatedAt: '2024-06-01T11:40:00.000Z'
                },
                {
                    id: 'project-3',
                    name: 'Digital-кампанія для OKKO',
                    company: 'OKKO',
                    stage: 'Discovery',
                    budget: 54000,
                    probability: 45,
                    owner: 'Дмитро',
                    team: ['Дмитро', 'Марина'],
                    contact: 'Світлана Романюк',
                    tags: ['Маркетинг', 'Discovery'],
                    description: 'Аналітика клієнтських сегментів і підготовка контент-стратегії.',
                    notes: [
                        { id: 'pnote-4', text: 'Затвердити перші три контент-спринти.', author: 'Дмитро', date: '2024-06-05T09:15:00.000Z' }
                    ],
                    attachments: [
                        {
                            id: 'pfile-okko-brief',
                            name: 'OKKO-creative-brief.txt',
                            path: 'OKKO/Briefs/creative-brief.txt',
                            size: 274,
                            type: 'text/plain',
                            lastModified: Date.parse('2024-05-31T16:05:00.000Z'),
                            dataUrl: 'data:text/plain;base64,Q3JlYXRpdmUgYnJpZWYgZm9yIE9LS08gZGlnaXRhbCBjYW1wYWlnbg=='
                        }
                    ],
                    createdAt: '2024-05-02T10:20:00.000Z',
                    updatedAt: '2024-06-05T09:15:00.000Z'
                }
            ],
            contacts: [
                {
                    id: 'contact-1',
                    name: 'Андрій Коваленко',
                    company: 'NovaPay',
                    role: 'COO',
                    email: 'a.kovalenko@novapay.ua',
                    phone: '+380 67 123 45 67',
                    status: 'vip',
                    segments: ['vip', 'customer'],
                    lifecycleStage: 'customer',
                    owner: 'Марина',
                    preferredChannel: 'email',
                    timezone: 'Europe/Kyiv',
                    website: 'https://novapay.ua',
                    linkedin: 'https://www.linkedin.com/in/andrii-kovalenko',
                    address: {
                        street: 'вул. Січових Стрільців, 21',
                        city: 'Київ',
                        country: 'Україна',
                        postalCode: '04053'
                    },
                    demographics: {
                        industry: 'Фінтех',
                        employees: 520,
                        annualRevenue: 120000000
                    },
                    tags: ['VIP', 'Digital'],
                    lastActivity: '2024-06-02T12:15:00.000Z',
                    notes: [
                        { id: 'cnote-1', text: 'Очікує фінальне узгодження roadmap.', author: 'Марина', date: '2024-06-02T12:15:00.000Z' }
                    ],
                    attachments: [
                        {
                            id: 'cfile-novapay-agreement',
                            name: 'NovaPay-agreement.txt',
                            path: 'Contacts/NovaPay/agreement.txt',
                            size: 256,
                            type: 'text/plain',
                            lastModified: Date.parse('2024-05-30T07:20:00.000Z'),
                            dataUrl: 'data:text/plain;base64,Q29udHJhY3Qgc3VtbWFyeSBmb3IgTm92YVBheQ=='
                        }
                    ],
                    interactions: [
                        {
                            id: 'cact-1',
                            type: 'meeting',
                            channel: 'video',
                            subject: 'Стратегічний воркшоп із командою клієнта',
                            summary: 'Обговорили дорожню карту та інтеграцію з контакт-центром Zoom для підтримки.',
                            timestamp: '2024-06-02T12:15:00.000Z',
                            author: 'Марина',
                            tags: ['Discovery']
                        },
                        {
                            id: 'cact-2',
                            type: 'email',
                            channel: 'email',
                            subject: 'Надіслано оновлений roadmap',
                            summary: 'Передано узгоджену версію документу з KPI та етапами.',
                            timestamp: '2024-05-28T09:30:00.000Z',
                            author: 'Марина',
                            tags: ['Документи']
                        },
                        {
                            id: 'cact-3',
                            type: 'call',
                            channel: 'phone',
                            subject: 'Початковий дзвінок та визначення цілей',
                            summary: 'Уточнили критичні KPI та очікування від запуску.',
                            timestamp: '2024-05-18T09:24:00.000Z',
                            author: 'Марина',
                            tags: ['Kick-off']
                        }
                    ],
                    automation: {
                        autoUpdate: {
                            emailInboxes: [
                                {
                                    label: 'sales@novapay.ua',
                                    provider: 'Gmail',
                                    status: 'connected',
                                    lastSync: '2024-06-05T07:45:00.000Z',
                                    newRecords: 2
                                }
                            ],
                            webForms: [
                                {
                                    label: 'Запис на консультацію',
                                    status: 'active',
                                    lastSync: '2024-06-05T07:30:00.000Z',
                                    newRecords: 1
                                }
                            ]
                        },
                        enrichment: {
                            providers: [
                                {
                                    name: 'Clearbit',
                                    status: 'active',
                                    lastRefresh: '2024-06-04T18:00:00.000Z',
                                    fields: ['галузь', 'розмір компанії']
                                },
                                {
                                    name: 'LinkedIn Sales Navigator',
                                    status: 'active',
                                    lastRefresh: '2024-06-04T18:00:00.000Z',
                                    fields: ['соціальні профілі ключових осіб']
                                }
                            ],
                            enrichedFields: ['галузь', 'розмір компанії', 'соціальні профілі']
                        },
                        communicationLog: {
                            calls: {
                                provider: 'Zoom Contact Center',
                                lastSync: '2024-06-02T12:15:00.000Z',
                                recordings: true,
                                loggedCount: 3,
                                tags: ['Впровадження', 'Фолоу-ап'],
                                followUp: 'Контроль впровадження 7 червня'
                            },
                            emails: {
                                provider: 'Outlook',
                                mailbox: 'sales@novapay.ua',
                                autoLink: true,
                                threadsTracked: 5,
                                lastSync: '2024-06-02T12:15:00.000Z'
                            }
                        }
                    }
                },
                {
                    id: 'contact-2',
                    name: 'Ірина Мельник',
                    company: 'Rozetka',
                    role: 'Head of Logistics',
                    email: 'i.melnyk@rozetka.ua',
                    phone: '+380 50 777 23 11',
                    status: 'lead',
                    segments: ['lead', 'potential'],
                    lifecycleStage: 'prospect',
                    owner: 'Олександр',
                    preferredChannel: 'email',
                    timezone: 'Europe/Kyiv',
                    website: 'https://rozetka.ua',
                    linkedin: 'https://www.linkedin.com/in/irynamelnyk',
                    address: {
                        street: 'просп. Степана Бандери, 6',
                        city: 'Київ',
                        country: 'Україна',
                        postalCode: '04073'
                    },
                    demographics: {
                        industry: 'E-commerce',
                        employees: 9000,
                        annualRevenue: 1500000000
                    },
                    tags: ['Priority', 'Retail'],
                    lastActivity: '2024-06-01T11:00:00.000Z',
                    notes: [
                        { id: 'cnote-2', text: 'Надіслати оновлений KPI-лист до 14 червня.', author: 'Олександр', date: '2024-06-01T11:00:00.000Z' }
                    ],
                    attachments: [],
                    interactions: [
                        {
                            id: 'cact-4',
                            type: 'meeting',
                            channel: 'video',
                            subject: 'Демонстрація модуля оптимізації логістики',
                            summary: 'Показали сценарії маршрутизації та синхронізацію складів.',
                            timestamp: '2024-06-01T11:00:00.000Z',
                            author: 'Олександр',
                            tags: ['Demo']
                        },
                        {
                            id: 'cact-5',
                            type: 'email',
                            channel: 'email',
                            subject: 'Надіслано оновлений KPI-лист',
                            summary: 'Уточнені показники SLA та плани з росту продуктивності.',
                            timestamp: '2024-05-26T15:20:00.000Z',
                            author: 'Олександр',
                            tags: ['Документи']
                        },
                        {
                            id: 'cact-6',
                            type: 'call',
                            channel: 'phone',
                            subject: 'Початковий дзвінок відділу логістики',
                            summary: 'Зібрані основні вимоги по інтеграції з WMS.',
                            timestamp: '2024-05-10T08:42:00.000Z',
                            author: 'Олександр',
                            tags: ['Kick-off']
                        }
                    ],
                    automation: {
                        autoUpdate: {
                            emailInboxes: [
                                {
                                    label: 'logistics@rozetka.ua',
                                    provider: 'Office 365',
                                    status: 'connected',
                                    lastSync: '2024-06-05T06:40:00.000Z',
                                    newRecords: 1
                                }
                            ],
                            webForms: [
                                {
                                    label: 'RFP на логістику',
                                    status: 'active',
                                    lastSync: '2024-06-05T06:30:00.000Z',
                                    newRecords: 3
                                }
                            ]
                        },
                        enrichment: {
                            providers: [
                                {
                                    name: 'Apollo.io',
                                    status: 'active',
                                    lastRefresh: '2024-06-04T17:20:00.000Z',
                                    fields: ['контакти команди', 'технологічний стек']
                                },
                                {
                                    name: 'Clearbit',
                                    status: 'active',
                                    lastRefresh: '2024-06-04T17:20:00.000Z',
                                    fields: ['галузь', 'розмір компанії']
                                }
                            ],
                            enrichedFields: ['галузь', 'розмір компанії', 'контакти команди', 'технологічний стек']
                        },
                        communicationLog: {
                            calls: {
                                provider: 'Zoom Contact Center',
                                lastSync: '2024-06-01T11:00:00.000Z',
                                recordings: true,
                                loggedCount: 2,
                                tags: ['Demo'],
                                followUp: 'Підготувати SLA-матеріали'
                            },
                            emails: {
                                provider: 'Gmail',
                                mailbox: 'sales@ourcrm.ua',
                                autoLink: true,
                                threadsTracked: 4,
                                lastSync: '2024-05-26T15:20:00.000Z'
                            }
                        }
                    }
                },
                {
                    id: 'contact-3',
                    name: 'Олег Данилюк',
                    company: 'GreenBank',
                    role: 'Digital Transformation Lead',
                    email: 'o.danyliuk@greenbank.ua',
                    phone: '+380 63 555 14 78',
                    status: 'customer',
                    segments: ['customer', 'partner'],
                    lifecycleStage: 'customer',
                    owner: 'Вікторія',
                    preferredChannel: 'video',
                    timezone: 'Europe/Kyiv',
                    website: 'https://greenbank.ua',
                    linkedin: 'https://www.linkedin.com/in/oleh-danyliuk',
                    address: {
                        street: 'вул. Хрещатик, 7',
                        city: 'Київ',
                        country: 'Україна',
                        postalCode: '01001'
                    },
                    demographics: {
                        industry: 'Банківська справа',
                        employees: 2800,
                        annualRevenue: 860000000
                    },
                    tags: ['Фінанси'],
                    lastActivity: '2024-06-03T15:45:00.000Z',
                    notes: [
                        { id: 'cnote-3', text: 'Чекає демо KYC-модуля у середу.', author: 'Вікторія', date: '2024-06-03T15:45:00.000Z' }
                    ],
                    attachments: [
                        {
                            id: 'cfile-greenbank-nda',
                            name: 'GreenBank-NDA.txt',
                            path: 'Contacts/GreenBank/NDA.txt',
                            size: 188,
                            type: 'text/plain',
                            lastModified: Date.parse('2024-05-18T09:40:00.000Z'),
                            dataUrl: 'data:text/plain;base64,TkRBIGZvciBHcmVlbkJhbms='
                        }
                    ],
                    interactions: [
                        {
                            id: 'cact-7',
                            type: 'meeting',
                            channel: 'video',
                            subject: 'Демо інтеграції з KYC-системою',
                            summary: 'Погодили наступні кроки та вимоги до безпеки.',
                            timestamp: '2024-06-03T15:45:00.000Z',
                            author: 'Вікторія',
                            tags: ['Demo']
                        },
                        {
                            id: 'cact-8',
                            type: 'email',
                            channel: 'email',
                            subject: 'Надсилання технічного аудиту',
                            summary: 'Відправили деталізований опис інтеграційних точок.',
                            timestamp: '2024-05-24T10:10:00.000Z',
                            author: 'Вікторія',
                            tags: ['Документи']
                        },
                        {
                            id: 'cact-9',
                            type: 'call',
                            channel: 'phone',
                            subject: 'Початковий дзвінок по проєкту',
                            summary: 'Узгодили бізнес-цілі та ключових учасників команди.',
                            timestamp: '2024-04-28T10:00:00.000Z',
                            author: 'Вікторія',
                            tags: ['Kick-off']
                        }
                    ],
                    automation: {
                        autoUpdate: {
                            emailInboxes: [
                                {
                                    label: 'digital@greenbank.ua',
                                    provider: 'Microsoft 365',
                                    status: 'connected',
                                    lastSync: '2024-06-03T15:50:00.000Z',
                                    newRecords: 1
                                }
                            ],
                            webForms: [
                                {
                                    label: 'Запит на KYC',
                                    status: 'active',
                                    lastSync: '2024-06-03T15:30:00.000Z',
                                    newRecords: 2
                                }
                            ]
                        },
                        enrichment: {
                            providers: [
                                {
                                    name: 'Crunchbase',
                                    status: 'active',
                                    lastRefresh: '2024-06-03T08:10:00.000Z',
                                    fields: ['інвестиції', 'дата заснування']
                                },
                                {
                                    name: 'LinkedIn',
                                    status: 'active',
                                    lastRefresh: '2024-06-03T08:10:00.000Z',
                                    fields: ['соціальні профілі команди']
                                }
                            ],
                            enrichedFields: ['галузь', 'розмір компанії', 'інвестиції', 'соціальні профілі']
                        },
                        communicationLog: {
                            calls: {
                                provider: 'Zoom Contact Center',
                                lastSync: '2024-06-03T15:45:00.000Z',
                                recordings: true,
                                loggedCount: 3,
                                tags: ['Безпека', 'Фолоу-ап'],
                                followUp: 'Відправити чекліст безпеки'
                            },
                            emails: {
                                provider: 'Outlook',
                                mailbox: 'project@greenbank.ua',
                                autoLink: true,
                                threadsTracked: 6,
                                lastSync: '2024-05-24T10:10:00.000Z'
                            }
                        }
                    }
                },
                {
                    id: 'contact-4',
                    name: 'Світлана Романюк',
                    company: 'OKKO',
                    role: 'Marketing Director',
                    email: 's.romaniuk@okko.ua',
                    phone: '+380 44 123 90 12',
                    status: 'potential',
                    segments: ['potential'],
                    lifecycleStage: 'prospect',
                    owner: 'Дмитро',
                    preferredChannel: 'email',
                    timezone: 'Europe/Kyiv',
                    website: 'https://www.okko.ua',
                    linkedin: 'https://www.linkedin.com/in/svitlana-romaniuk',
                    address: {
                        street: 'вул. Галицька, 201',
                        city: 'Львів',
                        country: 'Україна',
                        postalCode: '79000'
                    },
                    demographics: {
                        industry: 'Retail & Fuel',
                        employees: 4500,
                        annualRevenue: 920000000
                    },
                    tags: ['Marketing'],
                    lastActivity: '2024-06-05T09:15:00.000Z',
                    notes: [],
                    attachments: [],
                    interactions: [
                        {
                            id: 'cact-10',
                            type: 'email',
                            channel: 'email',
                            subject: 'Запит на контент-стратегію для програми лояльності',
                            summary: 'Отримали вихідні дані для підготовки пропозиції.',
                            timestamp: '2024-06-05T09:15:00.000Z',
                            author: 'Дмитро',
                            tags: ['Brief']
                        },
                        {
                            id: 'cact-11',
                            type: 'call',
                            channel: 'phone',
                            subject: 'Обговорення аудиторії та KPI',
                            summary: 'Уточнили ключові сегменти та бюджет на перший місяць.',
                            timestamp: '2024-05-29T16:40:00.000Z',
                            author: 'Дмитро',
                            tags: ['Discovery']
                        }
                    ],
                    automation: {
                        autoUpdate: {
                            emailInboxes: [
                                {
                                    label: 'marketing@okko.ua',
                                    provider: 'Gmail',
                                    status: 'connected',
                                    lastSync: '2024-06-05T09:15:00.000Z',
                                    newRecords: 2
                                }
                            ],
                            webForms: [
                                {
                                    label: 'Партнерська програма',
                                    status: 'active',
                                    lastSync: '2024-06-05T09:00:00.000Z',
                                    newRecords: 2
                                }
                            ]
                        },
                        enrichment: {
                            providers: [
                                {
                                    name: 'Clearbit',
                                    status: 'active',
                                    lastRefresh: '2024-06-04T12:00:00.000Z',
                                    fields: ['галузь', 'соціальні профілі']
                                },
                                {
                                    name: 'SimilarWeb',
                                    status: 'active',
                                    lastRefresh: '2024-06-04T12:00:00.000Z',
                                    fields: ['цифрові канали', 'трафік']
                                }
                            ],
                            enrichedFields: ['галузь', 'соціальні профілі', 'цифрові канали', 'трафік']
                        },
                        communicationLog: {
                            calls: {
                                provider: 'Zoom Contact Center',
                                lastSync: '2024-05-29T16:40:00.000Z',
                                recordings: true,
                                loggedCount: 2,
                                tags: ['Discovery'],
                                followUp: 'Підготувати контент-стратегію'
                            },
                            emails: {
                                provider: 'Gmail',
                                mailbox: 'marketing@okko.ua',
                                autoLink: true,
                                threadsTracked: 3,
                                lastSync: '2024-06-05T09:15:00.000Z'
                            }
                        }
                    }
                },
                {
                    id: 'contact-5',
                    name: 'Роман Лещенко',
                    company: 'Uklon',
                    role: 'Product Owner',
                    email: 'r.leshchenko@uklon.com',
                    phone: '+380 50 120 34 56',
                    status: 'partner',
                    segments: ['partner', 'customer'],
                    lifecycleStage: 'expansion',
                    owner: 'Марина',
                    preferredChannel: 'chat',
                    timezone: 'Europe/Kyiv',
                    website: 'https://www.uklon.com.ua',
                    linkedin: 'https://www.linkedin.com/in/roman-leshchenko',
                    address: {
                        street: 'вул. Антоновича, 109',
                        city: 'Київ',
                        country: 'Україна',
                        postalCode: '03150'
                    },
                    demographics: {
                        industry: 'Mobility',
                        employees: 600,
                        annualRevenue: 480000000
                    },
                    tags: ['Strategic'],
                    lastActivity: '2024-05-31T09:00:00.000Z',
                    notes: [
                        { id: 'cnote-4', text: 'Заплановано ретроспективу запуску на 12 червня.', author: 'Марина', date: '2024-05-31T09:00:00.000Z' }
                    ],
                    attachments: [
                        {
                            id: 'cfile-uklon-summary',
                            name: 'Uklon-summary.txt',
                            path: 'Contacts/Uklon/summary.txt',
                            size: 204,
                            type: 'text/plain',
                            lastModified: Date.parse('2024-05-29T12:25:00.000Z'),
                            dataUrl: 'data:text/plain;base64,U3VtbWFyeSBmb3IgVWxrb24gc3VjY2VzcyBtb2R1bGU='
                        }
                    ],
                    interactions: [
                        {
                            id: 'cact-12',
                            type: 'meeting',
                            channel: 'video',
                            subject: 'Ретроспектива запуску мобільного додатку',
                            summary: 'Зафіксували ключові висновки та roadmap наступних покращень.',
                            timestamp: '2024-05-31T09:00:00.000Z',
                            author: 'Марина',
                            tags: ['Retro']
                        },
                        {
                            id: 'cact-13',
                            type: 'chat',
                            channel: 'chat',
                            subject: 'Синхронізація щодо API-покриття',
                            summary: 'Уточнили перелік методів, які потрібно винести в публічний SDK.',
                            timestamp: '2024-05-22T14:45:00.000Z',
                            author: 'Марина',
                            tags: ['Інтеграція']
                        },
                        {
                            id: 'cact-14',
                            type: 'email',
                            channel: 'email',
                            subject: 'Передані фінальні артефакти запуску',
                            summary: 'Поділилися документацією та навчальними матеріалами для команди Uklon.',
                            timestamp: '2024-05-12T08:30:00.000Z',
                            author: 'Марина',
                            tags: ['Документи']
                        }
                    ],
                    automation: {
                        autoUpdate: {
                            emailInboxes: [
                                {
                                    label: 'product@uklon.com',
                                    provider: 'Google Workspace',
                                    status: 'connected',
                                    lastSync: '2024-05-31T09:05:00.000Z',
                                    newRecords: 1
                                }
                            ],
                            webForms: [
                                {
                                    label: 'Партнерський доступ',
                                    status: 'active',
                                    lastSync: '2024-05-30T18:00:00.000Z',
                                    newRecords: 1
                                }
                            ]
                        },
                        enrichment: {
                            providers: [
                                {
                                    name: 'LinkedIn',
                                    status: 'active',
                                    lastRefresh: '2024-05-29T12:30:00.000Z',
                                    fields: ['соціальні профілі команди']
                                },
                                {
                                    name: 'BuiltWith',
                                    status: 'active',
                                    lastRefresh: '2024-05-29T12:30:00.000Z',
                                    fields: ['технологічний стек']
                                }
                            ],
                            enrichedFields: ['галузь', 'соціальні профілі', 'технологічний стек']
                        },
                        communicationLog: {
                            calls: {
                                provider: 'Zoom Contact Center',
                                lastSync: '2024-05-22T14:45:00.000Z',
                                recordings: true,
                                loggedCount: 4,
                                tags: ['Інтеграція', 'Підтримка'],
                                followUp: 'Оновити публічний SDK'
                            },
                            emails: {
                                provider: 'Gmail',
                                mailbox: 'success@ourcrm.ua',
                                autoLink: true,
                                threadsTracked: 4,
                                lastSync: '2024-05-31T09:00:00.000Z'
                            }
                        }
                    }
                }
            ],
            tasks: [
                {
                    id: 'task-1',
                    title: 'Підготувати технічний аудит для NovaPay',
                    status: 'inProgress',
                    priority: 'high',
                    owner: 'Марина',
                    dueDate: '2024-06-08',
                    relatedLeadId: 'lead-1',
                    description: 'Зібрати технічні вимоги та запланувати воркшоп з командою клієнта.',
                    tags: ['Discovery', 'NovaPay'],
                    attachments: [
                        {
                            id: 'tfile-audit-checklist',
                            name: 'audit-checklist.txt',
                            path: 'Tasks/NovaPay/audit-checklist.txt',
                            size: 164,
                            type: 'text/plain',
                            lastModified: Date.parse('2024-06-01T09:00:00.000Z'),
                            dataUrl: 'data:text/plain;base64,QXVkaXQgY2hlY2tsaXN0IGZvciBOb3ZhUGF5IHRlYW0='
                        }
                    ],
                    createdAt: '2024-05-30T09:15:00.000Z'
                },
                {
                    id: 'task-2',
                    title: 'Оновити комерційну пропозицію Rozetka',
                    status: 'todo',
                    priority: 'high',
                    owner: 'Олександр',
                    dueDate: '2024-06-07',
                    relatedLeadId: 'lead-2',
                    description: 'Додати блок про інтеграцію з WMS та підрахувати ROI.',
                    tags: ['Proposal'],
                    attachments: [],
                    createdAt: '2024-05-28T08:20:00.000Z'
                },
                {
                    id: 'task-3',
                    title: 'Запланувати демонстрацію KYC-модуля',
                    status: 'todo',
                    priority: 'medium',
                    owner: 'Вікторія',
                    dueDate: '2024-06-12',
                    relatedLeadId: 'lead-3',
                    description: 'Підготувати сценарій демонстрації та приклади звітів.',
                    tags: ['Demo'],
                    attachments: [
                        {
                            id: 'tfile-kyc-script',
                            name: 'kyc-demo-script.txt',
                            path: 'Tasks/GreenBank/kyc-demo-script.txt',
                            size: 220,
                            type: 'text/plain',
                            lastModified: Date.parse('2024-06-03T15:00:00.000Z'),
                            dataUrl: 'data:text/plain;base64,S1lDIGRlbW8gc2NyaXB0IGZvciBncmVlbmJhbmsgdGVhbQ=='
                        }
                    ],
                    createdAt: '2024-05-31T10:45:00.000Z'
                },
                {
                    id: 'task-4',
                    title: 'Підбір кейсів для OKKO',
                    status: 'inProgress',
                    priority: 'medium',
                    owner: 'Дмитро',
                    dueDate: '2024-06-09',
                    relatedLeadId: 'lead-4',
                    description: 'Підібрати релевантні кейси з рітейлу та оформити презентацію.',
                    tags: ['Контент'],
                    attachments: [],
                    createdAt: '2024-05-29T12:00:00.000Z'
                },
                {
                    id: 'task-5',
                    title: 'Ретроспектива після запуску Uklon',
                    status: 'done',
                    priority: 'low',
                    owner: 'Марина',
                    dueDate: '2024-06-01',
                    relatedLeadId: 'lead-5',
                    description: 'Зафіксувати висновки та рекомендації для наступних запусків.',
                    tags: ['Retro'],
                    attachments: [],
                    completedAt: '2024-06-01',
                    createdAt: '2024-05-20T14:10:00.000Z'
                }
            ],
            supportTickets: [
                {
                    id: 'ticket-1',
                    subject: 'Не оновлюється статус замовлення',
                    client: 'NovaPay',
                    channel: 'Email',
                    status: 'open',
                    priority: 'high',
                    owner: 'Вікторія',
                    createdAt: '2024-06-04T08:10:00.000Z',
                    firstResponseAt: '2024-06-04T08:45:00.000Z',
                    resolvedAt: '',
                    csat: null
                },
                {
                    id: 'ticket-2',
                    subject: 'Питання з інтеграцією API',
                    client: 'Rozetka',
                    channel: 'Портал',
                    status: 'inProgress',
                    priority: 'medium',
                    owner: 'Дмитро',
                    createdAt: '2024-06-03T10:20:00.000Z',
                    firstResponseAt: '2024-06-03T10:50:00.000Z',
                    resolvedAt: '',
                    csat: null
                },
                {
                    id: 'ticket-3',
                    subject: 'Запит на додаткові ролі користувачів',
                    client: 'OKKO',
                    channel: 'Чат',
                    status: 'resolved',
                    priority: 'low',
                    owner: 'Марина',
                    createdAt: '2024-05-30T09:40:00.000Z',
                    firstResponseAt: '2024-05-30T09:55:00.000Z',
                    resolvedAt: '2024-05-30T13:10:00.000Z',
                    csat: 4.8
                },
                {
                    id: 'ticket-4',
                    subject: 'Звіт не експортується у CSV',
                    client: 'Uklon',
                    channel: 'Email',
                    status: 'resolved',
                    priority: 'medium',
                    owner: 'Олександр',
                    createdAt: '2024-05-28T11:05:00.000Z',
                    firstResponseAt: '2024-05-28T11:30:00.000Z',
                    resolvedAt: '2024-05-28T15:20:00.000Z',
                    csat: 4.5
                },
                {
                    id: 'ticket-5',
                    subject: 'Підтримка мобільного додатку',
                    client: 'Intertop',
                    channel: 'Телефон',
                    status: 'backlog',
                    priority: 'high',
                    owner: 'Вікторія',
                    createdAt: '2024-06-01T07:20:00.000Z',
                    firstResponseAt: '',
                    resolvedAt: '',
                    csat: null
                }
            ],
            activities: [
                {
                    id: 'act-3',
                    type: 'task',
                    entityId: 'task-4',
                    message: 'Створено нове завдання для OKKO.',
                    timestamp: '2024-06-05T09:15:00.000Z'
                },
                {
                    id: 'act-6',
                    type: 'role',
                    entityId: 'member-victoria',
                    message: 'Марина призначила Вікторію на роль Project Coordinator.',
                    timestamp: '2024-06-04T16:30:00.000Z'
                },
                {
                    id: 'act-1',
                    type: 'stage',
                    entityId: 'lead-3',
                    message: 'Вікторія оновила стадію GreenBank до «Переговори».',
                    timestamp: '2024-06-03T15:45:00.000Z'
                },
                {
                    id: 'act-2',
                    type: 'note',
                    entityId: 'lead-2',
                    message: 'Олександр додав нотатку до Rozetka: потребують нову комерційну пропозицію.',
                    timestamp: '2024-06-01T11:00:00.000Z'
                },
                {
                    id: 'act-4',
                    type: 'won',
                    entityId: 'lead-5',
                    message: 'Марина закрила угоду з Uklon на 45 000 ₴.',
                    timestamp: '2024-05-30T16:10:00.000Z'
                },
                {
                    id: 'act-5',
                    type: 'lost',
                    entityId: 'lead-6',
                    message: 'Intertop обрав рішення конкурента. Угоду позначено як втрачено.',
                    timestamp: '2024-05-16T10:45:00.000Z'
                }
            ],
            roles: {
                customRoles: [
                    {
                        id: 'role-project-coordinator',
                        name: 'Project Coordinator',
                        badge: 'Coordinator',
                        description: 'Відповідає за запуск проектів і синхронізацію команд.',
                        permissions: [
                            'Координація стартових зустрічей',
                            'Контроль таймлайну проектів',
                            'Перевірка завантажених матеріалів'
                        ],
                        limitations: ['Без права змінювати фінансові показники'],
                        baseRoleId: 'manager',
                        createdAt: '2024-04-22T09:00:00.000Z',
                        createdBy: 'Марина',
                        custom: true
                    },
                    {
                        id: 'role-marketing-curator',
                        name: 'Marketing Curator',
                        badge: 'Curator',
                        description: 'Опікується контентом та партнерськими активаціями.',
                        permissions: [
                            'Планування маркетингових задач',
                            'Керування контент-бібліотекою',
                            'Погодження матеріалів з клієнтами'
                        ],
                        limitations: ['Без доступу до налаштувань ролей'],
                        baseRoleId: 'support',
                        createdAt: '2024-04-28T14:30:00.000Z',
                        createdBy: 'Дмитро',
                        custom: true
                    }
                ],
                assignments: [
                    {
                        id: 'member-oleksandr',
                        name: 'Олександр',
                        email: 'oleksandr@demo-crm.ua',
                        department: 'Операційний відділ',
                        title: 'Комерційний директор',
                        phone: '+380 50 777 23 11',
                        roleId: 'owner',
                        responsibilities: [
                            'Фінансове планування',
                            'Стратегія розвитку продажів',
                            'Затвердження бюджетів'
                        ],
                        note: 'Керує ключовими угодами та правами доступу.',
                        updatedAt: '2024-06-01T08:30:00.000Z',
                        updatedBy: 'Система',
                        locked: true
                    },
                    {
                        id: 'member-marina',
                        name: 'Марина',
                        email: 'marina@demo-crm.ua',
                        department: 'Відділ продажів',
                        title: 'Керівниця продажів',
                        phone: '+380 67 123 45 67',
                        roleId: 'manager',
                        responsibilities: [
                            'Керування воронкою продажів',
                            'Контроль командних задач',
                            'Підготовка демо для клієнтів'
                        ],
                        note: 'Фокусується на стратегічних клієнтах і нових угодах.',
                        updatedAt: '2024-06-03T10:15:00.000Z',
                        updatedBy: 'Олександр',
                        locked: false
                    },
                    {
                        id: 'member-victoria',
                        name: 'Вікторія',
                        email: 'victoria@demo-crm.ua',
                        department: 'Доставка проектів',
                        title: 'Project Coordinator',
                        phone: '+380 63 555 14 78',
                        roleId: 'role-project-coordinator',
                        responsibilities: [
                            'Онбординг нових проектів',
                            'Комунікація з клієнтськими командами',
                            'Актуалізація статусів задач'
                        ],
                        note: 'Призначено на координацію фінансового сектору.',
                        updatedAt: '2024-06-04T16:30:00.000Z',
                        updatedBy: 'Марина',
                        locked: false
                    },
                    {
                        id: 'member-dmytro',
                        name: 'Дмитро',
                        email: 'dmytro@demo-crm.ua',
                        department: 'Маркетинг',
                        title: 'Marketing Curator',
                        phone: '+380 44 123 90 12',
                        roleId: 'role-marketing-curator',
                        responsibilities: [
                            'Підготовка кейсів',
                            'Узгодження креативних матеріалів',
                            'Ведення контент-календаря'
                        ],
                        note: 'Відповідає за контент для партнерських програм.',
                        updatedAt: '2024-06-05T09:15:00.000Z',
                        updatedBy: 'Вікторія',
                        locked: false
                    }
                ]
            },
            fileLibrary: [
                {
                    id: 'snapshot-marketing-folder',
                    rootName: 'D:/O',
                    scannedAt: '2024-06-05T08:45:00.000Z',
                    source: 'demo',
                    tree: {
                        type: 'directory',
                        name: 'D:/O',
                        path: 'D:/O',
                        children: [
                            {
                                type: 'directory',
                                name: 'Campaigns',
                                path: 'D:/O/Campaigns',
                                children: [
                                    {
                                        type: 'directory',
                                        name: 'Digital',
                                        path: 'D:/O/Campaigns/Digital',
                                        children: [
                                            {
                                                type: 'file',
                                                name: 'spring-launch-plan.pdf',
                                                path: 'D:/O/Campaigns/Digital/spring-launch-plan.pdf',
                                                size: 2880512,
                                                lastModified: Date.parse('2024-04-11T08:10:00.000Z'),
                                                mimeType: 'application/pdf'
                                            },
                                            {
                                                type: 'file',
                                                name: 'social-calendar.xlsx',
                                                path: 'D:/O/Campaigns/Digital/social-calendar.xlsx',
                                                size: 512000,
                                                lastModified: Date.parse('2024-04-09T14:25:00.000Z'),
                                                mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                                            }
                                        ]
                                    },
                                    {
                                        type: 'directory',
                                        name: 'Offline',
                                        path: 'D:/O/Campaigns/Offline',
                                        children: [
                                            {
                                                type: 'file',
                                                name: 'billboards.ai',
                                                path: 'D:/O/Campaigns/Offline/billboards.ai',
                                                size: 4200000,
                                                lastModified: Date.parse('2024-03-29T11:40:00.000Z'),
                                                mimeType: 'application/postscript'
                                            }
                                        ]
                                    },
                                    {
                                        type: 'file',
                                        name: 'budget.xlsx',
                                        path: 'D:/O/Campaigns/budget.xlsx',
                                        size: 768000,
                                        lastModified: Date.parse('2024-04-20T09:05:00.000Z'),
                                        mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                                    }
                                ]
                            },
                            {
                                type: 'directory',
                                name: 'Design',
                                path: 'D:/O/Design',
                                children: [
                                    {
                                        type: 'file',
                                        name: 'brandbook.pdf',
                                        path: 'D:/O/Design/brandbook.pdf',
                                        size: 5120000,
                                        lastModified: Date.parse('2024-05-18T13:32:00.000Z'),
                                        mimeType: 'application/pdf'
                                    },
                                    {
                                        type: 'file',
                                        name: 'logo-pack.zip',
                                        path: 'D:/O/Design/logo-pack.zip',
                                        size: 6553600,
                                        lastModified: Date.parse('2024-05-15T10:22:00.000Z'),
                                        mimeType: 'application/zip'
                                    }
                                ]
                            },
                            {
                                type: 'directory',
                                name: 'Case Studies',
                                path: 'D:/O/Case Studies',
                                children: [
                                    {
                                        type: 'file',
                                        name: 'fintech-demo.pptx',
                                        path: 'D:/O/Case Studies/fintech-demo.pptx',
                                        size: 4718592,
                                        lastModified: Date.parse('2024-05-05T17:05:00.000Z'),
                                        mimeType: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
                                    },
                                    {
                                        type: 'file',
                                        name: 'retail-overview.pptx',
                                        path: 'D:/O/Case Studies/retail-overview.pptx',
                                        size: 3932160,
                                        lastModified: Date.parse('2024-05-03T09:55:00.000Z'),
                                        mimeType: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
                                    }
                                ]
                            },
                            {
                                type: 'file',
                                name: 'readme.txt',
                                path: 'D:/O/readme.txt',
                                size: 2048,
                                lastModified: Date.parse('2024-02-01T08:00:00.000Z'),
                                mimeType: 'text/plain'
                            },
                            {
                                type: 'file',
                                name: 'q1-report.csv',
                                path: 'D:/O/q1-report.csv',
                                size: 128000,
                                lastModified: Date.parse('2024-04-05T07:45:00.000Z'),
                                mimeType: 'text/csv'
                            }
                        ]
                    }
                }
            ],
            fileSources: [
                {
                    id: 'source-local-marketing',
                    name: 'Маркетингові матеріали',
                    type: 'local',
                    path: 'D:\\O',
                    status: 'online',
                    connected: true,
                    autoSync: false,
                    totalFiles: 10,
                    totalFolders: 5,
                    totalSize: 28814912,
                    lastSynced: '2024-06-05T08:50:00.000Z',
                    snapshotId: 'snapshot-marketing-folder',
                    favorite: true
                },
                {
                    id: 'source-google-drive',
                    name: 'Google Drive • Brand Assets',
                    type: 'cloud',
                    provider: 'Google Drive',
                    path: 'Marketing/Brand Assets',
                    status: 'online',
                    connected: true,
                    autoSync: true,
                    totalFiles: 86,
                    totalFolders: 12,
                    totalSize: 892000000,
                    lastSynced: '2024-06-04T10:45:00.000Z',
                    snapshotId: null,
                    favorite: false
                },
                {
                    id: 'source-dropbox-sales',
                    name: 'Dropbox • Sales Kits',
                    type: 'cloud',
                    provider: 'Dropbox',
                    path: 'CRM/Sales Kits',
                    status: 'offline',
                    connected: false,
                    autoSync: true,
                    totalFiles: 0,
                    totalFolders: 0,
                    totalSize: 0,
                    lastSynced: null,
                    snapshotId: null,
                    favorite: false
                }
            ]
        };
        const deepClone = (data) => JSON.parse(JSON.stringify(data));

        function generateId(prefix = 'id') {
            return `${prefix}-${Math.random().toString(36).slice(2, 9)}`;
        }

        function normalizeAttachment(file, prefix = 'file') {
            if (!file || typeof file !== 'object') {
                return null;
            }

            const name = typeof file.name === 'string' && file.name.trim().length ? file.name.trim() : 'Файл';
            const path = typeof file.path === 'string' && file.path.trim().length ? file.path.trim() : name;
            const size = Math.max(0, Number(file.size) || 0);
            const type = typeof file.type === 'string' && file.type.trim().length ? file.type : 'application/octet-stream';
            const lastModified = Number(file.lastModified) || Date.now();
            const dataUrl = typeof file.dataUrl === 'string' ? file.dataUrl : '';

            return {
                id: typeof file.id === 'string' && file.id.trim().length ? file.id : generateId(prefix),
                name,
                path,
                size,
                type,
                lastModified,
                dataUrl
            };
        }

        function normalizeNote(note, prefix = 'note', fallbackAuthor = 'CRM') {
            if (!note) {
                return null;
            }

            if (typeof note === 'string') {
                const text = note.trim();
                if (!text.length) {
                    return null;
                }
                return {
                    id: generateId(prefix),
                    text,
                    author: fallbackAuthor,
                    date: new Date().toISOString()
                };
            }

            if (typeof note === 'object') {
                const text = typeof note.text === 'string' ? note.text.trim() : '';
                if (!text.length) {
                    return null;
                }

                return {
                    id: typeof note.id === 'string' && note.id.trim().length ? note.id : generateId(prefix),
                    text,
                    author: typeof note.author === 'string' && note.author.trim().length ? note.author.trim() : fallbackAuthor,
                    date: typeof note.date === 'string' && note.date ? note.date : new Date().toISOString()
                };
            }

            return null;
        }

        function normalizeContactInteraction(interaction, fallbackAuthor = CURRENT_USER.name) {
            if (!interaction || typeof interaction !== 'object') {
                return null;
            }

            const id = typeof interaction.id === 'string' && interaction.id.trim().length
                ? interaction.id.trim()
                : generateId('cact');
            const typeValue = typeof interaction.type === 'string'
                ? interaction.type.trim().toLowerCase()
                : '';
            const type = CONTACT_INTERACTION_TYPE_LABELS[typeValue] ? typeValue : 'note';
            const channelValue = typeof interaction.channel === 'string'
                ? interaction.channel.trim().toLowerCase()
                : type;
            const channel = CONTACT_CHANNEL_LABELS[channelValue] ? channelValue : type;
            const subject = typeof interaction.subject === 'string' && interaction.subject.trim().length
                ? interaction.subject.trim()
                : CONTACT_INTERACTION_TYPE_LABELS[type] || 'Активність';
            const summary = typeof interaction.summary === 'string'
                ? interaction.summary.trim()
                : '';
            const timestamp = typeof interaction.timestamp === 'string' && interaction.timestamp
                ? interaction.timestamp
                : new Date().toISOString();
            const author = typeof interaction.author === 'string' && interaction.author.trim().length
                ? interaction.author.trim()
                : (fallbackAuthor || CURRENT_USER.name);
            const tags = Array.isArray(interaction.tags)
                ? interaction.tags
                    .map(tag => (typeof tag === 'string' ? tag.trim() : String(tag || '').trim()))
                    .filter(Boolean)
                : [];
            const attachments = Array.isArray(interaction.attachments)
                ? interaction.attachments.map(file => normalizeAttachment(file, 'contactactivity')).filter(Boolean)
                : [];

            return { id, type, channel, subject, summary, timestamp, author, tags, attachments };
        }

        function upgradeDataStructure(data) {
            if (!data || typeof data !== 'object') {
                return deepClone(defaultData);
            }

            if (!Array.isArray(data.leads)) {
                data.leads = [];
            } else {
                data.leads = data.leads
                    .filter(lead => lead && typeof lead === 'object')
                    .map(lead => {
                        const normalizedLead = { ...lead };
                        normalizedLead.source = typeof lead.source === 'string' && LEAD_SOURCE_LABELS[lead.source]
                            ? lead.source
                            : 'web';
                        normalizedLead.qualification = typeof lead.qualification === 'string' && LEAD_QUALIFICATION_LABELS[lead.qualification]
                            ? lead.qualification
                            : 'new';
                        normalizedLead.score = Math.max(0, Math.min(100, Number(lead.score) || LEAD_SCORE_DEFAULT));
                        normalizedLead.attachments = Array.isArray(lead.attachments)
                            ? lead.attachments.map(file => normalizeAttachment(file, 'file')).filter(Boolean)
                            : [];
                        normalizedLead.notes = Array.isArray(lead.notes)
                            ? lead.notes.map(note => normalizeNote(note, 'note', lead.owner || 'CRM')).filter(Boolean)
                            : typeof lead.notes === 'string'
                                ? [normalizeNote(lead.notes, 'note', lead.owner || 'CRM')].filter(Boolean)
                                : [];
                        if (!Array.isArray(normalizedLead.timeline)) {
                            normalizedLead.timeline = [];
                        }
                        normalizedLead.createdAt = typeof lead.createdAt === 'string' && lead.createdAt
                            ? lead.createdAt
                            : new Date().toISOString();
                        normalizedLead.updatedAt = typeof lead.updatedAt === 'string' && lead.updatedAt
                            ? lead.updatedAt
                            : normalizedLead.createdAt;
                        normalizedLead.automation = normalizeLeadAutomation(lead.automation);
                        return normalizedLead;
                    });
            }

            data.projects = Array.isArray(data.projects)
                ? data.projects.map(normalizeProject).filter(Boolean)
                : [];

            data.contacts = Array.isArray(data.contacts)
                ? data.contacts.map(normalizeContact).filter(Boolean)
                : [];

            data.tasks = Array.isArray(data.tasks)
                ? data.tasks.map(normalizeTask).filter(Boolean)
                : [];

            data.supportTickets = Array.isArray(data.supportTickets)
                ? data.supportTickets.map(normalizeSupportTicket).filter(Boolean)
                : deepClone(defaultData.supportTickets || []);

            data.fileLibrary = Array.isArray(data.fileLibrary)
                ? data.fileLibrary.map(normalizeFileSnapshot).filter(Boolean)
                : [];

            data.fileSources = Array.isArray(data.fileSources)
                ? data.fileSources.map(normalizeFileSource).filter(Boolean)
                : deepClone(defaultData.fileSources);

            if (!data.roles || typeof data.roles !== 'object') {
                data.roles = deepClone(defaultData.roles);
            }

            data.roles.customRoles = Array.isArray(data.roles.customRoles)
                ? data.roles.customRoles.map(role => normalizeRoleDefinition(role, true)).filter(Boolean)
                : [];

            data.roles.assignments = Array.isArray(data.roles.assignments)
                ? data.roles.assignments.map(normalizeRoleAssignment).filter(Boolean)
                : [];

            const existingNames = new Set(data.roles.assignments.map(item => item.name));
            TEAM_MEMBERS.forEach(memberName => {
                if (!existingNames.has(memberName)) {
                    const fallbackAssignment = normalizeRoleAssignment({
                        id: generateId('member'),
                        name: memberName,
                        roleId: memberName === CURRENT_USER.name ? CURRENT_USER.role : 'manager',
                        responsibilities: ['Доступ до CRM'],
                        updatedAt: new Date().toISOString(),
                        updatedBy: 'Система'
                    });
                    data.roles.assignments.push(fallbackAssignment);
                    existingNames.add(memberName);
                }
            });

            let ownerAssignment = data.roles.assignments.find(item => item.roleId === 'owner');
            if (!ownerAssignment && data.roles.assignments.length) {
                ownerAssignment = data.roles.assignments[0];
                ownerAssignment.roleId = 'owner';
                ownerAssignment.updatedAt = new Date().toISOString();
                ownerAssignment.updatedBy = 'Система';
            }

            const currentAssignment = data.roles.assignments.find(item => item.name === CURRENT_USER.name);
            if (currentAssignment) {
                CURRENT_USER.role = currentAssignment.roleId;
            }

            return data;
        }

        function normalizeLeadAutomation(automation) {
            const result = {
                remindersSent: [],
                calendarSynced: false,
                lastAutoStage: null,
                lastReminderAt: null
            };

            if (!automation || typeof automation !== 'object') {
                return result;
            }

            const normalizeReminderKey = entry => {
                if (!entry) {
                    return '';
                }

                if (typeof entry === 'string' || typeof entry === 'number') {
                    return String(entry).trim();
                }

                if (entry instanceof Date) {
                    return entry.toISOString();
                }

                if (typeof entry !== 'object') {
                    return '';
                }

                if (typeof entry.key === 'string' && entry.key.trim().length) {
                    return entry.key.trim();
                }

                const dateFields = ['date', 'timestamp', 'sentAt'];
                let datePart = '';
                for (const field of dateFields) {
                    const value = entry[field];
                    if (value instanceof Date) {
                        datePart = value.toISOString();
                        break;
                    }
                    if (typeof value === 'number' && Number.isFinite(value)) {
                        const asDate = new Date(value);
                        if (!Number.isNaN(asDate.getTime())) {
                            datePart = asDate.toISOString();
                            break;
                        }
                    }
                    if (typeof value === 'string' && value.trim().length) {
                        datePart = value.trim();
                        break;
                    }
                }

                if (!datePart.length) {
                    return '';
                }

                const candidateOffsets = ['offset', 'day', 'days'];
                let offsetValue = null;
                candidateOffsets.some(prop => {
                    const value = entry[prop];
                    if (typeof value === 'number' && Number.isFinite(value)) {
                        offsetValue = value;
                        return true;
                    }
                    if (typeof value === 'string' && value.trim().length) {
                        const parsed = Number(value);
                        if (!Number.isNaN(parsed)) {
                            offsetValue = parsed;
                            return true;
                        }
                    }
                    return false;
                });

                const offsetLabel = offsetValue === null ? 'custom' : String(offsetValue);
                return `${datePart}|${offsetLabel}`;
            };

            if (Array.isArray(automation.remindersSent)) {
                const uniqueReminders = new Set();
                automation.remindersSent.forEach(entry => {
                    const normalized = normalizeReminderKey(entry);
                    if (normalized) {
                        uniqueReminders.add(normalized);
                    }
                });
                result.remindersSent = Array.from(uniqueReminders);
            }

            if (typeof automation.calendarSynced === 'boolean') {
                result.calendarSynced = automation.calendarSynced;
            } else if (typeof automation.calendarSynced === 'string') {
                const normalized = automation.calendarSynced.trim().toLowerCase();
                result.calendarSynced = ['true', '1', 'yes', 'y', 'synced'].includes(normalized);
            }

            let rawStage = '';
            if (typeof automation.lastAutoStage === 'string') {
                rawStage = automation.lastAutoStage.trim();
            } else if (automation.lastAutoStage && typeof automation.lastAutoStage === 'object' && typeof automation.lastAutoStage.stage === 'string') {
                rawStage = automation.lastAutoStage.stage.trim();
            }
            if (rawStage) {
                result.lastAutoStage = rawStage;
            }

            const reminderValue = automation.lastReminderAt;
            if (reminderValue !== undefined && reminderValue !== null) {
                let parsedReminderDate = null;
                if (reminderValue instanceof Date) {
                    parsedReminderDate = new Date(reminderValue.getTime());
                } else if (typeof reminderValue === 'number' && Number.isFinite(reminderValue)) {
                    parsedReminderDate = new Date(reminderValue);
                } else if (typeof reminderValue === 'string' && reminderValue.trim().length) {
                    parsedReminderDate = new Date(reminderValue.trim());
                }
                if (parsedReminderDate && !Number.isNaN(parsedReminderDate.getTime())) {
                    result.lastReminderAt = parsedReminderDate.toISOString();
                }
            }

            return result;
        }

        function normalizeProject(project) {
            if (!project || typeof project !== 'object') {
                return null;
            }

            const team = Array.isArray(project.team)
                ? project.team.map(member => typeof member === 'string' ? member.trim() : String(member || '').trim()).filter(Boolean)
                : typeof project.team === 'string' && project.team.trim().length
                    ? project.team.split(',').map(member => member.trim()).filter(Boolean)
                    : [];

            const tags = Array.isArray(project.tags)
                ? project.tags.map(tag => typeof tag === 'string' ? tag.trim() : String(tag || '').trim()).filter(Boolean)
                : typeof project.tags === 'string' && project.tags.trim().length
                    ? project.tags.split(',').map(tag => tag.trim()).filter(Boolean)
                    : [];

            const stage = typeof project.stage === 'string' && project.stage.trim()
                ? project.stage.trim()
                : PROJECT_STAGES[0];

            const createdAt = typeof project.createdAt === 'string' && project.createdAt
                ? project.createdAt
                : new Date().toISOString();
            const updatedAt = typeof project.updatedAt === 'string' && project.updatedAt
                ? project.updatedAt
                : createdAt;
            const description = typeof project.description === 'string' && project.description.trim().length
                ? project.description.trim()
                : typeof project.summary === 'string'
                    ? project.summary.trim()
                    : '';
            const attachments = Array.isArray(project.attachments)
                ? project.attachments.map(file => normalizeAttachment(file, 'projectfile')).filter(Boolean)
                : [];
            const notes = Array.isArray(project.notes)
                ? project.notes.map(note => normalizeNote(note, 'pnote', project.owner || 'CRM')).filter(Boolean)
                : typeof project.notes === 'string'
                    ? [normalizeNote(project.notes, 'pnote', project.owner || 'CRM')].filter(Boolean)
                    : [];

            return {
                id: typeof project.id === 'string' && project.id ? project.id : generateId('project'),
                name: typeof project.name === 'string' && project.name.trim() ? project.name.trim() : 'Новий проект',
                company: typeof project.company === 'string' ? project.company.trim() : '',
                stage,
                budget: Number(project.budget) || 0,
                probability: Math.max(0, Math.min(100, Number(project.probability) || 0)),
                owner: typeof project.owner === 'string' ? project.owner.trim() : '',
                contact: typeof project.contact === 'string' ? project.contact.trim() : '',
                team,
                tags,
                description,
                notes,
                attachments,
                createdAt,
                updatedAt
            };
        }

        function normalizeAutomationEndpoint(endpoint, defaultStatus = 'connected') {
            if (!endpoint || typeof endpoint !== 'object') {
                return null;
            }

            const label = typeof endpoint.label === 'string' ? endpoint.label.trim() : '';
            if (!label.length) {
                return null;
            }

            const provider = typeof endpoint.provider === 'string' ? endpoint.provider.trim() : '';
            const statusRaw = typeof endpoint.status === 'string' ? endpoint.status.trim().toLowerCase() : '';
            const status = statusRaw.length ? statusRaw : defaultStatus;
            const lastSync = normalizeToISOString(endpoint.lastSync);
            const recordsValue = Number(endpoint.newRecords);
            const newRecords = Number.isFinite(recordsValue) ? Math.max(0, Math.round(recordsValue)) : 0;

            return {
                label,
                provider,
                status,
                lastSync,
                newRecords
            };
        }

        function normalizeEnrichmentProvider(provider) {
            if (!provider || typeof provider !== 'object') {
                return null;
            }

            const name = typeof provider.name === 'string' ? provider.name.trim() : '';
            if (!name.length) {
                return null;
            }

            const statusRaw = typeof provider.status === 'string' ? provider.status.trim().toLowerCase() : '';
            const status = statusRaw.length ? statusRaw : 'active';
            const lastRefresh = normalizeToISOString(provider.lastRefresh);
            const fieldsSource = Array.isArray(provider.fields)
                ? provider.fields
                : typeof provider.fields === 'string'
                    ? provider.fields.split(',')
                    : [];
            const fields = fieldsSource
                .map(field => (typeof field === 'string' ? field.trim() : String(field || '').trim()))
                .filter(Boolean);

            return {
                name,
                status,
                lastRefresh,
                fields
            };
        }

        function normalizeContactCallLog(log) {
            if (!log || typeof log !== 'object') {
                return null;
            }

            const provider = typeof log.provider === 'string' ? log.provider.trim() : '';
            const lastSync = normalizeToISOString(log.lastSync);
            const recordings = typeof log.recordings === 'boolean'
                ? log.recordings
                : Boolean(log.recorded || log.hasRecordings);
            const countValue = Number(log.loggedCount ?? log.total ?? log.count);
            const loggedCount = Number.isFinite(countValue) ? Math.max(0, Math.round(countValue)) : null;
            const tagsSource = Array.isArray(log.tags)
                ? log.tags
                : typeof log.tags === 'string'
                    ? log.tags.split(',')
                    : [];
            const tags = tagsSource
                .map(tag => (typeof tag === 'string' ? tag.trim() : String(tag || '').trim()))
                .filter(Boolean);
            const followUp = typeof log.followUp === 'string' ? log.followUp.trim() : '';

            return {
                provider,
                lastSync,
                recordings,
                loggedCount,
                tags,
                followUp
            };
        }

        function normalizeContactEmailLog(log) {
            if (!log || typeof log !== 'object') {
                return null;
            }

            const provider = typeof log.provider === 'string' ? log.provider.trim() : '';
            const mailbox = typeof log.mailbox === 'string' ? log.mailbox.trim() : '';
            const lastSync = normalizeToISOString(log.lastSync);
            const autoLink = typeof log.autoLink === 'boolean'
                ? log.autoLink
                : Boolean(log.autoLogging || log.autoAttach);
            const threadsValue = Number(log.threadsTracked ?? log.threads ?? log.conversations);
            const threadsTracked = Number.isFinite(threadsValue) ? Math.max(0, Math.round(threadsValue)) : null;
            const followUp = typeof log.followUp === 'string' ? log.followUp.trim() : '';

            return {
                provider,
                mailbox,
                lastSync,
                autoLink,
                threadsTracked,
                followUp
            };
        }

        function normalizeContactAutomation(automation) {
            const result = {
                autoUpdate: {
                    emailInboxes: [],
                    webForms: []
                },
                enrichment: {
                    providers: [],
                    fields: [],
                    lastRefresh: ''
                },
                communicationLog: {
                    calls: null,
                    emails: null
                }
            };

            if (!automation || typeof automation !== 'object') {
                return result;
            }

            if (automation.autoUpdate && typeof automation.autoUpdate === 'object') {
                const autoUpdate = automation.autoUpdate;
                if (Array.isArray(autoUpdate.emailInboxes)) {
                    result.autoUpdate.emailInboxes = autoUpdate.emailInboxes
                        .map(item => normalizeAutomationEndpoint(item, 'connected'))
                        .filter(Boolean);
                }
                if (Array.isArray(autoUpdate.webForms)) {
                    result.autoUpdate.webForms = autoUpdate.webForms
                        .map(item => normalizeAutomationEndpoint(item, 'active'))
                        .filter(Boolean);
                }
            }

            if (automation.enrichment && typeof automation.enrichment === 'object') {
                const enrichment = automation.enrichment;
                const providers = Array.isArray(enrichment.providers)
                    ? enrichment.providers.map(normalizeEnrichmentProvider).filter(Boolean)
                    : [];
                const fieldsSource = Array.isArray(enrichment.enrichedFields)
                    ? enrichment.enrichedFields
                    : typeof enrichment.enrichedFields === 'string'
                        ? enrichment.enrichedFields.split(',')
                        : [];
                const explicitFields = fieldsSource
                    .map(field => (typeof field === 'string' ? field.trim() : String(field || '').trim()))
                    .filter(Boolean);
                const providerFields = providers.flatMap(provider => provider.fields || []);
                const allFields = Array.from(new Set([...explicitFields, ...providerFields]));
                const refreshCandidates = [normalizeToISOString(enrichment.lastRefresh), ...providers.map(provider => provider.lastRefresh)].filter(Boolean);
                let lastRefresh = '';
                if (refreshCandidates.length) {
                    lastRefresh = refreshCandidates.sort().pop() || '';
                }

                result.enrichment.providers = providers;
                result.enrichment.fields = allFields;
                result.enrichment.lastRefresh = lastRefresh;
            }

            if (automation.communicationLog && typeof automation.communicationLog === 'object') {
                const communication = automation.communicationLog;
                result.communicationLog.calls = normalizeContactCallLog(communication.calls);
                result.communicationLog.emails = normalizeContactEmailLog(communication.emails);
            }

            return result;
        }

        function normalizeContact(contact) {
            if (!contact || typeof contact !== 'object') {
                return null;
            }

            const id = typeof contact.id === 'string' && contact.id.trim().length ? contact.id.trim() : generateId('contact');
            const name = typeof contact.name === 'string' && contact.name.trim().length ? contact.name.trim() : 'Новий контакт';
            const company = typeof contact.company === 'string' ? contact.company.trim() : '';
            const role = typeof contact.role === 'string' ? contact.role.trim() : '';
            const email = typeof contact.email === 'string' ? contact.email.trim() : '';
            const phone = typeof contact.phone === 'string' ? contact.phone.trim() : '';

            const rawStatus = typeof contact.status === 'string' ? contact.status.trim().toLowerCase() : '';
            let status = CONTACT_SEGMENT_SET.has(rawStatus) ? rawStatus : '';
            if (!status && rawStatus && STATUS_LABELS[rawStatus]) {
                status = rawStatus;
            }
            if (!status && rawStatus === 'active') {
                status = 'customer';
            }
            if (!status && rawStatus === 'cold') {
                status = 'lead';
            }
            if (!status && rawStatus === 'vip') {
                status = 'vip';
            }
            if (!status) {
                status = 'lead';
            }

            const owner = typeof contact.owner === 'string' && contact.owner.trim().length ? contact.owner.trim() : CURRENT_USER.name;

            const tags = Array.isArray(contact.tags)
                ? contact.tags.map(tag => (typeof tag === 'string' ? tag.trim() : String(tag || '').trim())).filter(Boolean)
                : typeof contact.tags === 'string' && contact.tags.trim().length
                    ? contact.tags.split(',').map(tag => tag.trim()).filter(Boolean)
                    : [];

            const segments = Array.isArray(contact.segments)
                ? contact.segments
                    .map(segment => (typeof segment === 'string' ? segment.trim().toLowerCase() : ''))
                    .filter(segment => CONTACT_SEGMENT_SET.has(segment))
                : [];
            if (status && CONTACT_SEGMENT_SET.has(status) && !segments.includes(status)) {
                segments.unshift(status);
            }
            const uniqueSegments = Array.from(new Set(segments));

            const lifecycleRaw = typeof contact.lifecycleStage === 'string'
                ? contact.lifecycleStage.trim().toLowerCase()
                : '';
            const lifecycleStage = CONTACT_LIFECYCLE_LABELS[lifecycleRaw]
                ? lifecycleRaw
                : (status === 'customer' || status === 'vip' || status === 'partner' ? 'customer' : 'prospect');

            const preferredChannelRaw = typeof contact.preferredChannel === 'string'
                ? contact.preferredChannel.trim().toLowerCase()
                : '';
            const preferredChannel = CONTACT_CHANNEL_LABELS[preferredChannelRaw]
                ? preferredChannelRaw
                : (email ? 'email' : 'phone');

            const timezone = typeof contact.timezone === 'string' && contact.timezone.trim().length
                ? contact.timezone.trim()
                : 'Europe/Kyiv';

            const attachments = Array.isArray(contact.attachments)
                ? contact.attachments.map(file => normalizeAttachment(file, 'contactfile')).filter(Boolean)
                : [];
            const notes = Array.isArray(contact.notes)
                ? contact.notes.map(note => normalizeNote(note, 'cnote', owner)).filter(Boolean)
                : typeof contact.notes === 'string'
                    ? [normalizeNote(contact.notes, 'cnote', owner)].filter(Boolean)
                    : [];

            const addressSource = typeof contact.address === 'object' && contact.address
                ? contact.address
                : contact;
            const address = {
                street: typeof addressSource.street === 'string' ? addressSource.street.trim() : '',
                city: typeof addressSource.city === 'string' ? addressSource.city.trim() : '',
                country: typeof addressSource.country === 'string' ? addressSource.country.trim() : '',
                postalCode: typeof addressSource.postalCode === 'string'
                    ? addressSource.postalCode.trim()
                    : (typeof addressSource.postal === 'string' ? addressSource.postal.trim() : '')
            };

            const demographicsSource = typeof contact.demographics === 'object' && contact.demographics
                ? contact.demographics
                : contact;
            let employees = Number.isFinite(Number(demographicsSource.employees))
                ? Number(demographicsSource.employees)
                : Number.isFinite(Number(demographicsSource.employeeCount))
                    ? Number(demographicsSource.employeeCount)
                    : Number.isFinite(Number(demographicsSource.headcount))
                        ? Number(demographicsSource.headcount)
                        : null;
            employees = Number.isFinite(employees) ? Math.max(0, Math.round(employees)) : null;
            let annualRevenue = Number.isFinite(Number(demographicsSource.annualRevenue))
                ? Number(demographicsSource.annualRevenue)
                : Number.isFinite(Number(demographicsSource.revenue))
                    ? Number(demographicsSource.revenue)
                    : null;
            annualRevenue = Number.isFinite(annualRevenue) ? Math.max(0, Math.round(annualRevenue)) : null;
            const demographics = {
                industry: typeof demographicsSource.industry === 'string' ? demographicsSource.industry.trim() : '',
                employees,
                annualRevenue
            };

            const website = typeof contact.website === 'string' ? contact.website.trim() : '';
            const linkedin = typeof contact.linkedin === 'string' ? contact.linkedin.trim() : '';

            const interactions = Array.isArray(contact.interactions)
                ? contact.interactions.map(item => normalizeContactInteraction(item, owner)).filter(Boolean)
                : [];
            interactions.sort((a, b) => new Date(b.timestamp || 0) - new Date(a.timestamp || 0));

            let lastActivity = typeof contact.lastActivity === 'string' && contact.lastActivity
                ? contact.lastActivity
                : null;
            if (interactions.length && interactions[0].timestamp) {
                lastActivity = interactions[0].timestamp;
            }
            if (!lastActivity) {
                lastActivity = new Date().toISOString();
            }

            const automation = normalizeContactAutomation(contact.automation);

            return {
                id,
                name,
                company,
                role,
                email,
                phone,
                status,
                segments: uniqueSegments,
                lifecycleStage,
                preferredChannel,
                timezone,
                owner,
                tags,
                website,
                linkedin,
                address,
                demographics,
                attachments,
                notes,
                interactions,
                lastActivity,
                automation
            };
        }

        function normalizeTask(task) {
            if (!task || typeof task !== 'object') {
                return null;
            }

            const id = typeof task.id === 'string' && task.id.trim().length ? task.id.trim() : generateId('task');
            const title = typeof task.title === 'string' && task.title.trim().length ? task.title.trim() : 'Нове завдання';
            const owner = typeof task.owner === 'string' && task.owner.trim().length ? task.owner.trim() : CURRENT_USER.name;
            const dueDate = typeof task.dueDate === 'string' ? task.dueDate : '';
            const allowedStatuses = TASK_COLUMNS.map(column => column.id);
            const status = allowedStatuses.includes(task.status) ? task.status : 'todo';
            const priority = ['high', 'medium', 'low'].includes(task.priority) ? task.priority : 'medium';
            const relatedLeadId = typeof task.relatedLeadId === 'string' ? task.relatedLeadId : '';
            const relatedContactId = typeof task.relatedContactId === 'string' ? task.relatedContactId : '';
            const description = typeof task.description === 'string' ? task.description.trim() : '';
            const tags = Array.isArray(task.tags)
                ? task.tags.map(tag => typeof tag === 'string' ? tag.trim() : String(tag || '').trim()).filter(Boolean)
                : typeof task.tags === 'string' && task.tags.trim().length
                    ? task.tags.split(',').map(tag => tag.trim()).filter(Boolean)
                    : [];
            const attachments = Array.isArray(task.attachments)
                ? task.attachments.map(file => normalizeAttachment(file, 'taskfile')).filter(Boolean)
                : [];
            const createdAt = typeof task.createdAt === 'string' && task.createdAt ? task.createdAt : new Date().toISOString();

            const normalizedTask = {
                id,
                title,
                owner,
                dueDate,
                priority,
                status,
                relatedLeadId,
                relatedContactId,
                description,
                tags,
                attachments,
                createdAt
            };

            if (task.completedAt) {
                normalizedTask.completedAt = task.completedAt;
            }

            return normalizedTask;
        }

        function normalizeSupportTicket(ticket) {
            if (!ticket || typeof ticket !== 'object') {
                return null;
            }

            const id = typeof ticket.id === 'string' && ticket.id.trim().length ? ticket.id.trim() : generateId('ticket');
            const subject = typeof ticket.subject === 'string' && ticket.subject.trim().length ? ticket.subject.trim() : 'Запит клієнта';
            const client = typeof ticket.client === 'string' ? ticket.client.trim() : '';
            const owner = typeof ticket.owner === 'string' && ticket.owner.trim().length ? ticket.owner.trim() : 'Команда підтримки';
            const status = typeof ticket.status === 'string' && SUPPORT_STATUS_LABELS[ticket.status] ? ticket.status : 'open';
            const priority = typeof ticket.priority === 'string' && SUPPORT_PRIORITY_LABELS[ticket.priority] ? ticket.priority : 'medium';
            const channel = typeof ticket.channel === 'string' && ticket.channel.trim().length ? ticket.channel.trim() : 'Email';
            const createdAt = typeof ticket.createdAt === 'string' && ticket.createdAt ? ticket.createdAt : new Date().toISOString();
            const firstResponseAt = typeof ticket.firstResponseAt === 'string' ? ticket.firstResponseAt : '';
            const resolvedAt = typeof ticket.resolvedAt === 'string' ? ticket.resolvedAt : '';
            const csatValue = Number(ticket.csat);
            const csat = Number.isFinite(csatValue) ? csatValue : null;

            return {
                id,
                subject,
                client,
                owner,
                status,
                priority,
                channel,
                createdAt,
                firstResponseAt,
                resolvedAt,
                csat
            };
        }

        function normalizeRoleDefinition(role, isCustom = false) {
            if (!role || typeof role !== 'object') {
                return null;
            }

            const id = typeof role.id === 'string' && role.id.trim().length ? role.id.trim() : generateId('role');
            const name = typeof role.name === 'string' && role.name.trim().length ? role.name.trim() : 'Нова роль';
            const badge = typeof role.badge === 'string' && role.badge.trim().length ? role.badge.trim() : name;
            const description = typeof role.description === 'string' ? role.description.trim() : '';
            const permissions = Array.isArray(role.permissions)
                ? role.permissions.map(item => typeof item === 'string' ? item.trim() : String(item || '').trim()).filter(Boolean)
                : [];
            const limitations = Array.isArray(role.limitations)
                ? role.limitations.map(item => typeof item === 'string' ? item.trim() : String(item || '').trim()).filter(Boolean)
                : [];
            const baseRoleId = typeof role.baseRoleId === 'string' && role.baseRoleId.trim().length ? role.baseRoleId.trim() : null;
            const createdAt = typeof role.createdAt === 'string' && role.createdAt ? role.createdAt : new Date().toISOString();
            const createdBy = typeof role.createdBy === 'string' && role.createdBy.trim().length ? role.createdBy.trim() : 'Система';
            const custom = isCustom || Boolean(role.custom);

            return {
                id,
                name,
                badge,
                description,
                permissions,
                limitations,
                baseRoleId,
                createdAt,
                createdBy,
                custom
            };
        }

        function normalizeRoleAssignment(assignment) {
            if (!assignment || typeof assignment !== 'object') {
                return null;
            }

            const name = typeof assignment.name === 'string' && assignment.name.trim().length ? assignment.name.trim() : '';
            if (!name) {
                return null;
            }

            const id = typeof assignment.id === 'string' && assignment.id.trim().length ? assignment.id.trim() : generateId('member');
            const email = typeof assignment.email === 'string' ? assignment.email.trim() : '';
            const department = typeof assignment.department === 'string' ? assignment.department.trim() : '';
            const title = typeof assignment.title === 'string' ? assignment.title.trim() : '';
            const phone = typeof assignment.phone === 'string' ? assignment.phone.trim() : '';
            const roleId = typeof assignment.roleId === 'string' && assignment.roleId.trim().length ? assignment.roleId.trim() : 'manager';
            const responsibilities = Array.isArray(assignment.responsibilities)
                ? assignment.responsibilities.map(item => typeof item === 'string' ? item.trim() : String(item || '').trim()).filter(Boolean)
                : typeof assignment.responsibilities === 'string' && assignment.responsibilities.trim().length
                    ? assignment.responsibilities.split(',').map(item => item.trim()).filter(Boolean)
                    : [];
            const note = typeof assignment.note === 'string' ? assignment.note.trim() : '';
            const updatedAt = typeof assignment.updatedAt === 'string' && assignment.updatedAt ? assignment.updatedAt : new Date().toISOString();
            const updatedBy = typeof assignment.updatedBy === 'string' && assignment.updatedBy.trim().length ? assignment.updatedBy.trim() : 'Система';
            const locked = Boolean(assignment.locked);

            return {
                id,
                name,
                email,
                department,
                title,
                phone,
                roleId,
                responsibilities,
                note,
                updatedAt,
                updatedBy,
                locked
            };
        }

        function getRoleDefinition(roleId) {
            if (!roleId) {
                return null;
            }

            const baseRole = ROLE_DEFINITIONS.find(role => role.id === roleId);
            if (baseRole) {
                return {
                    id: baseRole.id,
                    name: baseRole.name,
                    badge: baseRole.badge,
                    description: baseRole.description,
                    permissions: Array.isArray(baseRole.permissions) ? [...baseRole.permissions] : [],
                    limitations: Array.isArray(baseRole.limitations) ? [...baseRole.limitations] : [],
                    baseRoleId: baseRole.baseRoleId || null,
                    createdAt: baseRole.createdAt || '',
                    createdBy: 'Система',
                    custom: false
                };
            }

            if (crmData && crmData.roles && Array.isArray(crmData.roles.customRoles)) {
                const customRole = crmData.roles.customRoles.find(role => role.id === roleId);
                if (customRole) {
                    return normalizeRoleDefinition(customRole, true);
                }
            }

            return null;
        }

        function getAllRoleDefinitions() {
            const baseRoles = ROLE_DEFINITIONS.map(role => ({
                id: role.id,
                name: role.name,
                badge: role.badge,
                description: role.description,
                permissions: Array.isArray(role.permissions) ? [...role.permissions] : [],
                limitations: Array.isArray(role.limitations) ? [...role.limitations] : [],
                baseRoleId: role.baseRoleId || null,
                createdAt: role.createdAt || '',
                createdBy: 'Система',
                custom: false
            }));

            const customRoles = crmData && crmData.roles && Array.isArray(crmData.roles.customRoles)
                ? crmData.roles.customRoles.map(role => normalizeRoleDefinition(role, true)).filter(Boolean)
                : [];

            return [...baseRoles, ...customRoles];
        }

        function getRoleLabel(roleId) {
            const definition = getRoleDefinition(roleId);
            return definition ? definition.name : roleId;
        }

        function getInitials(value) {
            if (!value || typeof value !== 'string') {
                return '—';
            }

            const parts = value.split(/\s+/).filter(Boolean);
            if (!parts.length) {
                return value.charAt(0).toUpperCase();
            }

            return parts
                .slice(0, 2)
                .map(part => part.charAt(0).toUpperCase())
                .join('');
        }

        function updateCustomRoleBaseOptions() {
            const select = document.getElementById('customRoleBase');
            if (!select) {
                return;
            }

            const roles = getAllRoleDefinitions();
            const previousValue = select.value;
            select.innerHTML = roles.map(role => `<option value="${role.id}">${escapeHtml(role.name)}</option>`).join('');

            if (roles.some(role => role.id === previousValue)) {
                select.value = previousValue;
            } else if (roles.some(role => role.id === 'manager')) {
                select.value = 'manager';
            } else if (roles.length) {
                select.value = roles[0].id;
            }
        }

        function updateCurrentUserBadge() {
            const badge = document.getElementById('currentUserBadge');
            const nameElement = document.getElementById('currentUserName');
            if (!badge || !nameElement) {
                return;
            }

            const assignment = crmData && crmData.roles && Array.isArray(crmData.roles.assignments)
                ? crmData.roles.assignments.find(item => item.name === CURRENT_USER.name)
                : null;
            const roleId = assignment ? assignment.roleId : CURRENT_USER.role;
            const roleLabel = getRoleLabel(roleId);

            nameElement.textContent = assignment
                ? `${assignment.name} • ${roleLabel}`
                : `${CURRENT_USER.name} • ${roleLabel}`;
            badge.dataset.role = roleId;
            badge.title = `Поточна роль: ${roleLabel}`;
        }

        function normalizeFileSource(source) {
            if (!source || typeof source !== 'object') {
                return null;
            }

            const id = typeof source.id === 'string' && source.id.trim().length
                ? source.id.trim()
                : generateId('source');
            const typeValue = typeof source.type === 'string' ? source.type.toLowerCase() : '';
            const type = typeValue === 'cloud' ? 'cloud' : 'local';

            let status = typeof source.status === 'string' ? source.status.toLowerCase() : '';
            let connected = typeof source.connected === 'boolean' ? source.connected : status === 'online';

            if (status === 'syncing') {
                connected = true;
            }

            if (!['online', 'offline', 'syncing'].includes(status)) {
                status = connected ? 'online' : 'offline';
            }

            if (!connected && status === 'online') {
                connected = true;
            }

            return {
                id,
                name: typeof source.name === 'string' && source.name.trim().length ? source.name.trim() : 'Джерело файлів',
                type,
                path: typeof source.path === 'string' ? source.path : '',
                provider: typeof source.provider === 'string' ? source.provider : '',
                status,
                connected,
                autoSync: 'autoSync' in source ? Boolean(source.autoSync) : type === 'cloud',
                totalFiles: Math.max(0, Number(source.totalFiles) || 0),
                totalFolders: Math.max(0, Number(source.totalFolders) || 0),
                totalSize: Math.max(0, Number(source.totalSize) || 0),
                lastSynced: typeof source.lastSynced === 'string' && source.lastSynced ? source.lastSynced : null,
                snapshotId: typeof source.snapshotId === 'string' && source.snapshotId ? source.snapshotId : null,
                favorite: Boolean(source.favorite)
            };
        }

        function loadData() {
            let saved = null;

            if (persistentStorage && canPersistData) {
                try {
                    saved = persistentStorage.getItem(STORAGE_KEY);
                } catch (error) {
                    canPersistData = false;
                    console.warn('Локальне сховище недоступне. Дані CRM будуть збережені лише в межах поточної сесії.', error);
                }
            }

            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (parsed && typeof parsed === 'object') {
                        return upgradeDataStructure(parsed);
                    }
                } catch (error) {
                    console.warn('Не вдалося прочитати збережені дані CRM, використовую демо-набір.', error);
                }
            }
            return upgradeDataStructure(deepClone(defaultData));
        }

        function saveData() {
            if (!persistentStorage || !canPersistData) {
                return;
            }

            try {
                persistentStorage.setItem(STORAGE_KEY, JSON.stringify(crmData));
            } catch (error) {
                canPersistData = false;
                console.warn('Не вдалося зберегти дані CRM. Інформація буде доступна лише до перезавантаження сторінки.', error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            crmData = loadData();
            uiPreferences = loadPreferences();
            updateLayoutVariables();
            const snapshots = Array.isArray(crmData.fileLibrary) ? crmData.fileLibrary : [];
            const linkedSnapshot = Array.isArray(crmData.fileSources)
                ? snapshots.find(snapshot => crmData.fileSources.some(source => source.snapshotId === snapshot.id))
                : null;
            const fallbackSnapshot = snapshots.length ? snapshots[0] : null;
            const initialSnapshot = linkedSnapshot || fallbackSnapshot;
            activeFileSnapshotId = initialSnapshot ? initialSnapshot.id : null;
            const initialSource = Array.isArray(crmData.fileSources)
                ? crmData.fileSources.find(source => source.snapshotId === activeFileSnapshotId) || null
                : null;
            activeFileSourceId = initialSource ? initialSource.id : null;
            pendingFileSourceId = null;
            setupUI();
            renderAll();
        });

        window.addEventListener('beforeunload', () => {
            disposeCallCenterSockets();
        });

        const layoutManager = (() => {
            const areas = new Map();
            let draggingBlock = null;
            let draggingAreaId = null;

            function registerArea(areaId, container) {
                if (!container) {
                    return;
                }
                container.dataset.layoutArea = areaId;
                if (!areas.has(areaId)) {
                    container.addEventListener('dragover', handleDragOver);
                    container.addEventListener('drop', handleDrop);
                    container.addEventListener('dragenter', handleDragEnter);
                    container.addEventListener('dragleave', handleDragLeave);
                }
                areas.set(areaId, { container });
                refreshArea(areaId);
            }

            function refreshArea(areaId) {
                const area = areas.get(areaId);
                if (!area || !area.container) {
                    return;
                }

                const container = area.container;
                const blocks = Array.from(container.querySelectorAll('[data-block-id]'));
                area.blocks = blocks;

                const order = getLayoutOrder(areaId);
                const blockMap = new Map(blocks.map(block => [block.dataset.blockId, block]));
                order.forEach(id => {
                    const block = blockMap.get(id);
                    if (block) {
                        container.appendChild(block);
                    }
                });

                blocks.forEach(block => {
                    const id = block.dataset.blockId;
                    if (id && !order.includes(id)) {
                        container.appendChild(block);
                    }
                });

                const hiddenSet = new Set(getHiddenBlocks(areaId));
                blocks.forEach(block => {
                    const blockId = block.dataset.blockId;
                    if (!blockId) {
                        return;
                    }
                    const hidden = hiddenSet.has(blockId);
                    block.dataset.layoutArea = areaId;
                    block.classList.toggle('layout-hidden', hidden);
                    block.removeEventListener('dragstart', handleDragStart);
                    block.removeEventListener('dragend', handleDragEnd);

                    if (hidden) {
                        block.setAttribute('draggable', 'false');
                        block.classList.remove('layout-draggable', 'is-dragging');
                    } else {
                        block.setAttribute('draggable', 'true');
                        block.classList.add('layout-draggable');
                        block.addEventListener('dragstart', handleDragStart);
                        block.addEventListener('dragend', handleDragEnd);
                    }
                });
            }

            function handleDragStart(event) {
                const block = event.currentTarget;
                draggingBlock = block;
                draggingAreaId = block.dataset.layoutArea;
                if (event.dataTransfer) {
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text/plain', block.dataset.blockId || '');
                }
                requestAnimationFrame(() => block.classList.add('is-dragging'));
            }

            function handleDragEnd(event) {
                const block = event.currentTarget;
                block.classList.remove('is-dragging');
                const areaId = block.dataset.layoutArea;
                draggingBlock = null;
                draggingAreaId = null;
                if (areaId) {
                    finalizeAreaOrder(areaId);
                }
            }

            function handleDragEnter(event) {
                const container = event.currentTarget;
                if (!draggingBlock) {
                    return;
                }
                if (container.dataset.layoutArea === draggingAreaId) {
                    container.classList.add('is-drag-over');
                }
            }

            function handleDragLeave(event) {
                const container = event.currentTarget;
                if (!container.dataset.layoutArea) {
                    return;
                }
                if (!draggingBlock || !container.contains(event.relatedTarget)) {
                    container.classList.remove('is-drag-over');
                }
            }

            function handleDragOver(event) {
                if (!draggingBlock) {
                    return;
                }
                const container = event.currentTarget;
                const areaId = container.dataset.layoutArea;
                if (!areaId || areaId !== draggingAreaId) {
                    return;
                }
                event.preventDefault();
                const afterElement = getDragAfterElement(container, event);
                if (!afterElement) {
                    container.appendChild(draggingBlock);
                } else if (afterElement !== draggingBlock) {
                    container.insertBefore(draggingBlock, afterElement);
                }
            }

            function handleDrop(event) {
                const container = event.currentTarget;
                container.classList.remove('is-drag-over');
                if (!draggingBlock) {
                    return;
                }
                const areaId = container.dataset.layoutArea;
                if (!areaId || areaId !== draggingAreaId) {
                    return;
                }
                event.preventDefault();
                finalizeAreaOrder(areaId);
                draggingBlock = null;
                draggingAreaId = null;
            }

            function getDragAfterElement(container, event) {
                const blocks = Array.from(container.querySelectorAll('[data-block-id]:not(.layout-hidden):not(.is-dragging)'));
                if (!blocks.length) {
                    return null;
                }
                const pointerY = event.clientY;
                let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
                blocks.forEach(block => {
                    const rect = block.getBoundingClientRect();
                    const offset = pointerY - rect.top - rect.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        closest = { offset, element: block };
                    }
                });
                return closest.element;
            }

            function finalizeAreaOrder(areaId) {
                const area = areas.get(areaId);
                if (!area || !area.container) {
                    return;
                }
                const ids = Array.from(area.container.querySelectorAll('[data-block-id]')).map(el => el.dataset.blockId);
                setLayoutOrder(areaId, ids);
            }

            return {
                registerArea,
                refreshArea
            };
        })();

        function initializeLayoutAreas() {
            const dashboardGrid = document.querySelector('[data-layout-area="dashboard"]');
            if (dashboardGrid) {
                layoutManager.registerArea('dashboard', dashboardGrid);
            }
            const metricsGrid = document.querySelector('[data-layout-area="metrics"]');
            if (metricsGrid) {
                layoutManager.registerArea('metrics', metricsGrid);
            }
        }

        function setupSettingsPanel() {
            renderVisibilityControls();
            syncColumnControls();
            syncCardWidthControls();
            syncCompactToggle();
            updateLayoutOrderPreview();

            document.querySelectorAll('input[name="dashboardColumns"]').forEach(radio => {
                radio.addEventListener('change', event => {
                    if (event.target.checked) {
                        setLayoutColumns('dashboard', event.target.value);
                    }
                });
            });

            document.querySelectorAll('input[name="metricsColumns"]').forEach(radio => {
                radio.addEventListener('change', event => {
                    if (event.target.checked) {
                        setLayoutColumns('metrics', event.target.value);
                    }
                });
            });

            const compactToggle = document.getElementById('compactLayoutToggle');
            if (compactToggle) {
                compactToggle.addEventListener('change', event => {
                    setCompactMode(event.target.checked);
                });
            }

            const dashboardSlider = document.getElementById('dashboardMinWidthSlider');
            const dashboardValue = document.getElementById('dashboardMinWidthValue');
            if (dashboardSlider && dashboardValue) {
                dashboardSlider.value = getCardMinWidth('dashboard');
                dashboardValue.textContent = `${dashboardSlider.value}px`;
                dashboardSlider.addEventListener('input', event => {
                    const value = Number(event.target.value);
                    dashboardValue.textContent = `${value}px`;
                    setCardMinWidth('dashboard', value);
                });
            }

            const metricsSlider = document.getElementById('metricsMinWidthSlider');
            const metricsValue = document.getElementById('metricsMinWidthValue');
            if (metricsSlider && metricsValue) {
                metricsSlider.value = getCardMinWidth('metrics');
                metricsValue.textContent = `${metricsSlider.value}px`;
                metricsSlider.addEventListener('input', event => {
                    const value = Number(event.target.value);
                    metricsValue.textContent = `${value}px`;
                    setCardMinWidth('metrics', value);
                });
            }

            const resetButton = document.getElementById('resetLayoutBtn');
            if (resetButton) {
                resetButton.addEventListener('click', () => {
                    if (confirm('Скинути макет до стандартного вигляду?')) {
                        resetLayoutPreferences();
                    }
                });
            }
        }

        function renderVisibilityControls() {
            const dashboardContainer = document.getElementById('dashboardVisibilityControls');
            if (dashboardContainer) {
                const hidden = new Set(getHiddenBlocks('dashboard'));
                dashboardContainer.innerHTML = DASHBOARD_BLOCK_IDS.map(id => {
                    const label = escapeHtml(DASHBOARD_BLOCK_LABELS[id] || id);
                    const checked = hidden.has(id) ? '' : 'checked';
                    return `<label class="setting-checkbox"><input type="checkbox" value="${id}" ${checked}>${label}</label>`;
                }).join('');

                dashboardContainer.querySelectorAll('input[type="checkbox"]').forEach(input => {
                    input.addEventListener('change', event => {
                        setBlockVisibility('dashboard', event.target.value, event.target.checked);
                        layoutManager.refreshArea('dashboard');
                    });
                });
            }

            const metricsContainer = document.getElementById('metricsVisibilityControls');
            if (metricsContainer) {
                const hiddenMetrics = new Set(getHiddenBlocks('metrics'));
                metricsContainer.innerHTML = METRIC_BLOCK_IDS.map(id => {
                    const label = escapeHtml(METRIC_BLOCK_LABELS[id] || id);
                    const checked = hiddenMetrics.has(id) ? '' : 'checked';
                    return `<label class="setting-checkbox"><input type="checkbox" value="${id}" ${checked}>${label}</label>`;
                }).join('');

                metricsContainer.querySelectorAll('input[type="checkbox"]').forEach(input => {
                    input.addEventListener('change', event => {
                        setBlockVisibility('metrics', event.target.value, event.target.checked);
                        renderDashboard();
                    });
                });
            }
        }

        function updateLayoutOrderPreview() {
            const dashboardList = document.getElementById('dashboardOrderPreview');
            if (dashboardList) {
                const order = getLayoutOrder('dashboard');
                const hidden = new Set(getHiddenBlocks('dashboard'));
                dashboardList.innerHTML = order.map(id => {
                    const label = escapeHtml(DASHBOARD_BLOCK_LABELS[id] || id);
                    const hiddenLabel = hidden.has(id) ? '<span class="settings-tag">приховано</span>' : '';
                    const className = hidden.has(id) ? ' class="is-hidden"' : '';
                    return `<li${className}>${label}${hiddenLabel}</li>`;
                }).join('');
            }

            const metricsList = document.getElementById('metricsOrderPreview');
            if (metricsList) {
                const order = getLayoutOrder('metrics');
                const hidden = new Set(getHiddenBlocks('metrics'));
                metricsList.innerHTML = order.map(id => {
                    const label = escapeHtml(METRIC_BLOCK_LABELS[id] || id);
                    const hiddenLabel = hidden.has(id) ? '<span class="settings-tag">приховано</span>' : '';
                    const className = hidden.has(id) ? ' class="is-hidden"' : '';
                    return `<li${className}>${label}${hiddenLabel}</li>`;
                }).join('');
            }
        }

        function syncColumnControls() {
            const dashboardValue = getColumnInputValue('dashboard');
            document.querySelectorAll('input[name="dashboardColumns"]').forEach(radio => {
                radio.checked = radio.value === dashboardValue;
            });
            const metricsValue = getColumnInputValue('metrics');
            document.querySelectorAll('input[name="metricsColumns"]').forEach(radio => {
                radio.checked = radio.value === metricsValue;
            });
        }

        function syncCardWidthControls() {
            const dashboardSlider = document.getElementById('dashboardMinWidthSlider');
            const dashboardValue = document.getElementById('dashboardMinWidthValue');
            if (dashboardSlider) {
                const value = getCardMinWidth('dashboard');
                if (dashboardSlider.value !== String(value)) {
                    dashboardSlider.value = value;
                }
                if (dashboardValue) {
                    dashboardValue.textContent = `${value}px`;
                }
            }

            const metricsSlider = document.getElementById('metricsMinWidthSlider');
            const metricsValue = document.getElementById('metricsMinWidthValue');
            if (metricsSlider) {
                const value = getCardMinWidth('metrics');
                if (metricsSlider.value !== String(value)) {
                    metricsSlider.value = value;
                }
                if (metricsValue) {
                    metricsValue.textContent = `${value}px`;
                }
            }
        }

        function syncCompactToggle() {
            const toggle = document.getElementById('compactLayoutToggle');
            if (toggle) {
                toggle.checked = Boolean(uiPreferences?.layout?.compactMode);
            }
        }

        function setupUI() {
            populateDropdowns();
            setupNavigation();
            setupModals();
            setupForms();
            initializeAttachmentAreas();
            setupSearch();
            setupFilters();
            setupFileLibrary();
            setupRoleManagement();
            setupSettingsPanel();
            initializeCallCenterAnalytics();
            initializeLayoutAreas();
            setupCustomCharts();
            document.getElementById('resetDataBtn').addEventListener('click', resetDemoData);
            document.getElementById('refreshDashboardBtn').addEventListener('click', () => {
                renderDashboard();
                renderAnalytics();
            });
            document.getElementById('openLeadModalBtn').addEventListener('click', openLeadCreationModal);
            document.getElementById('addPipelineLeadBtn').addEventListener('click', openLeadCreationModal);
            document.getElementById('openContactModalBtn').addEventListener('click', () => openModal('addContactModal'));
            document.getElementById('openTaskModalBtn').addEventListener('click', () => openTaskModal());
            const projectModalBtn = document.getElementById('openProjectModalBtn');
            if (projectModalBtn) {
                projectModalBtn.addEventListener('click', () => openModal('addProjectModal'));
            }
        }

        function populateDropdowns() {
            const stageSelect = document.getElementById('leadStage');
            stageSelect.innerHTML = STAGES.filter(stage => stage !== 'Втрачено').map(stage => `<option value="${stage}">${stage}</option>`).join('');

            const ownerSelects = [
                document.getElementById('leadOwner'),
                document.getElementById('contactOwner'),
                document.getElementById('taskOwner'),
                document.getElementById('projectOwner')
            ].filter(Boolean);

            ownerSelects.forEach(select => {
                select.innerHTML = TEAM_MEMBERS.map(member => `<option value="${member}">${member}</option>`).join('');
            });

            const contactStatusSelect = document.getElementById('contactStatus');
            if (contactStatusSelect) {
                contactStatusSelect.innerHTML = CONTACT_SEGMENT_OPTIONS
                    .map(option => `<option value="${option.id}">${option.label}</option>`)
                    .join('');
                if (!CONTACT_SEGMENT_SET.has(contactStatusSelect.value)) {
                    contactStatusSelect.value = CONTACT_SEGMENT_OPTIONS[0]?.id || '';
                }
            }

            const contactSegmentsSelect = document.getElementById('contactSegments');
            if (contactSegmentsSelect) {
                contactSegmentsSelect.innerHTML = CONTACT_SEGMENT_OPTIONS
                    .map(option => `<option value="${option.id}">${option.label}</option>`)
                    .join('');
            }

            const contactLifecycleSelect = document.getElementById('contactLifecycle');
            if (contactLifecycleSelect && !CONTACT_LIFECYCLE_LABELS[contactLifecycleSelect.value]) {
                contactLifecycleSelect.value = 'prospect';
            }

            const contactChannelSelect = document.getElementById('contactChannel');
            if (contactChannelSelect && !CONTACT_CHANNEL_LABELS[contactChannelSelect.value]) {
                contactChannelSelect.value = 'email';
            }

            const contactTimezoneInput = document.getElementById('contactTimezone');
            if (contactTimezoneInput && !contactTimezoneInput.value) {
                contactTimezoneInput.value = 'Europe/Kyiv';
            }

            const sourceSelect = document.getElementById('leadSource');
            if (sourceSelect) {
                sourceSelect.innerHTML = LEAD_SOURCE_OPTIONS
                    .map(option => `<option value="${option.id}">${option.label}</option>`)
                    .join('');
                sourceSelect.value = LEAD_SOURCE_OPTIONS[0]?.id || '';
            }

            const qualificationSelect = document.getElementById('leadQualification');
            if (qualificationSelect) {
                qualificationSelect.innerHTML = LEAD_QUALIFICATION_OPTIONS
                    .map(option => `<option value="${option.id}">${option.label}</option>`)
                    .join('');
                qualificationSelect.value = LEAD_QUALIFICATION_OPTIONS[0]?.id || 'new';
            }

            updateLeadScoreIndicator(document.getElementById('leadScore')?.value || LEAD_SCORE_DEFAULT);
            updateLeadOwnerSuggestion(true);

            const projectStageSelect = document.getElementById('projectStage');
            if (projectStageSelect) {
                projectStageSelect.innerHTML = PROJECT_STAGES.map(stage => `<option value="${stage}">${stage}</option>`).join('');
            }

            const projectTeamSelect = document.getElementById('projectTeam');
            if (projectTeamSelect) {
                projectTeamSelect.innerHTML = TEAM_MEMBERS.map(member => `<option value="${member}">${member}</option>`).join('');
            }

            const projectStageFilterSelect = document.getElementById('projectStageFilter');
            if (projectStageFilterSelect) {
                const options = ['<option value="all">Всі етапи</option>', ...PROJECT_STAGES.map(stage => `<option value="${stage}">${stage}</option>`)];
                projectStageFilterSelect.innerHTML = options.join('');
                projectStageFilterSelect.value = PROJECT_STAGES.includes(projectStageFilter) ? projectStageFilter : 'all';
            }

            const pipelineFilter = document.getElementById('pipelineOwnerFilter');
            if (pipelineFilter) {
                pipelineFilter.innerHTML = '<option value="all">Всі менеджери</option>';
                TEAM_MEMBERS.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    pipelineFilter.appendChild(option);
                });
                pipelineFilter.value = pipelineFilterOwner;
            }

            updateTaskLeadOptions();
        }

        function updateTaskLeadOptions() {
            const taskLeadSelect = document.getElementById('taskLead');
            const options = [`<option value="">Без прив'язки</option>`];
            crmData.leads.forEach(lead => {
                options.push(`<option value="${lead.id}">${lead.name} (${lead.company})</option>`);
            });
            taskLeadSelect.innerHTML = options.join('');
        }

        function setupNavigation() {
            const nav = document.getElementById('mainNav');
            if (!nav) {
                return;
            }

            const navItems = Array.from(nav.querySelectorAll('.nav-item'));
            const navGroups = Array.from(nav.querySelectorAll('.nav-group'));
            const searchInput = document.getElementById('navSearch');
            const filterSelect = document.getElementById('navFilter');

            navigationState.search = searchInput ? searchInput.value || '' : '';
            navigationState.filter = filterSelect ? filterSelect.value || 'all' : 'all';

            const emptyState = document.createElement('div');
            emptyState.className = 'nav-empty';
            emptyState.setAttribute('role', 'status');
            emptyState.setAttribute('aria-live', 'polite');
            emptyState.setAttribute('aria-hidden', 'true');
            emptyState.textContent = 'Немає модулів за вашим запитом.';
            nav.appendChild(emptyState);

            const activateItem = item => {
                const target = item.dataset.sectionTarget;
                if (!target) {
                    return;
                }

                document.querySelectorAll('.section').forEach(section => section.classList.remove('active'));
                const section = document.getElementById(target);
                if (section) {
                    section.classList.add('active');
                }

                navItems.forEach(btn => btn.classList.remove('active'));
                item.classList.add('active');
            };

            navItems.forEach(item => {
                item.addEventListener('click', () => activateItem(item));
            });

            applyNavigationFilters = () => {
                const searchTerm = navigationState.search.trim().toLowerCase();
                const filterValue = navigationState.filter;
                let visibleCount = 0;

                navItems.forEach(item => {
                    const text = (item.textContent || '').toLowerCase();
                    const keywords = (item.dataset.navKeywords || '').toLowerCase();
                    const categories = (item.dataset.navCategory || '').split(/\s+/).filter(Boolean);
                    const matchesSearch = !searchTerm || text.includes(searchTerm) || keywords.includes(searchTerm);
                    const matchesFilter = filterValue === 'all' || categories.includes(filterValue);
                    const isVisible = matchesSearch && matchesFilter;

                    item.classList.toggle('is-hidden', !isVisible);
                    item.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
                    if (isVisible) {
                        item.removeAttribute('tabindex');
                        visibleCount += 1;
                    } else {
                        item.setAttribute('tabindex', '-1');
                    }
                });

                navGroups.forEach(group => {
                    const hasVisible = Array.from(group.querySelectorAll('.nav-item')).some(item => !item.classList.contains('is-hidden'));
                    group.classList.toggle('is-collapsed', !hasVisible);
                });

                if (visibleCount === 0) {
                    emptyState.classList.add('is-visible');
                    emptyState.setAttribute('aria-hidden', 'false');
                } else {
                    emptyState.classList.remove('is-visible');
                    emptyState.setAttribute('aria-hidden', 'true');
                }
            };

            if (searchInput) {
                searchInput.addEventListener('input', event => {
                    navigationState.search = event.target.value;
                    applyNavigationFilters();
                });
            }

            if (filterSelect) {
                filterSelect.addEventListener('change', event => {
                    navigationState.filter = event.target.value;
                    applyNavigationFilters();
                });
            }

            applyNavigationFilters();
        }

        function openContactsSection(contactId = null) {
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.remove('active'));
            const contactsSection = document.getElementById('contactsSection');
            if (contactsSection) {
                contactsSection.classList.add('active');
            }

            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => item.classList.remove('active'));
            const contactsNav = document.querySelector('.nav-item[data-section-target="contactsSection"]');
            if (contactsNav) {
                contactsNav.classList.add('active');
            }

            if (contactId) {
                activeContactId = contactId;
            }

            const searchInput = document.getElementById('contactSearch');
            const currentQuery = searchInput ? searchInput.value || '' : '';
            renderContacts(currentQuery);

            if (contactsSection) {
                contactsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function setupModals() {
            document.querySelectorAll('[data-close]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const modal = btn.closest('.modal');
                    if (modal) closeModal(modal.id);
                });
            });

            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', event => {
                    if (event.target === modal) {
                        closeModal(modal.id);
                    }
                });
            });
        }

        function setupForms() {
            document.getElementById('leadForm').addEventListener('submit', handleLeadSubmit);
            document.getElementById('contactForm').addEventListener('submit', handleContactSubmit);
            document.getElementById('taskForm').addEventListener('submit', handleTaskSubmit);
            const projectForm = document.getElementById('projectForm');
            if (projectForm) {
                projectForm.addEventListener('submit', handleProjectSubmit);
            }

            const leadSourceSelect = document.getElementById('leadSource');
            if (leadSourceSelect) {
                leadSourceSelect.addEventListener('change', () => updateLeadOwnerSuggestion(false));
            }

            const leadOwnerSelect = document.getElementById('leadOwner');
            if (leadOwnerSelect) {
                leadOwnerSelect.addEventListener('change', () => {
                    leadOwnerManuallySelected = true;
                    updateLeadOwnerSuggestion(false);
                });
            }

            const leadScoreInput = document.getElementById('leadScore');
            if (leadScoreInput) {
                leadScoreInput.addEventListener('input', event => updateLeadScoreIndicator(event.target.value));
            }
        }

        function openLeadCreationModal() {
            leadOwnerManuallySelected = false;
            const form = document.getElementById('leadForm');
            if (form) {
                form.reset();
            }

            const sourceSelect = document.getElementById('leadSource');
            if (sourceSelect && LEAD_SOURCE_OPTIONS.length) {
                sourceSelect.value = LEAD_SOURCE_OPTIONS[0].id;
            }

            const qualificationSelect = document.getElementById('leadQualification');
            if (qualificationSelect && LEAD_QUALIFICATION_OPTIONS.length) {
                qualificationSelect.value = LEAD_QUALIFICATION_OPTIONS[0].id;
            }

            const scoreInput = document.getElementById('leadScore');
            if (scoreInput) {
                scoreInput.value = LEAD_SCORE_DEFAULT;
                updateLeadScoreIndicator(LEAD_SCORE_DEFAULT);
            }

            const expectedCloseInput = document.getElementById('leadExpectedClose');
            if (expectedCloseInput) {
                const baseDate = startOfDay(new Date());
                if (baseDate) {
                    baseDate.setDate(baseDate.getDate() + 14);
                    expectedCloseInput.value = formatDateForInput(baseDate);
                } else {
                    expectedCloseInput.value = '';
                }
            }

            updateLeadOwnerSuggestion(true);
            resetAttachmentArea('lead');
            openModal('addLeadModal');
        }

        function initializeAttachmentAreas() {
            const areas = [
                {
                    key: 'lead',
                    dropzoneId: 'leadFileDropzone',
                    inputId: 'leadFiles',
                    browseButtonId: 'leadFileBrowseBtn',
                    listId: 'leadFileList',
                    progressId: 'leadUploadProgress',
                    progressBarId: 'leadUploadBar',
                    progressLabelId: 'leadUploadLabel',
                    progressTextId: 'leadUploadText',
                    allowDirectories: true,
                    emptyText: 'Файли ще не обрано.'
                },
                {
                    key: 'project',
                    dropzoneId: 'projectFileDropzone',
                    inputId: 'projectFiles',
                    browseButtonId: 'projectFileBrowseBtn',
                    listId: 'projectFileList',
                    progressId: 'projectUploadProgress',
                    progressBarId: 'projectUploadBar',
                    progressLabelId: 'projectUploadLabel',
                    progressTextId: 'projectUploadText',
                    allowDirectories: false,
                    emptyText: 'Документи проекту ще не додано.'
                },
                {
                    key: 'contact',
                    dropzoneId: 'contactFileDropzone',
                    inputId: 'contactFiles',
                    browseButtonId: 'contactFileBrowseBtn',
                    listId: 'contactFileList',
                    progressId: 'contactUploadProgress',
                    progressBarId: 'contactUploadBar',
                    progressLabelId: 'contactUploadLabel',
                    progressTextId: 'contactUploadText',
                    allowDirectories: false,
                    emptyText: 'Прикріпіть договори чи листування.'
                },
                {
                    key: 'task',
                    dropzoneId: 'taskFileDropzone',
                    inputId: 'taskFiles',
                    browseButtonId: 'taskFileBrowseBtn',
                    listId: 'taskFileList',
                    progressId: 'taskUploadProgress',
                    progressBarId: 'taskUploadBar',
                    progressLabelId: 'taskUploadLabel',
                    progressTextId: 'taskUploadText',
                    allowDirectories: false,
                    emptyText: 'Матеріали для завдання ще не додані.'
                }
            ];

            areas.forEach(area => registerAttachmentArea(area.key, area));
        }

        function getAttachmentState(areaKey) {
            return attachmentAreas[areaKey] || null;
        }

        function registerAttachmentArea(areaKey, config) {
            const dropzone = document.getElementById(config.dropzoneId);
            const input = document.getElementById(config.inputId);
            const list = document.getElementById(config.listId);

            if (!dropzone || !input || !list) {
                return;
            }

            const area = {
                key: areaKey,
                dropzone,
                input,
                list,
                files: [],
                progress: new Map(),
                uploading: false,
                options: {
                    allowDirectories: config.allowDirectories !== false,
                    maxItemSize: config.maxItemSize || MAX_ATTACHMENT_SIZE,
                    maxTotalSize: config.maxTotalSize || MAX_TOTAL_ATTACHMENTS_SIZE,
                    emptyText: config.emptyText || 'Файли ще не обрано.'
                },
                browseButton: config.browseButtonId ? document.getElementById(config.browseButtonId) : null,
                progressContainer: config.progressId ? document.getElementById(config.progressId) : null,
                progressBar: config.progressBarId ? document.getElementById(config.progressBarId) : null,
                progressLabel: config.progressLabelId ? document.getElementById(config.progressLabelId) : null,
                progressText: config.progressTextId ? document.getElementById(config.progressTextId) : null
            };

            attachmentAreas[areaKey] = area;

            const openPicker = () => input.click();

            if (area.browseButton) {
                area.browseButton.addEventListener('click', event => {
                    event.stopPropagation();
                    openPicker();
                });
            }

            dropzone.addEventListener('click', event => {
                if (!event.target.closest('.file-browse-btn')) {
                    openPicker();
                }
            });

            dropzone.addEventListener('keydown', event => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    openPicker();
                }
            });

            input.addEventListener('change', event => {
                const files = event.target.files;
                if (files && files.length) {
                    const normalized = Array.from(files).map(file =>
                        setFileRelativePath(file, file.webkitRelativePath || file.name)
                    );
                    addFilesToAttachmentArea(areaKey, normalized);
                    event.target.value = '';
                }
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropzone.addEventListener(eventName, event => {
                    event.preventDefault();
                    event.stopPropagation();
                    dropzone.classList.add('dragover');
                });
            });

            ['dragleave', 'dragend'].forEach(eventName => {
                dropzone.addEventListener(eventName, event => {
                    if (eventName === 'dragleave' && event.relatedTarget && dropzone.contains(event.relatedTarget)) {
                        return;
                    }
                    dropzone.classList.remove('dragover');
                });
            });

            dropzone.addEventListener('drop', async event => {
                event.preventDefault();
                dropzone.classList.remove('dragover');

                const dataTransfer = event.dataTransfer;
                if (!dataTransfer) {
                    return;
                }

                try {
                    let files = [];
                    if (area.options.allowDirectories && dataTransfer.items && dataTransfer.items.length) {
                        files = await extractFilesFromDataTransferItems(dataTransfer.items);
                    }

                    if ((!files || !files.length) && dataTransfer.files?.length) {
                        files = Array.from(dataTransfer.files).map(file =>
                            setFileRelativePath(file, file.webkitRelativePath || file.name)
                        );
                    }

                    if (files.length) {
                        addFilesToAttachmentArea(areaKey, files);
                    }
                } catch (error) {
                    console.warn('Не вдалося обробити файли з папки', error);
                }
            });

            renderAttachmentArea(areaKey);
        }

        function addFilesToAttachmentArea(areaKey, files) {
            const area = getAttachmentState(areaKey);
            if (!area || !Array.isArray(files) || !files.length) {
                return;
            }

            const existing = new Set(area.files.map(getFileKey));
            files.forEach(file => {
                const key = getFileKey(file);
                if (!existing.has(key)) {
                    area.files.push(file);
                    existing.add(key);
                }
            });

            renderAttachmentArea(areaKey);
        }

        function renderAttachmentArea(areaKey) {
            const area = getAttachmentState(areaKey);
            if (!area) {
                return;
            }

            const { list, dropzone, files, options } = area;
            if (!list) {
                return;
            }

            if (files.length === 0) {
                list.innerHTML = `<div class="file-empty">${options.emptyText}</div>`;
            } else {
                list.innerHTML = files.map((file, index) => {
                    const displayName = typeof file?.name === 'string' && file.name.length ? file.name : 'Файл';
                    const relativePathRaw = getFileRelativePath(file);
                    const safeName = escapeHtml(displayName);
                    const safePath = relativePathRaw && relativePathRaw !== displayName ? escapeHtml(relativePathRaw) : '';
                    const sizeLabel = formatBytes(Number(file.size) || 0);
                    const metaText = safePath ? `${safePath} • ${sizeLabel}` : sizeLabel;
                    const icon = getAttachmentIcon(file.type);
                    const key = getFileKey(file);
                    return `
                        <div class="file-item">
                            <div class="file-item-info">
                                <div class="file-icon"><i class="fa-solid ${icon}"></i></div>
                                <div>
                                    <strong>${safeName}</strong>
                                    <div class="file-meta">${metaText}</div>
                                </div>
                            </div>
                            <button type="button" class="file-remove" data-remove="${index}" aria-label="Видалити файл ${safeName}">
                                <i class="fa-solid fa-xmark"></i>
                            </button>
                            <div class="file-progress" data-progress-key="${key}">
                                <div class="file-progress-track"><div class="file-progress-value"></div></div>
                                <span class="file-progress-label">0%</span>
                            </div>
                        </div>
                    `;
                }).join('');

                list.querySelectorAll('[data-remove]').forEach(btn => {
                    btn.addEventListener('click', event => {
                        event.stopPropagation();
                        const index = Number(btn.dataset.remove);
                        removeAttachmentFromArea(areaKey, index);
                    });
                });
            }

            if (dropzone) {
                dropzone.classList.toggle('has-files', files.length > 0);
            }

            updateAttachmentProgressSummary(areaKey);
        }

        function removeAttachmentFromArea(areaKey, index) {
            const area = getAttachmentState(areaKey);
            if (!area || !Number.isInteger(index) || index < 0 || index >= area.files.length) {
                return;
            }

            const [removed] = area.files.splice(index, 1);
            if (removed) {
                area.progress.delete(getFileKey(removed));
            }

            renderAttachmentArea(areaKey);
        }

        function resetAttachmentArea(areaKey) {
            const area = getAttachmentState(areaKey);
            if (!area) {
                return;
            }

            area.files = [];
            area.progress.clear();
            area.uploading = false;
            if (area.input) {
                area.input.value = '';
            }
            renderAttachmentArea(areaKey);
        }

        function updateAttachmentProgressUI(areaKey, fileKey) {
            const area = getAttachmentState(areaKey);
            if (!area) {
                return;
            }

            const entry = area.progress.get(fileKey);
            const progressElement = area.list ? area.list.querySelector(`.file-progress[data-progress-key="${fileKey}"]`) : null;
            if (progressElement && entry) {
                const valueEl = progressElement.querySelector('.file-progress-value');
                const labelEl = progressElement.querySelector('.file-progress-label');
                const percent = entry.total ? Math.min(100, Math.round((entry.loaded / entry.total) * 100)) : 0;
                if (valueEl) {
                    valueEl.style.width = `${percent}%`;
                }
                if (labelEl) {
                    labelEl.textContent = `${percent}%`;
                }
            }

            updateAttachmentProgressSummary(areaKey);
        }

        function updateAttachmentProgressSummary(areaKey) {
            const area = getAttachmentState(areaKey);
            if (!area || !area.progressContainer) {
                return;
            }

            const { progressContainer, progressBar, progressLabel, progressText, files, progress, uploading } = area;

            if (!files.length) {
                progressContainer.classList.remove('active');
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                if (progressLabel) {
                    progressLabel.textContent = 'Готово';
                }
                if (progressText) {
                    progressText.textContent = 'Очікування файлів…';
                }
                return;
            }

            const totalBytes = files.reduce((sum, file) => sum + (Number(file.size) || 0), 0);
            const loadedBytes = Array.from(progress.values()).reduce((sum, entry) => sum + Math.min(entry.loaded, entry.total || 0), 0);
            const percent = totalBytes > 0 ? Math.min(100, Math.round((loadedBytes / totalBytes) * 100)) : (uploading ? 0 : 100);
            const finished = Array.from(progress.values()).filter(entry => entry.total && entry.loaded >= entry.total).length;

            if (progressBar) {
                progressBar.style.width = `${percent}%`;
            }
            if (progressLabel) {
                progressLabel.textContent = `${percent}%`;
            }
            if (progressText) {
                if (uploading) {
                    progressText.textContent = `Опрацьовано ${finished}/${files.length} файлів`;
                } else if (finished === files.length) {
                    progressText.textContent = `Додано ${files.length} файл(и)`;
                } else {
                    progressText.textContent = `Готово до завантаження: ${files.length} файл(и)`;
                }
            }

            progressContainer.classList.add('active');
        }

        async function prepareAttachmentsForArea(areaKey) {
            const area = getAttachmentState(areaKey);
            if (!area || area.files.length === 0) {
                return [];
            }

            const attachments = [];
            const skipped = [];
            let totalSize = 0;

            area.progress.clear();
            area.uploading = true;
            updateAttachmentProgressSummary(areaKey);

            for (const file of area.files) {
                const fileSize = Number(file.size) || 0;
                const displayName = typeof file?.name === 'string' && file.name.length ? file.name : 'Файл';
                const relativePath = getFileRelativePath(file);

                if (fileSize > area.options.maxItemSize) {
                    skipped.push(`«${displayName}» перевищує обмеження ${formatBytes(area.options.maxItemSize)}.`);
                    continue;
                }

                if (totalSize + fileSize > area.options.maxTotalSize) {
                    skipped.push(`«${displayName}» не додано: перевищено загальний ліміт ${formatBytes(area.options.maxTotalSize)}.`);
                    continue;
                }

                const fileKey = getFileKey(file);
                area.progress.set(fileKey, { loaded: 0, total: fileSize });
                updateAttachmentProgressUI(areaKey, fileKey);

                try {
                    const dataUrl = await readFileAsDataURL(file, (loaded, total) => {
                        area.progress.set(fileKey, { loaded, total: total || fileSize });
                        updateAttachmentProgressUI(areaKey, fileKey);
                    });

                    attachments.push({
                        id: generateId('file'),
                        name: displayName,
                        path: relativePath || displayName,
                        size: fileSize,
                        type: file.type || 'application/octet-stream',
                        lastModified: Number(file.lastModified) || Date.now(),
                        dataUrl
                    });
                    totalSize += fileSize;
                    area.progress.set(fileKey, { loaded: fileSize, total: fileSize });
                    updateAttachmentProgressUI(areaKey, fileKey);
                } catch (error) {
                    console.error('Не вдалося прочитати файл', error);
                    skipped.push(`Сталася помилка під час читання «${displayName}».`);
                }
            }

            area.uploading = false;
            updateAttachmentProgressSummary(areaKey);

            if (skipped.length) {
                alert(`Деякі файли не були додані:\n${skipped.join('\n')}`);
            }

            return attachments;
        }

        function setFileRelativePath(file, path) {
            if (!file || typeof path !== 'string') {
                return file;
            }

            const trimmed = path.replace(/^[\\/]+/, '');
            const sanitized = trimmed.replace(/\\/g, '/');

            if (!sanitized) {
                return file;
            }

            try {
                file._relativePath = sanitized;
            } catch (error) {
                // ignore inability to attach metadata to the File object
            }

            if (!file.webkitRelativePath) {
                try {
                    Object.defineProperty(file, 'webkitRelativePath', {
                        configurable: true,
                        enumerable: false,
                        value: sanitized
                    });
                } catch (error) {
                    // Some environments expose a read-only property; ignore failures
                }
            }

            return file;
        }

        function getFileRelativePath(file) {
            if (!file || typeof file !== 'object') {
                return '';
            }

            const candidate = typeof file._relativePath === 'string' && file._relativePath.length
                ? file._relativePath
                : typeof file.webkitRelativePath === 'string' && file.webkitRelativePath.length
                    ? file.webkitRelativePath
                    : '';

            if (candidate) {
                return candidate.replace(/\\/g, '/');
            }

            return typeof file.name === 'string' ? file.name : '';
        }

        async function extractFilesFromDataTransferItems(items) {
            if (!items || typeof items.length !== 'number' || items.length === 0) {
                return [];
            }

            const collected = [];

            const processEntry = async entry => {
                if (!entry) {
                    return;
                }

                if (entry.isFile) {
                    try {
                        const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
                        const relativePath = typeof entry.fullPath === 'string' && entry.fullPath.length
                            ? entry.fullPath
                            : file.webkitRelativePath || file.name;
                        collected.push(setFileRelativePath(file, relativePath));
                    } catch (error) {
                        console.warn('Не вдалося прочитати файл з папки', error);
                    }
                    return;
                }

                if (entry.isDirectory) {
                    const reader = entry.createReader();
                    while (true) {
                        const batch = await new Promise((resolve, reject) => reader.readEntries(resolve, reject));
                        if (!batch.length) {
                            break;
                        }
                        for (const subEntry of batch) {
                            await processEntry(subEntry);
                        }
                    }
                }
            };

            for (const item of Array.from(items)) {
                if (!item || item.kind !== 'file') {
                    continue;
                }

                try {
                    const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                    if (entry) {
                        await processEntry(entry);
                    } else {
                        const file = item.getAsFile();
                        if (file) {
                            collected.push(setFileRelativePath(file, file.webkitRelativePath || file.name));
                        }
                    }
                } catch (error) {
                    console.warn('Не вдалося обробити елемент передачі файлів', error);
                }
            }

            return collected;
        }

        function getFileKey(file) {
            if (!file) {
                return '';
            }

            const relativePath = getFileRelativePath(file) || file.name || '';
            const lastModified = typeof file.lastModified === 'number' ? file.lastModified : 0;
            const size = typeof file.size === 'number' ? file.size : 0;
            return `${relativePath}__${lastModified}__${size}`;
        }

        function readFileAsDataURL(file, onProgress) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    if (typeof onProgress === 'function') {
                        try {
                            const size = Number(file?.size) || 0;
                            onProgress(size, size);
                        } catch (error) {
                            console.warn('Помилка обробки прогресу файлу', error);
                        }
                    }
                    resolve(reader.result);
                };
                reader.onerror = () => reject(reader.error || new Error('Не вдалося прочитати файл.'));
                if (typeof onProgress === 'function') {
                    reader.onprogress = event => {
                        if (event.lengthComputable) {
                            try {
                                onProgress(event.loaded, event.total || Number(file?.size) || 0);
                            } catch (error) {
                                console.warn('Помилка обробки прогресу файлу', error);
                            }
                        }
                    };
                }
                reader.readAsDataURL(file);
            });
        }

        function setupSearch() {
            const wrapper = document.getElementById('globalSearchWrapper');
            const input = document.getElementById('globalSearch');
            const results = document.getElementById('searchResults');

            input.addEventListener('input', event => {
                const value = event.target.value;
                clearTimeout(searchTimer);
                searchTimer = setTimeout(() => handleGlobalSearch(value), 180);
            });

            document.addEventListener('click', event => {
                if (!wrapper.contains(event.target)) {
                    hideSearchResults();
                }
            });
        }

        function setupFilters() {
            document.getElementById('pipelineOwnerFilter').addEventListener('change', event => {
                pipelineFilterOwner = event.target.value;
                renderPipeline();
            });

            document.getElementById('contactSearch').addEventListener('input', event => {
                renderContacts(event.target.value);
            });

            document.getElementById('contactStatusFilter').addEventListener('change', event => {
                contactStatusFilter = event.target.value;
                renderContacts(document.getElementById('contactSearch').value);
            });

            const contactTagInput = document.getElementById('contactTagFilter');
            if (contactTagInput) {
                contactTagInput.addEventListener('input', event => {
                    contactTagFilter = event.target.value
                        .split(',')
                        .map(tag => tag.trim().toLowerCase())
                        .filter(Boolean);
                    renderContacts(document.getElementById('contactSearch').value);
                });
            }

            const projectStageSelect = document.getElementById('projectStageFilter');
            if (projectStageSelect) {
                projectStageSelect.addEventListener('change', event => {
                    projectStageFilter = event.target.value;
                    renderProjects(projectSearchTerm);
                });
            }

            const projectSearchInput = document.getElementById('projectSearch');
            if (projectSearchInput) {
                projectSearchInput.addEventListener('input', event => {
                    renderProjects(event.target.value);
                });
            }

            const projectProbabilityRange = document.getElementById('projectProbabilityRange');
            const probabilityLabel = document.getElementById('projectProbabilityValue');
            if (projectProbabilityRange) {
                projectProbabilityRange.addEventListener('input', event => {
                    projectMinProbability = Number(event.target.value) || 0;
                    if (probabilityLabel) {
                        probabilityLabel.textContent = `${projectMinProbability}%+`;
                    }
                    renderProjects(projectSearchTerm);
                });
            }

            const taskSearchInput = document.getElementById('taskSearchInput');
            if (taskSearchInput) {
                taskSearchInput.addEventListener('input', event => {
                    taskFilters.search = event.target.value;
                    renderTasks();
                });
            }

            const taskOwnerSelect = document.getElementById('taskOwnerFilter');
            if (taskOwnerSelect) {
                taskOwnerSelect.addEventListener('change', event => {
                    taskFilters.owner = event.target.value;
                    renderTasks();
                });
            }

            const taskPrioritySelect = document.getElementById('taskPriorityFilter');
            if (taskPrioritySelect) {
                taskPrioritySelect.addEventListener('change', event => {
                    taskFilters.priority = event.target.value;
                    renderTasks();
                });
            }

            const taskDueSelect = document.getElementById('taskDueFilter');
            if (taskDueSelect) {
                taskDueSelect.addEventListener('change', event => {
                    taskFilters.due = event.target.value;
                    renderTasks();
                });
            }

            const resetTaskFiltersBtn = document.getElementById('resetTaskFilters');
            if (resetTaskFiltersBtn) {
                resetTaskFiltersBtn.addEventListener('click', () => {
                    taskFilters = { ...TASK_FILTER_DEFAULTS };
                    renderTasks();
                });
            }

            if (probabilityLabel) {
                probabilityLabel.textContent = `${projectMinProbability}%+`;
            }
        }
        function setupFileLibrary() {
            const connectBtn = document.getElementById('connectFolderBtn');
            const fallbackInput = document.getElementById('folderInput');
            const searchInput = document.getElementById('fileSearchInput');
            const select = document.getElementById('folderSnapshotsSelect');

            if (connectBtn) {
                connectBtn.addEventListener('click', () => handleFolderConnect());
            }

            if (fallbackInput) {
                fallbackInput.addEventListener('change', handleFolderInputChange);
            }

            if (searchInput) {
                searchInput.value = fileSearchTerm;
                searchInput.addEventListener('input', event => {
                    fileSearchTerm = event.target.value;
                    renderFileExplorer(fileSearchTerm);
                });
            }

            if (select) {
                select.addEventListener('change', event => {
                    activeFileSnapshotId = event.target.value || null;
                    renderFileExplorer(fileSearchTerm);
                });
            }

            updateFileSnapshotsSelect();
            renderFileExplorer(fileSearchTerm);
            setupFileSources();
        }

        function setupFileSources() {
            const addCloudBtn = document.getElementById('addCloudSourceBtn');

            if (addCloudBtn && !addCloudBtn.dataset.bound) {
                addCloudBtn.addEventListener('click', () => {
                    const name = prompt('Назва каталогу (наприклад, Google Drive / Команда маркетингу)');
                    if (!name || !name.trim()) {
                        return;
                    }

                    const path = prompt('Вкажіть шлях або посилання на каталог (необов\'язково)') || '';
                    const provider = name.includes('/') ? name.split('/')[0].trim() : '';
                    const newSource = normalizeFileSource({
                        id: generateId('source'),
                        name: name.trim(),
                        type: 'cloud',
                        provider,
                        path: path.trim(),
                        status: 'offline',
                        connected: false,
                        autoSync: true,
                        totalFiles: 0,
                        totalFolders: 0,
                        totalSize: 0,
                        lastSynced: null,
                        snapshotId: null
                    });

                    if (!Array.isArray(crmData.fileSources)) {
                        crmData.fileSources = [];
                    }

                    crmData.fileSources = [newSource, ...crmData.fileSources];
                    saveData();
                    renderFileSources();
                });
                addCloudBtn.dataset.bound = 'true';
            }

            renderFileSources();
        }

        function setupRoleManagement() {
            const form = document.getElementById('customRoleForm');
            if (form && !form.dataset.bound) {
                form.addEventListener('submit', handleCustomRoleSubmit);
                form.dataset.bound = 'true';
            }

            updateCustomRoleBaseOptions();
            updateCurrentUserBadge();
        }

        function updateFileScanStatus(message) {
            const status = document.getElementById('fileScanStatus');
            if (status) {
                status.textContent = message || '';
            }
        }

        function triggerFolderFallback(sourceId = null) {
            pendingFileSourceId = sourceId;
            const fallbackInput = document.getElementById('folderInput');
            if (fallbackInput) {
                fallbackInput.click();
            }
        }

        async function handleFolderConnect(sourceId = null) {
            if (isScanningFolder) {
                return;
            }

            const source = sourceId ? getFileSourceById(sourceId) : null;
            const previousStatus = source ? source.status : null;
            const previousConnection = source ? source.connected : null;
            const previousActiveSource = activeFileSourceId;
            let snapshotStored = false;

            if (typeof window.showDirectoryPicker !== 'function') {
                triggerFolderFallback(sourceId);
                return;
            }

            const connectBtn = document.getElementById('connectFolderBtn');

            try {
                isScanningFolder = true;
                pendingFileSourceId = sourceId;
                if (source) {
                    source.status = 'syncing';
                    source.connected = true;
                    activeFileSourceId = source.id;
                    renderFileSources();
                }
                if (connectBtn) {
                    connectBtn.disabled = true;
                }
                updateFileScanStatus('Скануємо папку...');
                const snapshot = await scanDirectoryWithPicker();
                if (snapshot) {
                    snapshotStored = true;
                    storeFolderSnapshot(snapshot, sourceId);
                }
            } catch (error) {
                if (error?.name !== 'AbortError') {
                    console.error('Не вдалося прочитати вміст папки', error);
                    alert('Не вдалося прочитати вміст папки. Переконайтесь, що надали доступ, або спробуйте інший спосіб.');
                }
            } finally {
                isScanningFolder = false;
                pendingFileSourceId = null;
                if (connectBtn) {
                    connectBtn.disabled = false;
                }
                updateFileScanStatus('');
                renderFileExplorer(fileSearchTerm);
                if (source && !snapshotStored) {
                    source.status = previousStatus || (previousConnection ? 'online' : 'offline');
                    source.connected = Boolean(previousConnection);
                    activeFileSourceId = previousActiveSource;
                    renderFileSources();
                    saveData();
                }
            }
        }

        function handleFolderInputChange(event) {
            const { files } = event.target;
            if (!files || !files.length) {
                return;
            }

            const sourceId = pendingFileSourceId;
            const source = sourceId ? getFileSourceById(sourceId) : null;
            const previousStatus = source ? source.status : null;
            const previousConnection = source ? source.connected : null;
            const previousActiveSource = activeFileSourceId;
            let snapshotStored = false;
            try {
                isScanningFolder = true;
                updateFileScanStatus('Опрацьовуємо вибрані файли...');
                if (source) {
                    source.status = 'syncing';
                    source.connected = true;
                    activeFileSourceId = source.id;
                    renderFileSources();
                }
                const snapshot = buildSnapshotFromFileList(files);
                if (snapshot) {
                    snapshotStored = true;
                    storeFolderSnapshot(snapshot, sourceId);
                } else {
                    alert('Не вдалося побудувати структуру цієї папки. Спробуйте інший каталог.');
                }
            } catch (error) {
                console.error('Не вдалося обробити файли папки', error);
                alert('Не вдалося обробити вибрані файли. Будь ласка, спробуйте ще раз.');
            } finally {
                isScanningFolder = false;
                pendingFileSourceId = null;
                updateFileScanStatus('');
                event.target.value = '';
                renderFileExplorer(fileSearchTerm);
                if (source && !snapshotStored) {
                    source.status = previousStatus || (previousConnection ? 'online' : 'offline');
                    source.connected = Boolean(previousConnection);
                    activeFileSourceId = previousActiveSource;
                    renderFileSources();
                    saveData();
                }
            }
        }

        async function scanDirectoryWithPicker() {
            if (typeof window.showDirectoryPicker !== 'function') {
                return null;
            }

            const directoryHandle = await window.showDirectoryPicker();
            if (!directoryHandle) {
                return null;
            }

            const tree = await buildTreeFromDirectoryHandle(directoryHandle);
            if (!tree) {
                return null;
            }

            const snapshot = finalizeSnapshot(tree, 'picker', {
                id: generateId('folder'),
                rootName: directoryHandle.name || tree.name || 'Папка',
                scannedAt: new Date().toISOString(),
                source: 'picker'
            });

            snapshot.rootName = directoryHandle.name || snapshot.rootName;
            return snapshot;
        }

        async function buildTreeFromDirectoryHandle(directoryHandle, parentPath = '') {
            if (!directoryHandle) {
                return null;
            }

            const rootName = directoryHandle.name || 'Папка';
            const nodePath = joinPath(parentPath, rootName);
            const node = createDirectoryNode(rootName, nodePath);

            for await (const entry of directoryHandle.values()) {
                if (!entry) {
                    continue;
                }

                if (entry.kind === 'directory') {
                    const childNode = await buildTreeFromDirectoryHandle(entry, node.path);
                    if (childNode) {
                        node.children.push(childNode);
                    }
                    continue;
                }

                if (entry.kind === 'file') {
                    try {
                        const file = await entry.getFile();
                        node.children.push(createFileNode(entry.name, joinPath(node.path, entry.name), file.size, file.type, file.lastModified));
                    } catch (error) {
                        console.warn('Не вдалося прочитати файл з папки', error);
                    }
                }
            }

            sortDirectoryChildren(node);
            return node;
        }

        function buildSnapshotFromFileList(fileList) {
            const tree = buildTreeFromFileHandles(fileList);
            if (!tree) {
                return null;
            }
            return finalizeSnapshot(tree, 'upload');
        }

        function buildTreeFromFileHandles(fileList) {
            const files = Array.from(fileList || []);
            if (!files.length) {
                return null;
            }

            const normalized = files
                .map(file => {
                    const relativePath = (file.webkitRelativePath || file._relativePath || file.name || '')
                        .replace(/^[\/]+/, '')
                        .replace(/\\/g, '/');
                    return { file, relativePath };
                })
                .filter(item => item.relativePath);

            if (!normalized.length) {
                return null;
            }

            const rootName = normalized[0].relativePath.split('/')[0] || 'Папка';
            const root = createDirectoryNode(rootName, rootName);

            normalized.forEach(({ file, relativePath }) => {
                const segments = relativePath.split('/').filter(Boolean);
                if (!segments.length) {
                    return;
                }

                if (segments[0] === root.name) {
                    segments.shift();
                }

                const fileName = segments.pop() || relativePath;
                let current = root;
                segments.forEach(segment => {
                    current = ensureDirectoryChild(current, segment);
                });

                const filePath = joinPath(current.path, fileName);
                current.children.push(createFileNode(fileName, filePath, file.size, file.type, file.lastModified));
            });

            sortDirectoryChildren(root);
            return root;
        }

        function joinPath(parentPath, segment) {
            const base = (parentPath || '').replace(/\\/g, '/');
            const addition = (segment || '').replace(/\\/g, '/');
            const cleanBase = base.replace(/\/+$/, '');
            const cleanAddition = addition.replace(/^\/+/, '');
            if (!cleanBase) {
                return cleanAddition;
            }
            if (!cleanAddition) {
                return cleanBase;
            }
            return `${cleanBase}/${cleanAddition}`;
        }

        function createDirectoryNode(name, path) {
            const safeName = name || 'Папка';
            const safePath = (path || safeName).toString().replace(/\\/g, '/');
            return {
                type: 'directory',
                name: safeName,
                path: safePath,
                children: []
            };
        }

        function createFileNode(name, path, size = 0, mimeType = '', lastModified = 0) {
            return {
                type: 'file',
                name: name || 'Файл',
                path: (path || '').toString().replace(/\\/g, '/'),
                size: Number(size) || 0,
                mimeType: mimeType || '',
                lastModified: Number(lastModified) || 0
            };
        }

        function ensureDirectoryChild(parent, name) {
            const safeName = name || 'Папка';
            if (!parent || parent.type !== 'directory') {
                return createDirectoryNode(safeName, safeName);
            }

            if (!Array.isArray(parent.children)) {
                parent.children = [];
            }

            let child = parent.children.find(item => item.type === 'directory' && item.name === safeName);
            if (!child) {
                child = createDirectoryNode(safeName, joinPath(parent.path, safeName));
                parent.children.push(child);
            }

            return child;
        }

        function sortDirectoryChildren(node) {
            if (!node || node.type !== 'directory' || !Array.isArray(node.children)) {
                return;
            }

            node.children.sort((a, b) => {
                if (a.type === b.type) {
                    return a.name.localeCompare(b.name, 'uk', { sensitivity: 'base' });
                }
                return a.type === 'directory' ? -1 : 1;
            });

            node.children.forEach(child => {
                if (child.type === 'directory') {
                    sortDirectoryChildren(child);
                }
            });
        }
        function computeNodeStats(node) {
            if (!node) {
                return { files: 0, folders: 0, size: 0, lastModified: 0 };
            }

            if (node.type === 'file') {
                const size = Number(node.size) || 0;
                const lastModified = Number(node.lastModified) || 0;
                const stats = { files: 1, folders: 0, size, lastModified };
                node.stats = stats;
                return stats;
            }

            let files = 0;
            let folders = 1;
            let size = 0;
            let lastModified = 0;

            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    const childStats = computeNodeStats(child);
                    files += childStats.files;
                    folders += childStats.folders;
                    size += childStats.size;
                    if (childStats.lastModified && childStats.lastModified > lastModified) {
                        lastModified = childStats.lastModified;
                    }
                });
            }

            const stats = { files, folders, size, lastModified };
            node.stats = stats;
            return stats;
        }

        function finalizeSnapshot(rootNode, source = 'picker', base = null) {
            if (!rootNode) {
                return null;
            }

            sortDirectoryChildren(rootNode);
            const stats = computeNodeStats(rootNode);

            return {
                id: base?.id || generateId('folder'),
                rootName: (base?.rootName || rootNode.name || 'Папка').toString(),
                scannedAt: base?.scannedAt || new Date().toISOString(),
                source: base?.source || source,
                tree: rootNode,
                totals: {
                    files: stats.files,
                    folders: Math.max(stats.folders - 1, 0),
                    size: stats.size
                }
            };
        }

        function storeFolderSnapshot(snapshot, sourceId = null) {
            if (!snapshot) {
                return;
            }

            if (!Array.isArray(crmData.fileLibrary)) {
                crmData.fileLibrary = [];
            }

            const filtered = crmData.fileLibrary.filter(item => item.id !== snapshot.id && item.rootName !== snapshot.rootName);
            crmData.fileLibrary = [snapshot, ...filtered].slice(0, FILE_LIBRARY_LIMIT);
            activeFileSnapshotId = snapshot.id;

            const targetSourceId = sourceId
                || (Array.isArray(crmData.fileSources)
                    ? (crmData.fileSources.find(item => item.snapshotId === snapshot.id)?.id || null)
                    : null);

            if (targetSourceId) {
                attachSnapshotToSource(snapshot, targetSourceId);
            } else if (Array.isArray(crmData.fileSources)) {
                const matchedSource = crmData.fileSources.find(item => {
                    if (item.snapshotId) {
                        return false;
                    }
                    if (item.type !== 'local') {
                        return false;
                    }
                    if (!item.path || !snapshot.rootName) {
                        return false;
                    }
                    return item.path.replace(/\\/g, '/').toLowerCase() === snapshot.rootName.replace(/\\/g, '/').toLowerCase();
                });
                if (matchedSource) {
                    attachSnapshotToSource(snapshot, matchedSource.id);
                }
            }

            pendingFileSourceId = null;
            saveData();
            updateFileSnapshotsSelect();
            renderFileExplorer(fileSearchTerm);
            renderFileSources();
        }

        function updateFileSnapshotsSelect() {
            const select = document.getElementById('folderSnapshotsSelect');
            if (!select) {
                return;
            }

            const snapshots = Array.isArray(crmData.fileLibrary) ? crmData.fileLibrary : [];
            if (!snapshots.length) {
                select.innerHTML = '<option value="">Папки ще не підключені</option>';
                select.value = '';
                select.disabled = true;
                return;
            }

            select.disabled = false;
            if (!activeFileSnapshotId) {
                activeFileSnapshotId = snapshots[0].id;
            }

            const options = snapshots.map(snapshot => {
                const dateLabel = snapshot.scannedAt
                    ? `${formatDate(snapshot.scannedAt, { day: '2-digit', month: 'short', year: 'numeric' })} ${formatTime(snapshot.scannedAt)}`
                    : '';
                const label = `${snapshot.rootName}${dateLabel ? ` • ${dateLabel}` : ''}`;
                const selected = snapshot.id === activeFileSnapshotId ? ' selected' : '';
                return `<option value="${snapshot.id}"${selected}>${escapeHtml(label)}</option>`;
            });

            select.innerHTML = options.join('');
            select.value = activeFileSnapshotId || '';
        }

        function renderFileExplorer(searchTerm = '') {
            const treeBody = document.getElementById('fileTreeBody');
            const summary = document.getElementById('fileSummary');
            const searchInput = document.getElementById('fileSearchInput');

            if (!treeBody || !summary) {
                return;
            }

            fileSearchTerm = searchTerm || '';
            if (searchInput && searchInput.value !== fileSearchTerm) {
                searchInput.value = fileSearchTerm;
            }

            updateFileScanStatus(isScanningFolder ? 'Скануємо папку...' : '');

            const snapshots = Array.isArray(crmData.fileLibrary) ? crmData.fileLibrary : [];
            if (!snapshots.length) {
                summary.innerHTML = '<div class="empty-state" style="padding: 24px;">Підключіть папку, щоб побачити її структуру. Дані зберігаються лише локально.</div>';
                treeBody.innerHTML = '<div class="empty-state" style="padding: 32px;">Жодної папки ще не підключено.</div>';
                const select = document.getElementById('folderSnapshotsSelect');
                if (select) {
                    select.innerHTML = '<option value="">Папки ще не підключені</option>';
                    select.disabled = true;
                }
                renderFileProcesses(null);
                return;
            }

            const select = document.getElementById('folderSnapshotsSelect');
            if (select) {
                select.disabled = false;
                if (!activeFileSnapshotId) {
                    activeFileSnapshotId = snapshots[0].id;
                }
                if (select.value !== activeFileSnapshotId) {
                    select.value = activeFileSnapshotId;
                }
            }

            const snapshot = snapshots.find(item => item.id === activeFileSnapshotId) || snapshots[0];
            activeFileSnapshotId = snapshot?.id || null;
            const previousSourceId = activeFileSourceId;
            const linkedSource = getFileSourceBySnapshotId(snapshot?.id);
            activeFileSourceId = linkedSource ? linkedSource.id : null;
            updateFileSummary(snapshot);
            renderFileProcesses(snapshot || null);

            if (!snapshot) {
                treeBody.innerHTML = '<div class="empty-state" style="padding: 32px;">Не вдалося завантажити вибране сканування.</div>';
                return;
            }

            const entries = flattenFileTree(snapshot.tree);
            const visibleEntries = getVisibleFileEntries(entries, fileSearchTerm);

            if (!visibleEntries.length) {
                treeBody.innerHTML = '<div class="empty-state" style="padding: 32px;">За вашим запитом нічого не знайдено.</div>';
                return;
            }

            const rootPrefix = snapshot.rootName ? `${snapshot.rootName}/` : '';
            treeBody.innerHTML = visibleEntries.map(entry => {
                const icon = entry.type === 'directory'
                    ? 'fa-solid fa-folder'
                    : `fa-solid ${getAttachmentIcon(entry.mimeType || '')}`;
                const nameHtml = highlightMatch(entry.name, fileSearchTerm);
                const relativePath = entry.path.startsWith(rootPrefix)
                    ? entry.path.slice(rootPrefix.length)
                    : (entry.path === snapshot.rootName ? '' : entry.path);
                const directoryMeta = entry.type === 'directory'
                    ? `${entry.stats.files} файлів • ${Math.max(entry.stats.folders - 1, 0)} папок`
                    : '';
                const fileMeta = entry.type === 'file' && relativePath ? relativePath : '';
                const metaText = directoryMeta || fileMeta;
                const metaHtml = metaText ? `<div class="file-meta">${escapeHtml(metaText)}</div>` : '';
                const sizeLabel = formatBytes(entry.size);
                const modifiedLabel = entry.lastModified
                    ? `${formatDate(entry.lastModified, { day: '2-digit', month: 'short', year: 'numeric' })} ${formatTime(entry.lastModified)}`
                    : '—';
                return `
                    <div class="file-entry">
                        <div class="file-name" data-type="${entry.type}" style="--level: ${entry.level}">
                            <i class="${icon}"></i>
                            <div>
                                <div>${nameHtml}</div>
                                ${metaHtml}
                            </div>
                        </div>
                        <div>${sizeLabel}</div>
                        <div>${modifiedLabel}</div>
                    </div>
                `;
            }).join('');

            if (previousSourceId !== activeFileSourceId) {
                renderFileSources();
            }
        }

        function renderFileSources() {
            const grid = document.getElementById('fileSourceGrid');
            if (!grid) {
                return;
            }

            const sources = Array.isArray(crmData.fileSources) ? crmData.fileSources.filter(Boolean) : [];
            if (!sources.length) {
                grid.innerHTML = '<div class="empty-state" style="padding: 20px;">Додайте локальну папку або підключіть хмарний каталог, щоб швидко отримати доступ до матеріалів.</div>';
                return;
            }

            grid.innerHTML = sources.map(createFileSourceCard).join('');

            grid.querySelectorAll('[data-source-connect]').forEach(button => {
                button.addEventListener('click', () => handleFileSourceConnect(button.dataset.sourceConnect));
            });

            grid.querySelectorAll('[data-source-open]').forEach(button => {
                button.addEventListener('click', () => handleFileSourceOpen(button.dataset.sourceOpen));
            });

            grid.querySelectorAll('[data-source-sync]').forEach(button => {
                button.addEventListener('click', () => handleFileSourceSync(button.dataset.sourceSync));
            });
        }

        function createFileSourceCard(source) {
            const status = getFileSourceStatus(source);
            const statusLabel = getFileSourceStatusLabel(status);
            const icon = source?.type === 'cloud' ? 'fa-cloud' : 'fa-folder-tree';
            const provider = source?.type === 'cloud'
                ? (source?.provider && source.provider.trim().length ? source.provider : 'Хмарне сховище')
                : 'Локальна папка';
            const pathLabel = source?.path && source.path.trim().length
                ? escapeHtml(source.path)
                : escapeHtml(source?.type === 'cloud' ? 'Хмарний каталог' : 'Локальна папка');
            const filesValue = formatIntegerDisplay(source?.totalFiles);
            const foldersValue = formatIntegerDisplay(source?.totalFolders);
            const sizeValue = Number(source?.totalSize) > 0 ? formatBytes(source.totalSize) : '—';
            const updatedText = source?.lastSynced
                ? `Оновлено ${formatDate(source.lastSynced, { day: '2-digit', month: 'short', year: 'numeric' })} ${formatTime(source.lastSynced)}`
                : (source?.connected ? 'Очікує синхронізацію' : 'Ще не підключено');
            const autoSyncText = source?.autoSync ? 'Автосинхронізація увімкнена' : 'Ручне оновлення';
            const hasSnapshot = Boolean(source?.snapshotId)
                && Array.isArray(crmData.fileLibrary)
                && crmData.fileLibrary.some(snapshot => snapshot.id === source.snapshotId);
            const isActive = Boolean(activeFileSourceId) && source?.id === activeFileSourceId;

            let actionHtml = '';
            if (!source?.connected || (source?.type === 'local' && !hasSnapshot)) {
                actionHtml = `<button type="button" class="btn btn-small-muted" data-source-connect="${source.id}">Підключити</button>`;
            } else if (hasSnapshot) {
                actionHtml = `<button type="button" class="btn btn-small-muted" data-source-open="${source.id}">Відкрити</button>`;
            } else if (source?.type === 'cloud') {
                actionHtml = `<button type="button" class="btn btn-small-muted" data-source-sync="${source.id}">Синхронізувати</button>`;
            }

            return `
                <article class="file-source-card${isActive ? ' active' : ''}" data-source-id="${source.id}">
                    <header class="file-source-header">
                        <div class="file-source-icon">
                            <i class="fa-solid ${icon}"></i>
                        </div>
                        <div class="file-source-title">
                            <strong>${escapeHtml(source?.name || 'Джерело файлів')}</strong>
                            <span class="metric-sub">${escapeHtml(provider)}</span>
                        </div>
                        <span class="file-source-status status-${status}">${statusLabel}</span>
                    </header>
                    <div class="file-source-body">
                        <div class="file-source-path"><i class="fa-solid fa-location-dot"></i> ${pathLabel}</div>
                        <div class="file-source-stats">
                            <div><strong>${filesValue}</strong><span>файлів</span></div>
                            <div><strong>${foldersValue}</strong><span>папок</span></div>
                            <div><strong>${sizeValue}</strong><span>обсяг</span></div>
                        </div>
                        <div class="file-source-updated">${escapeHtml(updatedText)}</div>
                        <div class="metric-sub">${autoSyncText}${source?.favorite ? ' • В обраних' : ''}</div>
                    </div>
                    ${actionHtml ? `<footer class="file-source-footer">${actionHtml}</footer>` : ''}
                </article>
            `;
        }

        function handleFileSourceConnect(sourceId) {
            if (!sourceId) {
                return;
            }

            const source = getFileSourceById(sourceId);
            if (!source) {
                return;
            }

            if (source.type === 'cloud') {
                source.connected = true;
                source.status = 'online';
                source.lastSynced = new Date().toISOString();
                activeFileSourceId = source.id;
                saveData();
                renderFileSources();
                renderFileExplorer(fileSearchTerm);
                return;
            }

            handleFolderConnect(sourceId);
        }

        function handleFileSourceOpen(sourceId) {
            if (!sourceId) {
                return;
            }

            const source = getFileSourceById(sourceId);
            if (!source || !source.snapshotId) {
                return;
            }

            const snapshotExists = Array.isArray(crmData.fileLibrary)
                && crmData.fileLibrary.some(snapshot => snapshot.id === source.snapshotId);

            if (!snapshotExists) {
                alert('Збережений знімок каталогу недоступний. Підключіть джерело повторно.');
                source.status = 'offline';
                source.connected = false;
                source.snapshotId = null;
                saveData();
                renderFileSources();
                return;
            }

            activeFileSourceId = source.id;
            activeFileSnapshotId = source.snapshotId;
            renderFileExplorer(fileSearchTerm);
            updateFileSnapshotsSelect();
        }

        function handleFileSourceSync(sourceId) {
            if (!sourceId) {
                return;
            }

            const source = getFileSourceById(sourceId);
            if (!source) {
                return;
            }

            source.status = 'syncing';
            renderFileSources();
            renderFileExplorer(fileSearchTerm);

            setTimeout(() => {
                source.status = 'online';
                source.connected = true;
                source.lastSynced = new Date().toISOString();
                saveData();
                renderFileSources();
                renderFileExplorer(fileSearchTerm);
            }, 700);
        }

        function attachSnapshotToSource(snapshot, sourceId) {
            if (!snapshot || !sourceId) {
                return;
            }

            const source = getFileSourceById(sourceId);
            if (!source) {
                return;
            }

            source.snapshotId = snapshot.id;
            source.connected = true;
            source.status = 'online';
            source.totalFiles = snapshot.totals?.files ?? 0;
            source.totalFolders = snapshot.totals?.folders ?? 0;
            source.totalSize = snapshot.totals?.size ?? 0;
            source.lastSynced = snapshot.scannedAt || new Date().toISOString();
            if (!source.path) {
                source.path = snapshot.rootName;
            }
            activeFileSourceId = source.id;
        }

        function getFileSourceById(sourceId) {
            if (!sourceId || !Array.isArray(crmData.fileSources)) {
                return null;
            }
            return crmData.fileSources.find(source => source.id === sourceId) || null;
        }

        function getFileSourceBySnapshotId(snapshotId) {
            if (!snapshotId || !Array.isArray(crmData.fileSources)) {
                return null;
            }
            return crmData.fileSources.find(source => source.snapshotId === snapshotId) || null;
        }

        function getFileSourceStatus(source) {
            if (!source || typeof source !== 'object') {
                return 'offline';
            }

            const status = typeof source.status === 'string' ? source.status.toLowerCase() : '';
            if (status === 'online' || status === 'offline' || status === 'syncing') {
                return status;
            }

            return source.connected ? 'online' : 'offline';
        }

        function getFileSourceStatusLabel(status) {
            switch (status) {
                case 'online':
                    return 'Онлайн';
                case 'syncing':
                    return 'Синхронізація';
                case 'offline':
                default:
                    return 'Не підключено';
            }
        }

        function flattenFileTree(node, level = 0, acc = []) {
            if (!node) {
                return acc;
            }

            acc.push({
                type: node.type,
                name: node.name,
                path: node.path,
                level,
                size: node.type === 'file' ? Number(node.size) || 0 : Number(node.stats?.size) || 0,
                lastModified: node.type === 'file'
                    ? Number(node.lastModified) || 0
                    : Number(node.stats?.lastModified) || 0,
                mimeType: node.mimeType || '',
                stats: node.stats || { files: 0, folders: 0, size: 0, lastModified: 0 }
            });

            if (node.type === 'directory' && Array.isArray(node.children)) {
                node.children.forEach(child => flattenFileTree(child, level + 1, acc));
            }

            return acc;
        }

        function getVisibleFileEntries(entries, query) {
            if (!Array.isArray(entries) || !entries.length) {
                return [];
            }

            const trimmed = (query || '').trim().toLowerCase();
            if (!trimmed) {
                return entries;
            }

            const matched = entries.filter(entry => entry.path.toLowerCase().includes(trimmed) || entry.name.toLowerCase().includes(trimmed));
            if (!matched.length) {
                return [];
            }

            const visiblePaths = new Set();
            matched.forEach(item => {
                const segments = item.path.split('/');
                let current = '';
                segments.forEach((segment, index) => {
                    if (!segment) {
                        return;
                    }
                    current = index === 0 ? segment : `${current}/${segment}`;
                    visiblePaths.add(current);
                });
            });

            return entries.filter(entry => visiblePaths.has(entry.path));
        }

        function getFileExtension(name = '') {
            if (typeof name !== 'string') {
                return '';
            }

            const lastDot = name.lastIndexOf('.');
            if (lastDot === -1) {
                return '';
            }

            return name.slice(lastDot + 1).toLowerCase();
        }

        function categorizeFileEntry(entry) {
            if (!entry || entry.type !== 'file') {
                return 'other';
            }

            const extension = getFileExtension(entry.name || entry.path || '');
            if (!extension) {
                return 'other';
            }

            if (['doc', 'docx', 'pdf', 'txt', 'rtf'].includes(extension)) {
                return 'documents';
            }
            if (['xls', 'xlsx', 'csv', 'ods'].includes(extension)) {
                return 'spreadsheets';
            }
            if (['ppt', 'pptx', 'key'].includes(extension)) {
                return 'presentations';
            }
            if (['ai', 'psd', 'fig', 'sketch', 'xd'].includes(extension)) {
                return 'design';
            }
            if (['zip', 'rar', '7z', 'tar', 'gz'].includes(extension)) {
                return 'archives';
            }
            if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'mp4', 'mov', 'avi', 'mkv', 'mp3', 'wav', 'heic'].includes(extension)) {
                return 'media';
            }

            return 'other';
        }

        function highlightMatch(text, query) {
            const safe = escapeHtml(text || '');
            if (!query) {
                return safe;
            }

            try {
                const regex = new RegExp(escapeRegExp(query), 'ig');
                return safe.replace(regex, match => `<mark>${match}</mark>`);
            } catch (error) {
                return safe;
            }
        }

        function escapeRegExp(value) {
            return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function updateFileSummary(snapshot) {
            const container = document.getElementById('fileSummary');
            if (!container) {
                return;
            }

            if (!snapshot) {
                container.innerHTML = '';
                return;
            }

            const updatedLabel = snapshot.scannedAt
                ? `${formatDate(snapshot.scannedAt, { day: '2-digit', month: 'short', year: 'numeric' })} ${formatTime(snapshot.scannedAt)}`
                : '—';
            const foldersTotal = snapshot.totals?.folders ?? 0;
            const filesTotal = snapshot.totals?.files ?? 0;

            container.innerHTML = `
                <div class="file-summary-card">
                    <span>Папка</span>
                    <strong>${escapeHtml(snapshot.rootName)}</strong>
                    <small>Оновлено ${escapeHtml(updatedLabel)}</small>
                </div>
                <div class="file-summary-card">
                    <span>Файли</span>
                    <strong>${filesTotal}</strong>
                    <small>${foldersTotal} папок усередині</small>
                </div>
                <div class="file-summary-card">
                    <span>Загальний розмір</span>
                    <strong>${formatBytes(snapshot.totals?.size || 0)}</strong>
                    <small>Дані зберігаються локально</small>
                </div>
            `;
        }

        function renderFileProcesses(snapshot) {
            const processGrid = document.getElementById('fileProcessGrid');
            const statusList = document.getElementById('fileProcessStatusList');
            const featureList = document.getElementById('fileFeatureUsage');
            const activityTimeline = document.getElementById('fileActivityTimeline');

            if (!processGrid && !statusList && !featureList && !activityTimeline) {
                return;
            }

            const sources = Array.isArray(crmData.fileSources) ? crmData.fileSources.filter(Boolean) : [];
            const totalSources = sources.length;
            const statusCounts = { online: 0, syncing: 0, offline: 0 };

            sources.forEach(source => {
                const status = getFileSourceStatus(source);
                if (statusCounts[status] !== undefined) {
                    statusCounts[status] += 1;
                } else {
                    statusCounts.offline += 1;
                }
            });

            const connectedCount = sources.filter(source => source.connected || getFileSourceStatus(source) !== 'offline').length;
            const autoSyncCount = sources.filter(source => source.autoSync).length;
            const favoriteCount = sources.filter(source => source.favorite).length;
            const cloudCount = sources.filter(source => source.type === 'cloud').length;
            const snapshotsCount = Array.isArray(crmData.fileLibrary) ? crmData.fileLibrary.length : 0;
            const cloudPercent = totalSources ? Math.round((cloudCount / totalSources) * 100) : 0;
            const favoritePercent = totalSources ? Math.round((favoriteCount / totalSources) * 100) : 0;

            if (processGrid) {
                const metrics = [
                    {
                        icon: 'fa-satellite-dish',
                        tone: 'success',
                        label: 'Активні підключення',
                        value: connectedCount,
                        note: totalSources
                            ? `${Math.round((connectedCount / totalSources) * 100)}% від ${totalSources} джерел`
                            : 'Джерела ще не підключено'
                    },
                    {
                        icon: 'fa-arrows-rotate',
                        tone: 'info',
                        label: 'Процеси синхронізації',
                        value: statusCounts.syncing,
                        note: statusCounts.syncing
                            ? 'Синхронізація триває'
                            : 'Немає активних процесів'
                    },
                    {
                        icon: 'fa-bolt',
                        tone: 'primary',
                        label: 'Автосинхронізація',
                        value: autoSyncCount,
                        note: totalSources
                            ? `${autoSyncCount} увімкнено`
                            : 'Підключіть джерела для автосинхронізації'
                    },
                    {
                        icon: 'fa-folder-tree',
                        tone: 'muted',
                        label: 'Збережені знімки',
                        value: snapshotsCount,
                        note: snapshot
                            ? `Поточна папка: ${snapshot.rootName || '—'}`
                            : 'Додайте знімок каталогу'
                    }
                ];

                processGrid.innerHTML = metrics.map(metric => {
                    const valueLabel = formatIntegerDisplay(metric.value);
                    const note = typeof metric.note === 'string' ? metric.note : '';
                    const toneClass = metric.tone ? ` tone-${metric.tone}` : '';
                    return `
                        <div class="file-process-card">
                            <div class="file-process-icon${toneClass}">
                                <i class="fa-solid ${metric.icon}" aria-hidden="true"></i>
                            </div>
                            <div class="file-process-value">${valueLabel}</div>
                            <div class="file-process-label">${escapeHtml(metric.label)}</div>
                            <div class="file-process-note">${escapeHtml(note)}</div>
                        </div>
                    `;
                }).join('');
            }

            if (statusList) {
                if (!totalSources) {
                    statusList.innerHTML = '<div class="empty-state">Підключіть хоча б одне джерело, щоб бачити статуси процесів.</div>';
                } else {
                    const statusItems = [
                        { key: 'online', label: 'Онлайн', icon: 'fa-circle-check', count: statusCounts.online },
                        { key: 'syncing', label: 'Синхронізація', icon: 'fa-arrows-rotate', count: statusCounts.syncing },
                        { key: 'offline', label: 'Не підключено', icon: 'fa-circle-xmark', count: statusCounts.offline }
                    ];

                    statusList.innerHTML = statusItems.map(item => {
                        const percentage = totalSources ? Math.round((item.count / totalSources) * 100) : 0;
                        const metaLabel = totalSources ? `${percentage}% від джерел` : '';
                        return `
                            <div class="file-status-item">
                                <div class="file-status-header">
                                    <span class="file-status-badge status-${item.key}">
                                        <i class="fa-solid ${item.icon}" aria-hidden="true"></i>
                                        ${escapeHtml(item.label)}
                                    </span>
                                    <strong>${formatIntegerDisplay(item.count)}</strong>
                                </div>
                                <div class="file-status-meta">${escapeHtml(metaLabel)}</div>
                                <div class="progress-track"><div class="progress-value" style="width:${percentage}%;"></div></div>
                            </div>
                        `;
                    }).join('');
                }
            }

            const fileEntries = snapshot && snapshot.tree
                ? flattenFileTree(snapshot.tree).filter(entry => entry.type === 'file')
                : [];
            const totalFiles = fileEntries.length;
            const fourteenDaysAgo = Date.now() - (14 * 24 * 60 * 60 * 1000);
            const recentUpdates = fileEntries.filter(entry => Number(entry.lastModified) >= fourteenDaysAgo && Number(entry.lastModified) > 0).length;
            const categoryCounts = fileEntries.reduce((acc, entry) => {
                const category = categorizeFileEntry(entry);
                acc[category] = (acc[category] || 0) + 1;
                return acc;
            }, {});
            const docAndPresentation = (categoryCounts.documents || 0) + (categoryCounts.presentations || 0);
            const recentPercent = totalFiles ? Math.round((recentUpdates / totalFiles) * 100) : 0;
            const documentsPercent = totalFiles ? Math.round((docAndPresentation / totalFiles) * 100) : 0;

            if (featureList) {
                if (!totalSources && !snapshot) {
                    featureList.innerHTML = '<div class="empty-state">Функціональні метрики з\'являться після підключення джерел або сканування папки.</div>';
                } else {
                    const features = [
                        {
                            key: 'cloud',
                            icon: 'fa-cloud',
                            tone: 'info',
                            label: 'Хмарні інтеграції',
                            value: cloudCount,
                            description: cloudCount
                                ? `${cloudCount} підключень до зовнішніх сервісів.`
                                : 'Додайте хмарні каталоги для команди.',
                            progress: cloudPercent
                        },
                        {
                            key: 'favorites',
                            icon: 'fa-star',
                            tone: 'warning',
                            label: 'Обрані каталоги',
                            value: favoriteCount,
                            description: favoriteCount
                                ? `${favoriteCount} джерел позначено як пріоритетні.`
                                : 'Позначте критичні каталоги зіркою.',
                            progress: favoritePercent
                        },
                        {
                            key: 'recent',
                            icon: 'fa-clock-rotate-left',
                            tone: 'primary',
                            label: 'Оновлено за 14 днів',
                            value: recentUpdates,
                            description: totalFiles
                                ? `${recentPercent}% бібліотеки змінено останнім часом.`
                                : 'Запустіть сканування, щоб відстежувати зміни.',
                            progress: recentPercent
                        },
                        {
                            key: 'documents',
                            icon: 'fa-file-lines',
                            tone: 'success',
                            label: 'Документи для продажів',
                            value: docAndPresentation,
                            description: docAndPresentation
                                ? 'Готові презентації та договори доступні в каталозі.'
                                : 'Додайте презентації та договори до бібліотеки.',
                            progress: documentsPercent
                        }
                    ];

                    featureList.innerHTML = features.map(feature => {
                        const valueLabel = formatIntegerDisplay(feature.value);
                        const toneClass = feature.tone ? ` tone-${feature.tone}` : '';
                        const progressWidth = Math.max(0, Math.min(feature.progress || 0, 100));
                        return `
                            <div class="file-feature-item">
                                <div class="file-feature-top">
                                    <div class="file-feature-icon${toneClass}">
                                        <i class="fa-solid ${feature.icon}" aria-hidden="true"></i>
                                    </div>
                                    <div class="file-feature-info">
                                        <strong>${escapeHtml(feature.label)}</strong>
                                        <p class="file-feature-meta">${escapeHtml(feature.description)}</p>
                                    </div>
                                    <span class="file-feature-value">${valueLabel}</span>
                                </div>
                                <div class="progress-track"><div class="progress-value" style="width:${progressWidth}%;"></div></div>
                            </div>
                        `;
                    }).join('');
                }
            }

            if (activityTimeline) {
                const timelineEntries = [];

                if (snapshot && snapshot.scannedAt) {
                    const filesLabel = formatIntegerDisplay(snapshot.totals?.files ?? 0);
                    const sizeLabel = formatBytes(snapshot.totals?.size || 0);
                    timelineEntries.push({
                        icon: 'fa-folder-open',
                        tone: 'primary',
                        title: `Сканування • ${snapshot.rootName || 'Каталог'}`,
                        timestamp: snapshot.scannedAt,
                        description: `${filesLabel} файлів • ${sizeLabel}`
                    });
                }

                sources.forEach(source => {
                    const status = getFileSourceStatus(source);
                    if (status === 'syncing') {
                        timelineEntries.push({
                            icon: 'fa-arrows-rotate',
                            tone: 'info',
                            title: `Синхронізація • ${source.name || 'Джерело'}`,
                            timestamp: new Date().toISOString(),
                            description: 'Процес синхронізації виконується.'
                        });
                        return;
                    }

                    if (source.lastSynced) {
                        const filesLabel = formatIntegerDisplay(source.totalFiles || 0);
                        const sizeLabel = formatBytes(source.totalSize || 0);
                        timelineEntries.push({
                            icon: 'fa-rotate',
                            tone: 'success',
                            title: `Оновлено • ${source.name || 'Джерело'}`,
                            timestamp: source.lastSynced,
                            description: `${filesLabel} файлів • ${sizeLabel}`
                        });
                    } else if (!source.connected) {
                        timelineEntries.push({
                            icon: 'fa-plug-circle-xmark',
                            tone: 'muted',
                            title: `Очікує підключення • ${source.name || 'Джерело'}`,
                            timestamp: null,
                            description: 'Підключіть джерело, щоб активувати моніторинг.'
                        });
                    }
                });

                if (!timelineEntries.length) {
                    activityTimeline.innerHTML = '<div class="empty-state">Активність з\'явиться після підключення джерел або запуску сканування.</div>';
                } else {
                    timelineEntries.sort((a, b) => {
                        const aTime = a.timestamp ? new Date(a.timestamp).getTime() : 0;
                        const bTime = b.timestamp ? new Date(b.timestamp).getTime() : 0;
                        return bTime - aTime;
                    });

                    const timelineMarkup = timelineEntries.slice(0, 6).map(entry => {
                        const toneClass = entry.tone ? ` tone-${entry.tone}` : '';
                        const parts = [];
                        if (entry.timestamp) {
                            parts.push(`${formatDate(entry.timestamp, { day: '2-digit', month: 'short', year: 'numeric' })} ${formatTime(entry.timestamp)}`);
                            const relative = formatRelativeTime(entry.timestamp);
                            if (relative) {
                                parts.push(relative);
                            }
                        }
                        const timeLabel = parts.length ? parts.join(' • ') : 'Очікує запуску';
                        return `
                            <div class="file-activity-item">
                                <div class="file-activity-icon${toneClass}">
                                    <i class="fa-solid ${entry.icon}" aria-hidden="true"></i>
                                </div>
                                <div class="file-activity-info">
                                    <strong>${escapeHtml(entry.title)}</strong>
                                    <p>${escapeHtml(entry.description)}</p>
                                    <span class="file-activity-time">${escapeHtml(timeLabel)}</span>
                                </div>
                            </div>
                        `;
                    }).join('');

                    activityTimeline.innerHTML = timelineMarkup;
                }
            }
        }

        function sanitizeFileNode(node, parentPath = '') {
            if (!node || typeof node !== 'object') {
                return null;
            }

            const nodeType = node.type === 'file' || node.type === 'directory'
                ? node.type
                : Array.isArray(node.children) ? 'directory' : 'file';

            const rawName = typeof node.name === 'string' && node.name.trim()
                ? node.name.trim()
                : (typeof node.path === 'string' && node.path.trim()
                    ? node.path.trim().split(/[\/]/).filter(Boolean).pop()
                    : nodeType === 'file' ? 'Файл' : 'Папка');

            const path = typeof node.path === 'string' && node.path.trim()
                ? node.path.trim().replace(/\\/g, '/')
                : joinPath(parentPath, rawName);

            if (nodeType === 'file') {
                return {
                    type: 'file',
                    name: rawName,
                    path,
                    size: Number(node.size) || 0,
                    lastModified: Number(node.lastModified) || 0,
                    mimeType: typeof node.mimeType === 'string'
                        ? node.mimeType
                        : typeof node.fileType === 'string'
                            ? node.fileType
                            : ''
                };
            }

            const children = Array.isArray(node.children)
                ? node.children.map(child => sanitizeFileNode(child, path)).filter(Boolean)
                : [];

            return {
                type: 'directory',
                name: rawName,
                path,
                children
            };
        }

        function normalizeFileSnapshot(snapshot) {
            if (!snapshot || typeof snapshot !== 'object') {
                return null;
            }

            const sanitizedTree = sanitizeFileNode(snapshot.tree);
            if (!sanitizedTree) {
                return null;
            }

            return finalizeSnapshot(sanitizedTree, snapshot.source || 'picker', {
                id: typeof snapshot.id === 'string' ? snapshot.id : generateId('folder'),
                rootName: typeof snapshot.rootName === 'string' ? snapshot.rootName : sanitizedTree.name,
                scannedAt: snapshot.scannedAt,
                source: snapshot.source || 'picker'
            });
        }

        function getLeadSourceLabel(source) {
            return LEAD_SOURCE_LABELS[source] || 'Інше джерело';
        }

        function getLeadQualificationLabel(qualification) {
            return LEAD_QUALIFICATION_LABELS[qualification] || 'Без кваліфікації';
        }

        function suggestLeadOwner(source) {
            const normalized = typeof source === 'string' ? source : '';
            return LEAD_ROUTING_RULES[normalized] || LEAD_ROUTING_RULES.default || TEAM_MEMBERS[0] || '';
        }

        function updateLeadOwnerSuggestion(force = false) {
            const sourceSelect = document.getElementById('leadSource');
            const ownerSelect = document.getElementById('leadOwner');
            const hint = document.getElementById('leadRoutingHint');
            if (!ownerSelect) {
                return;
            }

            const sourceValue = sourceSelect ? sourceSelect.value : '';
            const suggestedOwner = suggestLeadOwner(sourceValue);
            if ((force || !leadOwnerManuallySelected) && suggestedOwner) {
                ownerSelect.value = suggestedOwner;
            }

            if (hint) {
                if (suggestedOwner) {
                    const sourceLabel = getLeadSourceLabel(sourceValue);
                    hint.innerHTML = `Рекомендований менеджер: <strong>${escapeHtml(suggestedOwner)}</strong>${sourceLabel ? ` • ${escapeHtml(sourceLabel)}` : ''}`;
                } else {
                    hint.textContent = 'Оберіть відповідального менеджера.';
                }
            }
        }

        function updateLeadScoreIndicator(value) {
            const indicator = document.getElementById('leadScoreValue');
            if (!indicator) {
                return;
            }
            const numeric = Math.max(0, Math.min(100, Number(value) || LEAD_SCORE_DEFAULT));
            indicator.textContent = `${numeric}%`;
        }

        function startOfDay(dateInput) {
            const instance = dateInput instanceof Date ? new Date(dateInput.getTime()) : new Date(dateInput);
            if (Number.isNaN(instance.getTime())) {
                return null;
            }
            instance.setHours(0, 0, 0, 0);
            return instance;
        }

        function calculateCalendarDayDiff(targetDate, referenceDate = new Date()) {
            const target = startOfDay(targetDate);
            const reference = startOfDay(referenceDate);
            if (!target || !reference) {
                return null;
            }
            const diffMs = target.getTime() - reference.getTime();
            return Math.round(diffMs / (1000 * 60 * 60 * 24));
        }

        function formatDateForInput(dateInput) {
            const normalized = startOfDay(dateInput);
            if (!normalized) {
                return '';
            }
            const year = normalized.getFullYear();
            const month = String(normalized.getMonth() + 1).padStart(2, '0');
            const day = String(normalized.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function runLeadAutomations() {
            if (!crmData || !Array.isArray(crmData.leads) || !crmData.leads.length) {
                return;
            }

            const now = new Date();
            let hasChanges = false;

            crmData.leads.forEach(lead => {
                if (!lead || typeof lead !== 'object') {
                    return;
                }

                if (!lead.automation || typeof lead.automation !== 'object') {
                    lead.automation = normalizeLeadAutomation(lead.automation);
                    hasChanges = true;
                }

                const automation = lead.automation;

                if (!lead.owner || !lead.owner.trim()) {
                    const suggestedOwner = suggestLeadOwner(lead.source);
                    if (suggestedOwner) {
                        lead.owner = suggestedOwner;
                        addTimelineEntry(lead, `Лід автоматично призначено менеджеру ${suggestedOwner}.`);
                        logActivity(`Система призначила ${suggestedOwner} відповідальним за ${lead.name}.`, 'automation', lead.id);
                        hasChanges = true;
                    }
                }

                const stageChanged = maybeAdvanceLeadStage(lead, automation, now);
                const remindersTriggered = maybeSendLeadReminders(lead, automation, now);
                const calendarSynced = maybeSyncLeadCalendar(lead, automation, now);

                if (stageChanged || remindersTriggered || calendarSynced) {
                    hasChanges = true;
                }
            });

            if (hasChanges) {
                saveData();
            }
        }

        function maybeAdvanceLeadStage(lead, automation, now) {
            if (!lead || typeof lead !== 'object') {
                return false;
            }

            const currentStage = lead.stage || 'Новий';
            if (currentStage === 'Втрачено') {
                return false;
            }

            const currentIndex = STAGE_INDEX[currentStage] ?? 0;
            let targetStage = currentStage;
            let targetIndex = currentIndex;
            const scoreValue = Math.max(0, Math.min(100, Number(lead.score) || 0));

            LEAD_STAGE_SCORE_RULES.forEach(rule => {
                const stageIndex = STAGE_INDEX[rule.stage] ?? -1;
                if (stageIndex > targetIndex && scoreValue >= rule.minScore) {
                    targetStage = rule.stage;
                    targetIndex = stageIndex;
                }
            });

            if (!['Угода', 'Втрачено'].includes(currentStage)) {
                const probability = Number(lead.probability) || 0;
                if (probability >= LEAD_AUTOMATION_CLOSE_RULE.probability) {
                    let daysUntil = null;
                    if (lead.expectedClose) {
                        const diff = calculateCalendarDayDiff(lead.expectedClose, now);
                        if (diff !== null) {
                            daysUntil = diff;
                        }
                    }
                    if (daysUntil === null || daysUntil <= 1) {
                        const winIndex = STAGE_INDEX[LEAD_AUTOMATION_CLOSE_RULE.stage] ?? -1;
                        if (winIndex > targetIndex) {
                            targetStage = LEAD_AUTOMATION_CLOSE_RULE.stage;
                            targetIndex = winIndex;
                        }
                    }
                }
            }

            if (targetStage === currentStage) {
                return false;
            }

            const previousStage = currentStage;
            lead.stage = targetStage;
            lead.updatedAt = now.toISOString();
            if (targetStage === 'Угода') {
                lead.status = 'won';
                lead.closedAt = now.toISOString();
                lead.probability = 100;
            } else if (targetStage === 'Втрачено') {
                lead.status = 'lost';
                lead.probability = 0;
            } else {
                lead.status = 'active';
            }
            automation.lastAutoStage = targetStage;
            addTimelineEntry(lead, `Автоматизація (support.monday.com) перемістила зі стадії ${previousStage} до ${targetStage}.`);
            logActivity(`Автоматизація перемістила ${lead.name} на етап ${targetStage}.`, 'automation', lead.id);
            return true;
        }

        function maybeSendLeadReminders(lead, automation, now) {
            if (!lead || !lead.expectedClose || ['Угода', 'Втрачено'].includes(lead.stage)) {
                return false;
            }

            const diffDays = calculateCalendarDayDiff(lead.expectedClose, now);
            if (diffDays === null) {
                return false;
            }

            let changed = false;

            LEAD_REMINDER_DAYS.forEach(day => {
                const key = `${lead.expectedClose}|${day}`;
                if (diffDays === day && !automation.remindersSent.includes(key)) {
                    const message = day === 1
                        ? `До закриття залишився 1 день для ${lead.name}.`
                        : `Закриття ${lead.name} заплановано через ${day} днів.`;
                    addTimelineEntry(lead, `Нагадування: ${message}`);
                    logActivity(message, 'reminder', lead.id);
                    automation.remindersSent.push(key);
                    automation.lastReminderAt = now.toISOString();
                    changed = true;
                }
            });

            if (diffDays === 0) {
                const todayKey = `${lead.expectedClose}|0`;
                if (!automation.remindersSent.includes(todayKey)) {
                    addTimelineEntry(lead, `Нагадування: сьогодні дедлайн угоди ${lead.name}.`);
                    logActivity(`Сьогодні дедлайн угоди ${lead.name}.`, 'reminder', lead.id);
                    automation.remindersSent.push(todayKey);
                    automation.lastReminderAt = now.toISOString();
                    changed = true;
                }
            }

            if (diffDays < 0) {
                const overdueKey = `${lead.expectedClose}|overdue`;
                if (!automation.remindersSent.includes(overdueKey)) {
                    const overdueDays = Math.abs(diffDays);
                    addTimelineEntry(lead, `Угода прострочена на ${overdueDays} дн. Перевірте наступні кроки.`);
                    logActivity(`Угода ${lead.name} прострочена на ${overdueDays} дн.`, 'reminder', lead.id);
                    automation.remindersSent.push(overdueKey);
                    automation.lastReminderAt = now.toISOString();
                    changed = true;
                }
            }

            if (changed) {
                automation.remindersSent = Array.from(new Set(automation.remindersSent));
            }

            return changed;
        }

        function maybeSyncLeadCalendar(lead, automation, now) {
            if (!lead || automation.calendarSynced || !lead.expectedClose) {
                return false;
            }

            const dueDate = new Date(lead.expectedClose);
            if (Number.isNaN(dueDate.getTime())) {
                return false;
            }

            automation.calendarSynced = true;
            addTimelineEntry(lead, 'Подію додано до календаря команди (support.monday.com).');
            logActivity(`Календар оновлено: ${lead.name} очікується ${formatDate(lead.expectedClose)}.`, 'calendar', lead.id);
            return true;
        }

        function renderAll() {
            runLeadAutomations();
            renderDashboard();
            renderPipeline();
            renderProjects(projectSearchTerm);
            renderContacts(document.getElementById('contactSearch').value || '');
            renderTasks();
            renderRoles();
            renderFileExplorer(fileSearchTerm);
            renderAnalytics();
        }

        function updateSidebar() {
            const activeLeads = crmData.leads.filter(lead => lead.stage !== 'Втрачено');
            const pipelineValue = activeLeads.reduce((sum, lead) => sum + lead.value, 0);
            document.getElementById('sidebarDeals').textContent = activeLeads.length;
            document.getElementById('sidebarPipeline').textContent = formatCurrency(pipelineValue, true);
        }

        function renderDashboard() {
            updateSidebar();
            const activeLeads = crmData.leads.filter(lead => lead.stage !== 'Втрачено');
            const wonDeals = crmData.leads.filter(lead => lead.stage === 'Угода');
            const lostDeals = crmData.leads.filter(lead => lead.stage === 'Втрачено');
            const pipelineValue = activeLeads.reduce((sum, lead) => sum + lead.value, 0);
            const expectedRevenue = activeLeads.reduce((sum, lead) => sum + lead.value * (lead.probability / 100), 0);
            const totalClosedDeals = wonDeals.length + lostDeals.length;
            const winRate = totalClosedDeals === 0 ? 0 : Math.round((wonDeals.length / totalClosedDeals) * 100);
            const tasksDueToday = crmData.tasks.filter(task => task.status !== 'done' && isDueToday(task.dueDate)).length;
            const activeTasksCount = crmData.tasks.filter(task => task.status !== 'done').length;
            const hotDeals = activeLeads.filter(lead => lead.probability >= 60).length;
            const wonDealsValue = wonDeals.reduce((sum, lead) => sum + lead.value, 0);
            const lostDealsValue = lostDeals.reduce((sum, lead) => sum + lead.value, 0);

            const metricsContainer = document.getElementById('metricCards');
            if (metricsContainer) {
                const metricsState = {
                    activeLeadsCount: activeLeads.length,
                    hotDealsCount: hotDeals,
                    pipelineValue,
                    expectedRevenue,
                    winRate,
                    wonDealsCount: wonDeals.length,
                    lostDealsCount: lostDeals.length,
                    tasksDueToday,
                    activeTasksCount
                };
                const order = getLayoutOrder('metrics');
                const hidden = new Set(getHiddenBlocks('metrics'));
                metricsContainer.innerHTML = order.map(id => {
                    const renderMetric = METRIC_RENDERERS[id];
                    if (!renderMetric) {
                        return '';
                    }
                    const hiddenClass = hidden.has(id) ? ' layout-hidden' : '';
                    return `<div class="metric-card${hiddenClass}" data-block-id="${id}">${renderMetric(metricsState)}</div>`;
                }).join('');
                layoutManager.refreshArea('metrics');
            }

            renderStageDistribution();
            renderUpcomingActivities();
            renderActivityTimeline();
            renderProcessOverview();
            renderFeatureUsage();
            renderForecastCard(pipelineValue, expectedRevenue);
            renderSalesPerformanceChart({
                totalPipelineValue: pipelineValue,
                totalWonValue: wonDealsValue,
                totalLostValue: lostDealsValue
            });
            renderTeamProductivityChart();
            renderCustomCharts();
        }

        function renderStageDistribution() {
            const container = document.getElementById('stageDistribution');
            const totalValue = crmData.leads.filter(lead => lead.stage !== 'Втрачено').reduce((sum, lead) => sum + lead.value, 0);
            container.innerHTML = STAGES.map(stage => {
                const stageLeads = crmData.leads.filter(lead => lead.stage === stage);
                const stageValue = stageLeads.reduce((sum, lead) => sum + lead.value, 0);
                const percent = totalValue ? Math.round((stageValue / totalValue) * 100) : 0;
                const badgeClass = stage === 'Угода' ? 'badge-success' : stage === 'Втрачено' ? 'badge-danger' : '';
                return `
                    <div class="stage-item">
                        <div class="stage-info">
                            <strong>${stage}</strong>
                            <div class="stage-bar"><span style="width: ${percent || stageLeads.length ? Math.max(percent, 6) : 4}%"></span></div>
                        </div>
                        <div style="text-align: right;">
                            <div>${formatCurrency(stageValue)}</div>
                            <div class="metric-sub">${stageLeads.length} угод${stage === 'Угода' ? `<span class="badge ${badgeClass}" style="margin-left:8px;">успіх</span>` : stage === 'Втрачено' ? `<span class="badge ${badgeClass}" style="margin-left:8px;">потрібна увага</span>` : ''}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderUpcomingActivities() {
            const container = document.getElementById('upcomingActivities');
            const upcoming = [];
            const today = new Date();
            const contacts = crmData && Array.isArray(crmData.contacts) ? crmData.contacts : [];

            crmData.tasks.filter(task => task.status !== 'done' && task.dueDate).forEach(task => {
                const relatedContact = task.relatedContactId
                    ? contacts.find(contact => contact.id === task.relatedContactId)
                    : null;
                upcoming.push({
                    type: 'task',
                    title: task.title,
                    owner: task.owner,
                    dueDate: task.dueDate,
                    relatedLeadId: task.relatedLeadId,
                    relatedContactId: task.relatedContactId,
                    priority: task.priority,
                    contactName: relatedContact ? relatedContact.name : '',
                    contactCompany: relatedContact ? relatedContact.company : ''
                });
            });

            crmData.leads.filter(lead => !['Угода', 'Втрачено'].includes(lead.stage) && lead.expectedClose).forEach(lead => {
                upcoming.push({
                    type: 'lead',
                    title: `Очікуване закриття: ${lead.name}`,
                    owner: lead.owner,
                    dueDate: lead.expectedClose,
                    relatedLeadId: lead.id,
                    priority: lead.probability >= 60 ? 'high' : 'medium'
                });
            });

            const soon = upcoming
                .filter(item => item.dueDate)
                .sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate))
                .slice(0, 5);

            if (soon.length === 0) {
                container.innerHTML = '<div class="empty-state">Найближчі активності відсутні — додайте нові завдання.</div>';
                return;
            }

            container.innerHTML = soon.map(item => {
                const due = formatDate(item.dueDate);
                const overdue = new Date(item.dueDate) < today && !isSameDay(new Date(item.dueDate), today);
                const badge = item.type === 'task'
                    ? (item.priority === 'high' ? 'badge-danger' : item.priority === 'medium' ? 'badge-warning' : 'badge-success')
                    : 'badge-warning';
                const contactLabel = item.contactName
                    ? `Контакт: ${escapeHtml(item.contactName)}${item.contactCompany ? ` (${escapeHtml(item.contactCompany)})` : ''}`
                    : '';
                const metaParts = [
                    overdue ? `${due} • прострочено` : due,
                    item.owner,
                    contactLabel
                ].filter(Boolean);
                const actions = [
                    item.relatedLeadId ? `<button class="btn btn-small-muted" data-open-lead="${item.relatedLeadId}">Угода</button>` : '',
                    item.relatedContactId ? `<button class="btn btn-small-muted" data-open-contact="${item.relatedContactId}">Контакт</button>` : ''
                ].filter(Boolean).join('');
                return `
                    <div class="upcoming-item">
                        <div class="badge ${badge}">${item.type === 'task' ? 'Завдання' : 'Угода'}</div>
                        <div>
                            <strong>${item.title}</strong>
                            <div class="metric-sub">${metaParts.join(' • ')}</div>
                        </div>
                        ${actions}
                    </div>
                `;
            }).join('');

            container.querySelectorAll('[data-open-lead]').forEach(btn => {
                btn.addEventListener('click', () => openLeadDetails(btn.dataset.openLead));
            });

            container.querySelectorAll('[data-open-contact]').forEach(btn => {
                btn.addEventListener('click', () => openContactsSection(btn.dataset.openContact));
            });
        }

        function renderActivityTimeline() {
            const container = document.getElementById('activityTimeline');
            const latest = crmData.activities.slice(0, 6);
            if (latest.length === 0) {
                container.innerHTML = '<div class="empty-state">Ще не було активностей. Додайте перші угоди!</div>';
                return;
            }

            container.innerHTML = latest.map(activity => {
                const icon = getActivityIcon(activity.type);
                return `
                    <div class="timeline-item">
                        <div class="timeline-icon"><i class="${icon}"></i></div>
                        <div class="timeline-content">
                            <div>${activity.message}</div>
                            <div class="timeline-time">${formatRelativeTime(activity.timestamp)}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderProcessOverview() {
            const container = document.getElementById('processOverview');
            if (!container) {
                return;
            }

            const now = new Date();
            const staleThreshold = 7;
            const openLeads = crmData.leads.filter(lead => !['Угода', 'Втрачено'].includes(lead.stage));
            const openTasks = crmData.tasks.filter(task => task.status !== 'done');
            const tasksByLead = openTasks.reduce((map, task) => {
                if (!task.relatedLeadId) {
                    return map;
                }
                if (!map.has(task.relatedLeadId)) {
                    map.set(task.relatedLeadId, []);
                }
                map.get(task.relatedLeadId).push(task);
                return map;
            }, new Map());

            const leadsWithoutTasks = openLeads.filter(lead => !(tasksByLead.get(lead.id)?.length));
            const staleLeads = openLeads.filter(lead => {
                const referenceDate = lead.updatedAt || lead.createdAt;
                if (!referenceDate) {
                    return false;
                }
                return daysBetween(referenceDate, now) >= staleThreshold;
            });
            const overdueTasks = openTasks.filter(task => {
                if (!task.dueDate) {
                    return false;
                }
                const due = new Date(task.dueDate);
                if (Number.isNaN(due.getTime())) {
                    return false;
                }
                return due < now && !isSameDay(due, now);
            });
            const closingSoonLeads = openLeads.filter(lead => {
                if (!lead.expectedClose) {
                    return false;
                }
                const due = new Date(lead.expectedClose);
                if (Number.isNaN(due.getTime())) {
                    return false;
                }
                const diffDays = Math.round((due.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                return diffDays <= 14;
            });

            const avgStageAge = openLeads.length
                ? Math.round(openLeads.reduce((sum, lead) => {
                    const referenceDate = lead.updatedAt || lead.createdAt;
                    return sum + daysBetween(referenceDate, now);
                }, 0) / openLeads.length)
                : null;
            const summaryValue = avgStageAge !== null
                ? `${avgStageAge}<span>дн.</span>`
                : '&mdash;';

            const formatList = (items, getLabel) => {
                if (!items.length) {
                    return '';
                }
                const labels = items.slice(0, 2).map(getLabel);
                if (items.length > 2) {
                    labels.push(`+${items.length - 2}`);
                }
                return labels.join(', ');
            };

            const processStats = [
                {
                    label: 'Без активних задач',
                    value: leadsWithoutTasks.length,
                    note: leadsWithoutTasks.length
                        ? `Потрібно призначити: ${formatList(leadsWithoutTasks, lead => lead.name)}`
                        : 'Кожна угода має наступний крок.',
                    badge: leadsWithoutTasks.length ? 'badge-warning' : 'badge-success',
                    badgeLabel: leadsWithoutTasks.length ? 'потрібна дія' : 'готово'
                },
                {
                    label: 'Без руху 7+ днів',
                    value: staleLeads.length,
                    note: staleLeads.length
                        ? `Оновіть статус: ${formatList(staleLeads, lead => lead.name)}`
                        : 'Стадії оновлюються регулярно.',
                    badge: staleLeads.length ? 'badge-danger' : 'badge-success',
                    badgeLabel: staleLeads.length ? 'ризик' : 'стабільно'
                },
                {
                    label: 'Прострочені задачі',
                    value: overdueTasks.length,
                    note: overdueTasks.length
                        ? `Закрийте: ${formatList(overdueTasks, task => task.title)}`
                        : 'Немає прострочених активностей.',
                    badge: overdueTasks.length ? 'badge-danger' : 'badge-success',
                    badgeLabel: overdueTasks.length ? 'терміново' : 'в нормі'
                },
                {
                    label: 'Закриття ≤ 14 днів',
                    value: closingSoonLeads.length,
                    note: closingSoonLeads.length
                        ? `Готуйте фіналізацію: ${formatList(closingSoonLeads, lead => lead.name)}`
                        : 'Плануйте нові презентації.',
                    badge: closingSoonLeads.length ? 'badge-primary' : 'badge-neutral',
                    badgeLabel: closingSoonLeads.length ? 'фокус' : 'план'
                }
            ];

            const statsMarkup = processStats.map(stat => `
                <div class="process-item">
                    <div class="process-item-top">
                        <div>
                            <div class="process-item-label">${stat.label}</div>
                            <div class="process-item-value">${stat.value}</div>
                        </div>
                        <span class="badge ${stat.badge}">${stat.badgeLabel}</span>
                    </div>
                    <div class="process-item-note">${stat.note}</div>
                </div>
            `).join('');

            const attentionLeads = openLeads
                .map(lead => {
                    const tasks = tasksByLead.get(lead.id) || [];
                    const daysIdle = daysBetween(lead.updatedAt || lead.createdAt, now);
                    const overdueTaskCount = tasks.filter(task => {
                        if (!task.dueDate) {
                            return false;
                        }
                        const due = new Date(task.dueDate);
                        if (Number.isNaN(due.getTime())) {
                            return false;
                        }
                        return due < now && !isSameDay(due, now);
                    }).length;
                    const expectedClose = lead.expectedClose ? new Date(lead.expectedClose) : null;
                    const diffDays = expectedClose && !Number.isNaN(expectedClose.getTime())
                        ? Math.round((expectedClose.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
                        : null;
                    const closingSoon = diffDays !== null && diffDays <= 14;
                    const closingOverdue = diffDays !== null && diffDays < 0;
                    const needsAttention = tasks.length === 0 || daysIdle >= staleThreshold || overdueTaskCount > 0 || closingOverdue;
                    const score = (closingOverdue ? 3 : 0)
                        + (overdueTaskCount ? 2 : 0)
                        + (tasks.length === 0 ? 2 : 0)
                        + (daysIdle >= staleThreshold ? 1 : 0)
                        + (closingSoon ? 1 : 0);
                    return { lead, tasks, daysIdle, overdueTaskCount, closingSoon, closingOverdue, diffDays, needsAttention, score };
                })
                .filter(item => item.needsAttention)
                .sort((a, b) => b.score - a.score || b.daysIdle - a.daysIdle)
                .slice(0, 3);

            const hotlistMarkup = attentionLeads.length
                ? attentionLeads.map(item => `
                    <div class="process-hotlist-item">
                        <div class="process-hotlist-head">
                            <strong>${item.lead.name}</strong>
                            <span class="badge ${item.overdueTaskCount || item.closingOverdue ? 'badge-danger' : item.closingSoon ? 'badge-warning' : 'badge-primary'}">${item.lead.stage}</span>
                        </div>
                        <div class="process-hotlist-meta">
                            <span>Без оновлень: ${item.daysIdle} дн.</span>
                            <span>Активних задач: ${item.tasks.length}</span>
                            ${item.diffDays !== null ? `<span>${item.diffDays < 0 ? 'Дедлайн минув' : 'Закриття через ' + item.diffDays + ' дн.'}</span>` : ''}
                            <span>Менеджер: ${item.lead.owner}</span>
                        </div>
                        <div class="process-hotlist-actions">
                            <button class="btn btn-small-muted" data-open-lead="${item.lead.id}">Деталі</button>
                        </div>
                    </div>
                `).join('')
                : '<div class="empty-state">Усі процеси у графіку — команда працює стабільно.</div>';

            container.innerHTML = `
                <div class="process-summary">
                    <div>
                        <div class="process-summary-value">${summaryValue}</div>
                        <div class="process-summary-label">Середній час у поточній стадії</div>
                    </div>
                    <span class="process-summary-target">Ціль ≤ 10 дн.</span>
                </div>
                <div class="process-grid">
                    ${statsMarkup}
                </div>
                <div class="process-hotlist">
                    <div class="process-hotlist-title">Угоди, що потребують уваги</div>
                    ${hotlistMarkup}
                </div>
            `;

            container.querySelectorAll('[data-open-lead]').forEach(btn => {
                btn.addEventListener('click', () => openLeadDetails(btn.dataset.openLead));
            });
        }

        function renderFeatureUsage() {
            const container = document.getElementById('featureUsage');
            if (!container) {
                return;
            }

            const totalLeads = crmData.leads.length;
            const leadsWithNotes = crmData.leads.filter(lead => Array.isArray(lead.notes) && lead.notes.length > 0).length;
            const leadsWithAttachments = crmData.leads.filter(lead => Array.isArray(lead.attachments) && lead.attachments.length > 0).length;
            const totalTasks = crmData.tasks.length;
            const tasksWithAttachments = crmData.tasks.filter(task => Array.isArray(task.attachments) && task.attachments.length > 0).length;
            const completedTasks = crmData.tasks.filter(task => task.status === 'done').length;
            const totalContacts = crmData.contacts.length;
            const contactsWithNotes = crmData.contacts.filter(contact => Array.isArray(contact.notes) && contact.notes.length > 0).length;

            const featureMetrics = [
                {
                    label: 'Нотатки по лідах',
                    value: leadsWithNotes,
                    total: totalLeads,
                    description: 'Зберігайте ключові домовленості по кожній можливості.',
                    target: '80%'
                },
                {
                    label: 'Документи в угодах',
                    value: leadsWithAttachments,
                    total: totalLeads,
                    description: 'Прикріплюйте брифи, договори та презентації до лідів.',
                    target: '60%'
                },
                {
                    label: 'Виконані задачі',
                    value: completedTasks,
                    total: totalTasks,
                    description: 'Контролюйте доведення задач до кінця.',
                    target: '70%'
                },
                {
                    label: 'Контакти з нотатками',
                    value: contactsWithNotes,
                    total: totalContacts,
                    description: 'Контекст по зустрічах та домовленостях завжди під рукою.',
                    target: '70%'
                },
                {
                    label: 'Файли в задачах',
                    value: tasksWithAttachments,
                    total: totalTasks,
                    description: 'Додавайте матеріали до задач для швидкого старту роботи.',
                    target: '50%'
                }
            ];

            const metricsMarkup = featureMetrics.map(metric => {
                const hasTotal = metric.total && metric.total > 0;
                const percent = hasTotal ? Math.round((metric.value / metric.total) * 100) : 0;
                const badgeClass = hasTotal
                    ? (percent >= 75 ? 'badge-success' : percent >= 45 ? 'badge-warning' : 'badge-danger')
                    : 'badge-neutral';
                const badgeLabel = hasTotal ? `${percent}%` : '—';
                const progressWidth = hasTotal
                    ? (metric.value === 0 ? 0 : Math.min(100, Math.max(percent, 6)))
                    : 0;
                const countLabel = hasTotal ? `${metric.value}/${metric.total}` : `${metric.value}`;
                const description = `${hasTotal ? `${metric.value} з ${metric.total} • ` : ''}${metric.description}${metric.target ? ` Ціль: ${metric.target}.` : ''}`;

                return `
                    <div class="feature-item">
                        <div class="feature-item-header">
                            <div>
                                <div class="feature-label">${metric.label}</div>
                                <div class="feature-meta">${description}</div>
                            </div>
                            <span class="badge ${badgeClass}">${badgeLabel}</span>
                        </div>
                        <div class="feature-progress">
                            <div class="progress-track"><div class="progress-value" style="width:${progressWidth}%"></div></div>
                            <span>${countLabel}</span>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = metricsMarkup;
        }

        function renderSalesPerformanceChart(totals = {}) {
            const canvas = document.getElementById('salesPerformanceChart');
            const summary = document.getElementById('salesPerformanceSummary');
            if (!canvas || typeof Chart === 'undefined') {
                if (summary) {
                    summary.innerHTML = '';
                }
                return;
            }

            const leads = Array.isArray(crmData?.leads) ? crmData.leads : [];
            const parseDate = value => {
                if (!value) {
                    return null;
                }
                const date = value instanceof Date ? new Date(value.getTime()) : new Date(value);
                return Number.isNaN(date.getTime()) ? null : date;
            };

            const relevantDates = leads.flatMap(lead => {
                const dates = [];
                const expected = parseDate(lead.expectedClose);
                const closed = parseDate(lead.closedAt);
                const lost = (lead.status === 'lost' || lead.stage === 'Втрачено') ? parseDate(lead.updatedAt) : null;
                if (expected) dates.push(expected);
                if (closed) dates.push(closed);
                if (lost) dates.push(lost);
                return dates;
            });

            const referenceDate = relevantDates.length
                ? relevantDates.reduce((max, date) => (date > max ? date : max), relevantDates[0])
                : new Date();

            const months = [];
            for (let offset = 5; offset >= 0; offset -= 1) {
                months.push(new Date(referenceDate.getFullYear(), referenceDate.getMonth() - offset, 1));
            }

            const monthFormatter = new Intl.DateTimeFormat('uk-UA', { month: 'short', year: 'numeric' });
            const getMonthKey = date => `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

            const pipelineMap = new Map(months.map(date => [getMonthKey(date), 0]));
            const wonMap = new Map(months.map(date => [getMonthKey(date), 0]));
            const lostMap = new Map(months.map(date => [getMonthKey(date), 0]));

            leads.forEach(lead => {
                const value = Number(lead.value) || 0;
                if (lead.status === 'won' || lead.stage === 'Угода') {
                    const closedDate = parseDate(lead.closedAt) || parseDate(lead.updatedAt);
                    if (closedDate) {
                        const key = getMonthKey(new Date(closedDate.getFullYear(), closedDate.getMonth(), 1));
                        if (wonMap.has(key)) {
                            wonMap.set(key, wonMap.get(key) + value);
                        }
                    }
                } else if (lead.stage !== 'Втрачено' && lead.status !== 'lost') {
                    const expectedDate = parseDate(lead.expectedClose);
                    if (expectedDate) {
                        const key = getMonthKey(new Date(expectedDate.getFullYear(), expectedDate.getMonth(), 1));
                        if (pipelineMap.has(key)) {
                            pipelineMap.set(key, pipelineMap.get(key) + value);
                        }
                    }
                }
                if (lead.status === 'lost' || lead.stage === 'Втрачено') {
                    const lostDate = parseDate(lead.updatedAt)
                        || parseDate(lead.expectedClose)
                        || parseDate(lead.closedAt)
                        || parseDate(lead.createdAt);
                    if (lostDate) {
                        const key = getMonthKey(new Date(lostDate.getFullYear(), lostDate.getMonth(), 1));
                        if (lostMap.has(key)) {
                            lostMap.set(key, lostMap.get(key) + value);
                        }
                    }
                }
            });

            const labels = months.map(date => monthFormatter.format(date));
            const pipelineData = months.map(date => pipelineMap.get(getMonthKey(date)) || 0);
            const wonData = months.map(date => wonMap.get(getMonthKey(date)) || 0);
            const lostData = months.map(date => lostMap.get(getMonthKey(date)) || 0);

            const pipelineTotal = Number.isFinite(totals.totalPipelineValue)
                ? totals.totalPipelineValue
                : pipelineData.reduce((sum, amount) => sum + amount, 0);
            const wonTotal = Number.isFinite(totals.totalWonValue)
                ? totals.totalWonValue
                : wonData.reduce((sum, amount) => sum + amount, 0);
            const lostTotal = Number.isFinite(totals.totalLostValue)
                ? totals.totalLostValue
                : lostData.reduce((sum, amount) => sum + amount, 0);

            if (summary) {
                summary.innerHTML = [
                    `<span class="positive"><strong>${formatCurrency(wonTotal)}</strong> закрито</span>`,
                    `<span class="info"><strong>${formatCurrency(pipelineTotal)}</strong> у прогнозі</span>`,
                    `<span class="negative"><strong>${formatCurrency(lostTotal)}</strong> втрачено</span>`
                ].join('');
            }

            if (salesPerformanceChart) {
                salesPerformanceChart.data.labels = labels;
                salesPerformanceChart.data.datasets[0].data = wonData;
                salesPerformanceChart.data.datasets[1].data = pipelineData;
                salesPerformanceChart.data.datasets[2].data = lostData;
                salesPerformanceChart.update();
                return;
            }

            salesPerformanceChart = new Chart(canvas.getContext('2d'), {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Закриті угоди',
                            data: wonData,
                            borderColor: '#22c55e',
                            backgroundColor: 'rgba(34, 197, 94, 0.18)',
                            tension: 0.35,
                            fill: false,
                            pointRadius: 4,
                            pointBackgroundColor: '#22c55e',
                            pointBorderColor: '#22c55e',
                            order: 3
                        },
                        {
                            label: 'Прогнозований обсяг',
                            data: pipelineData,
                            borderColor: '#6366f1',
                            backgroundColor: 'rgba(99, 102, 241, 0.16)',
                            borderDash: [6, 4],
                            tension: 0.35,
                            fill: false,
                            pointRadius: 4,
                            pointBackgroundColor: '#6366f1',
                            pointBorderColor: '#6366f1',
                            order: 2
                        },
                        {
                            label: 'Втрачено',
                            data: lostData,
                            type: 'bar',
                            backgroundColor: 'rgba(239, 68, 68, 0.28)',
                            borderRadius: 6,
                            borderSkipped: false,
                            barPercentage: 0.6,
                            categoryPercentage: 0.6,
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: {
                            grid: { display: false }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: value => formatCurrency(Number(value), true)
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: context => {
                                    const value = context.parsed.y ?? context.parsed;
                                    return `${context.dataset.label}: ${formatCurrency(value)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderTeamProductivityChart() {
            const canvas = document.getElementById('teamProductivityChart');
            const summary = document.getElementById('teamProductivitySummary');
            if (!canvas || typeof Chart === 'undefined') {
                if (summary) {
                    summary.innerHTML = '';
                }
                return;
            }

            const tasks = Array.isArray(crmData?.tasks) ? crmData.tasks : [];
            const ownerName = task => {
                if (task && typeof task.owner === 'string' && task.owner.trim()) {
                    return task.owner.trim();
                }
                return 'Без відповідального';
            };
            const owners = Array.from(new Set(tasks.map(task => ownerName(task))))
                .sort((a, b) => a.localeCompare(b, 'uk', { sensitivity: 'base' }));

            if (!owners.length) {
                if (summary) {
                    summary.innerHTML = '<span class="info">Немає задач для відображення</span>';
                }
                if (teamProductivityChart) {
                    teamProductivityChart.destroy();
                    teamProductivityChart = null;
                }
                const context = canvas.getContext('2d');
                if (context) {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                }
                return;
            }

            const countByStatus = (owner, status) => tasks.filter(task => ownerName(task) === owner && task.status === status).length;

            const todoData = owners.map(owner => countByStatus(owner, 'todo'));
            const inProgressData = owners.map(owner => countByStatus(owner, 'inProgress'));
            const doneData = owners.map(owner => countByStatus(owner, 'done'));

            const totalDone = doneData.reduce((sum, value) => sum + value, 0);
            const totalActive = todoData.reduce((sum, value) => sum + value, 0)
                + inProgressData.reduce((sum, value) => sum + value, 0);
            const overdueCount = tasks.filter(task => task.status !== 'done' && isOverdue(task.dueDate)).length;

            let topPerformer = { owner: null, count: 0 };
            owners.forEach((owner, index) => {
                const completed = doneData[index];
                if (completed > topPerformer.count) {
                    topPerformer = { owner, count: completed };
                }
            });

            if (summary) {
                const parts = [
                    `<span class="positive"><strong>${totalDone}</strong> завершено</span>`,
                    `<span class="info"><strong>${totalActive}</strong> в роботі</span>`
                ];
                if (overdueCount > 0) {
                    parts.push(`<span class="negative"><strong>${overdueCount}</strong> прострочено</span>`);
                }
                if (topPerformer.owner && topPerformer.count > 0) {
                    parts.push(`<span class="positive">${topPerformer.owner}: <strong>${topPerformer.count}</strong> закрито</span>`);
                }
                summary.innerHTML = parts.join('');
            }

            if (teamProductivityChart) {
                teamProductivityChart.data.labels = owners;
                teamProductivityChart.data.datasets[0].data = todoData;
                teamProductivityChart.data.datasets[1].data = inProgressData;
                teamProductivityChart.data.datasets[2].data = doneData;
                teamProductivityChart.update();
                return;
            }

            teamProductivityChart = new Chart(canvas.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: owners,
                    datasets: [
                        {
                            label: 'До виконання',
                            data: todoData,
                            backgroundColor: 'rgba(99, 102, 241, 0.28)',
                            borderRadius: 8,
                            borderSkipped: false,
                            maxBarThickness: 36,
                            stack: 'tasks'
                        },
                        {
                            label: 'В роботі',
                            data: inProgressData,
                            backgroundColor: 'rgba(14, 165, 233, 0.32)',
                            borderRadius: 8,
                            borderSkipped: false,
                            maxBarThickness: 36,
                            stack: 'tasks'
                        },
                        {
                            label: 'Завершено',
                            data: doneData,
                            backgroundColor: 'rgba(34, 197, 94, 0.38)',
                            borderRadius: 8,
                            borderSkipped: false,
                            maxBarThickness: 36,
                            stack: 'tasks'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            grid: { display: false }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: {
                                precision: 0,
                                stepSize: 1
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: context => {
                                    const value = context.parsed.y ?? 0;
                                    return `${context.dataset.label}: ${value} задач`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function getCustomChartDataset(datasetId) {
            return CUSTOM_CHART_DATASETS.find(dataset => dataset.id === datasetId) || null;
        }

        function getCustomCharts() {
            return Array.isArray(uiPreferences?.customCharts) ? uiPreferences.customCharts.slice() : [];
        }

        function setCustomCharts(charts) {
            if (!uiPreferences) {
                uiPreferences = cloneDefaultPreferences();
            }
            const normalized = (Array.isArray(charts) ? charts : [])
                .map(chart => normalizeCustomChart(chart))
                .filter(Boolean);
            uiPreferences.customCharts = normalized;
            savePreferences();
            renderCustomCharts();
        }

        function getDatasetDefaultOptions(dataset, context = {}) {
            const result = {};
            if (!dataset || !Array.isArray(dataset.options)) {
                return result;
            }
            dataset.options.forEach(option => {
                if (!option || typeof option.id !== 'string') {
                    return;
                }
                if (option.type === 'checkbox') {
                    result[option.id] = option.default === true;
                } else if (option.type === 'select') {
                    const choices = resolveOptionChoices(option, context);
                    const defaultValue = typeof option.default === 'string'
                        ? option.default
                        : (choices[0]?.value ?? '');
                    const normalized = choices.some(choice => String(choice.value) === String(defaultValue))
                        ? String(defaultValue)
                        : (choices[0] ? String(choices[0].value) : '');
                    result[option.id] = normalized;
                } else if (option.type === 'number') {
                    const fallback = Number(option.default);
                    result[option.id] = Number.isFinite(fallback) ? fallback : 0;
                } else {
                    result[option.id] = option.default ?? '';
                }
            });
            return result;
        }

        function getDefaultToggleValues() {
            const values = {};
            CUSTOM_CHART_TOGGLES.forEach(toggle => {
                values[toggle.id] = toggle.default !== false;
            });
            return values;
        }

        function resolveOptionChoices(option, context = {}) {
            if (!option) {
                return [];
            }
            if (typeof option.choices === 'function') {
                try {
                    const resolved = option.choices({ crmData, chartConfig: context.chartConfig || null });
                    return Array.isArray(resolved)
                        ? resolved.filter(choice => choice && typeof choice.value !== 'undefined')
                        : [];
                } catch (error) {
                    console.warn('Не вдалося отримати список опцій для графіка', error);
                    return [];
                }
            }
            return Array.isArray(option.choices) ? option.choices : [];
        }

        function normalizeOptionValue(option, value, context = {}) {
            if (!option) {
                return value;
            }
            if (option.type === 'checkbox') {
                if (typeof value === 'boolean') {
                    return value;
                }
                if (typeof value === 'string') {
                    return value === 'true';
                }
                return option.default === true;
            }
            if (option.type === 'select') {
                const choices = resolveOptionChoices(option, context);
                const allowed = choices.map(choice => String(choice.value));
                const candidate = value != null ? String(value) : '';
                if (allowed.includes(candidate)) {
                    return candidate;
                }
                const fallback = typeof option.default === 'string' ? option.default : (allowed[0] ?? '');
                return allowed.includes(fallback) ? fallback : (allowed[0] ?? '');
            }
            if (option.type === 'number') {
                const numeric = Number(value);
                if (Number.isFinite(numeric)) {
                    return numeric;
                }
                const fallback = Number(option.default);
                return Number.isFinite(fallback) ? fallback : 0;
            }
            return typeof value === 'string' ? value : (option.default ?? '');
        }

        function normalizeCustomChart(config) {
            if (!config || typeof config !== 'object') {
                return null;
            }
            const dataset = getCustomChartDataset(config.datasetId);
            if (!dataset) {
                return null;
            }
            const id = typeof config.id === 'string' && config.id.trim().length ? config.id.trim() : generateId('chart');
            const title = typeof config.title === 'string' && config.title.trim().length ? config.title.trim() : dataset.label;
            const palette = CUSTOM_CHART_PALETTES[config.palette] ? config.palette : 'aurora';
            const allowedTypes = Array.isArray(dataset.allowedTypes) && dataset.allowedTypes.length ? dataset.allowedTypes : ['bar'];
            const defaultType = dataset.defaultType && allowedTypes.includes(dataset.defaultType) ? dataset.defaultType : allowedTypes[0];
            const chartType = allowedTypes.includes(config.chartType) ? config.chartType : defaultType;
            const defaultDatasetOptions = getDatasetDefaultOptions(dataset, { chartConfig: config });
            const providedDatasetOptions = config.datasetOptions && typeof config.datasetOptions === 'object' ? config.datasetOptions : {};
            const datasetOptions = {};
            Object.keys(defaultDatasetOptions).forEach(key => {
                const optionDefinition = (dataset.options || []).find(option => option.id === key);
                datasetOptions[key] = normalizeOptionValue(optionDefinition, providedDatasetOptions[key], { chartConfig: config, dataset });
            });
            const defaultToggleValues = getDefaultToggleValues();
            const providedToggleValues = config.options && typeof config.options === 'object' ? config.options : {};
            const toggleOptions = {};
            Object.keys(defaultToggleValues).forEach(key => {
                toggleOptions[key] = typeof providedToggleValues[key] === 'boolean' ? providedToggleValues[key] : defaultToggleValues[key];
            });
            return {
                id,
                title,
                datasetId: dataset.id,
                chartType,
                palette,
                datasetOptions,
                options: toggleOptions
            };
        }

        function createDefaultChartConfig(datasetId) {
            const dataset = getCustomChartDataset(datasetId);
            if (!dataset) {
                return null;
            }
            return normalizeCustomChart({
                id: generateId('chart'),
                title: dataset.label,
                datasetId: dataset.id,
                chartType: dataset.defaultType,
                palette: 'aurora',
                datasetOptions: {},
                options: {}
            });
        }

        function populateCustomChartSelects() {
            if (customChartMetricSelect) {
                const options = CUSTOM_CHART_DATASETS.map(dataset => {
                    const description = dataset.description ? ` data-description="${escapeHtml(dataset.description)}"` : '';
                    return `<option value="${escapeHtml(dataset.id)}"${description}>${escapeHtml(dataset.label)}</option>`;
                });
                customChartMetricSelect.innerHTML = options.join('');
            }

            if (customChartPaletteSelect) {
                const paletteOptions = Object.entries(CUSTOM_CHART_PALETTES).map(([id, palette]) => (
                    `<option value="${escapeHtml(id)}">${escapeHtml(palette.label)}</option>`
                ));
                customChartPaletteSelect.innerHTML = paletteOptions.join('');
            }
        }

        function renderCustomCharts() {
            const container = document.getElementById('customChartsContainer');
            if (!container) {
                return;
            }

            const charts = getCustomCharts();
            const activeIds = new Set(charts.map(chart => chart.id));
            customChartInstances.forEach((instance, id) => {
                if (!activeIds.has(id)) {
                    instance.destroy();
                    customChartInstances.delete(id);
                }
            });

            if (!charts.length) {
                container.innerHTML = `
                    <div class="custom-chart-empty">
                        <strong>Створіть перший графік</strong>
                        <p>Натисніть «Новий графік», щоб додати персональний віджет з потрібними показниками.</p>
                        <button type="button" class="btn btn-small-primary" data-chart-empty-create>Новий графік</button>
                    </div>
                `;
                const cta = container.querySelector('[data-chart-empty-create]');
                if (cta) {
                    cta.addEventListener('click', () => {
                        const trigger = document.getElementById('addCustomChartBtn');
                        if (trigger) {
                            trigger.click();
                        }
                    });
                }
                return;
            }

            container.innerHTML = charts.map(createCustomChartCardMarkup).join('');
            charts.forEach(config => renderCustomChartCanvas(config));
        }

        function createCustomChartCardMarkup(config) {
            const dataset = getCustomChartDataset(config.datasetId);
            const chartId = typeof config.id === 'string' ? config.id : '';
            const palette = CUSTOM_CHART_PALETTES[config.palette] || CUSTOM_CHART_PALETTES.aurora;
            const typeLabel = CHART_TYPE_LABELS[config.chartType] || config.chartType || 'Діаграма';
            const description = dataset?.description ? `<div class="metric-sub">${escapeHtml(dataset.description)}</div>` : '';
            return `
                <div class="custom-chart-item" data-chart-id="${escapeHtml(chartId)}">
                    <div class="custom-chart-item-header">
                        <div>
                            <h4>${escapeHtml(config.title || dataset?.label || 'Графік')}</h4>
                            ${description}
                            <div class="metric-sub">Тип: ${escapeHtml(typeLabel)} • Палітра: ${escapeHtml(palette.label)}</div>
                        </div>
                        <div class="custom-chart-actions">
                            <button type="button" data-chart-action="edit" data-chart-id="${escapeHtml(chartId)}">
                                <i class="fa-solid fa-pen"></i>
                                Редагувати
                            </button>
                            <button type="button" data-chart-action="duplicate" data-chart-id="${escapeHtml(chartId)}">
                                <i class="fa-regular fa-clone"></i>
                                Дублювати
                            </button>
                            <button type="button" class="danger" data-chart-action="delete" data-chart-id="${escapeHtml(chartId)}">
                                <i class="fa-solid fa-trash"></i>
                                Видалити
                            </button>
                        </div>
                    </div>
                    <div class="custom-chart-canvas">
                        <canvas id="customChartCanvas-${escapeHtml(chartId)}" role="img" aria-label="${escapeHtml(config.title || dataset?.label || 'Графік')}"></canvas>
                    </div>
                    <div class="custom-chart-empty" data-chart-empty hidden></div>
                    <div class="custom-chart-summary-info" data-chart-summary></div>
                </div>
            `;
        }

        function renderCustomChartCanvas(config) {
            const card = document.querySelector(`[data-chart-id="${config.id}"]`);
            if (!card) {
                return;
            }

            const canvasWrapper = card.querySelector('.custom-chart-canvas');
            const canvas = canvasWrapper ? canvasWrapper.querySelector('canvas') : null;
            const summary = card.querySelector('[data-chart-summary]');
            const emptyState = card.querySelector('[data-chart-empty]');
            const dataset = getCustomChartDataset(config.datasetId);

            const clearChartInstance = () => {
                if (customChartInstances.has(config.id)) {
                    const existing = customChartInstances.get(config.id);
                    existing.destroy();
                    customChartInstances.delete(config.id);
                }
                if (canvas) {
                    const context = canvas.getContext('2d');
                    if (context) {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }
                }
            };

            const showEmptyState = message => {
                clearChartInstance();
                if (canvasWrapper) {
                    canvasWrapper.style.display = 'none';
                }
                if (emptyState) {
                    emptyState.innerHTML = `<strong>Немає даних</strong><p>${escapeHtml(message)}</p>`;
                    emptyState.hidden = false;
                }
                if (summary) {
                    summary.textContent = '';
                }
            };

            if (!canvas) {
                return;
            }

            if (typeof Chart === 'undefined') {
                showEmptyState('Бібліотека візуалізацій недоступна. Оновіть сторінку або перевірте підключення.');
                return;
            }

            if (!dataset) {
                showEmptyState('Показник більше не доступний. Відредагуйте графік або виберіть інший показник.');
                return;
            }

            let computeResult = null;
            if (typeof dataset.compute === 'function') {
                try {
                    computeResult = dataset.compute(crmData, config, dataset);
                } catch (error) {
                    console.warn('Не вдалося побудувати користувацький графік', error);
                }
            }

            if (!computeResult || computeResult.error) {
                showEmptyState('Виникла помилка під час побудови графіка. Спробуйте змінити налаштування.');
                return;
            }

            const isEmpty = computeResult.empty === true;
            const datasets = Array.isArray(computeResult.datasets) ? computeResult.datasets : [];
            const hasValues = datasets.some(datasetItem => Array.isArray(datasetItem?.data)
                && datasetItem.data.some(value => Number.isFinite(value) && Math.abs(value) > 0));

            if (isEmpty || !datasets.length || !hasValues) {
                showEmptyState(computeResult.emptyMessage || 'Недостатньо даних для цього графіка.');
                return;
            }

            if (canvasWrapper) {
                canvasWrapper.style.display = '';
            }
            if (emptyState) {
                emptyState.hidden = true;
                emptyState.innerHTML = '';
            }

            applyPaletteToDatasets(datasets, config.palette, config.chartType, config);

            const baseOptions = buildBaseChartOptions(config, dataset, computeResult);
            const mergedOptions = mergeChartOptions(baseOptions, computeResult.options || {});

            const data = {
                labels: Array.isArray(computeResult.labels) ? computeResult.labels : [],
                datasets
            };

            clearChartInstance();
            const context = canvas.getContext('2d');
            const chartInstance = new Chart(context, {
                type: config.chartType,
                data,
                options: mergedOptions
            });
            customChartInstances.set(config.id, chartInstance);

            if (summary) {
                if (Array.isArray(computeResult.summary) && computeResult.summary.length) {
                    summary.innerHTML = computeResult.summary.map(item => `<div>${escapeHtml(String(item))}</div>`).join('');
                } else if (typeof computeResult.summary === 'string') {
                    summary.textContent = computeResult.summary;
                } else {
                    summary.textContent = '';
                }
            }
        }

        function buildColorArray(colors, length) {
            const palette = Array.isArray(colors) && colors.length ? colors.filter(Boolean) : ['#6366F1'];
            if (!length || length <= 0) {
                return palette.slice();
            }
            return Array.from({ length }, (_, index) => palette[index % palette.length]);
        }

        function hexToRgba(hex, alpha = 1) {
            if (typeof hex !== 'string') {
                return `rgba(99, 102, 241, ${alpha})`;
            }
            const normalized = hex.replace('#', '').trim();
            const expanded = normalized.length === 3
                ? normalized.split('').map(char => char + char).join('')
                : normalized.padEnd(6, '0').slice(0, 6);
            const numeric = parseInt(expanded, 16);
            if (Number.isNaN(numeric)) {
                return `rgba(99, 102, 241, ${alpha})`;
            }
            const r = (numeric >> 16) & 255;
            const g = (numeric >> 8) & 255;
            const b = numeric & 255;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function applyPaletteToDatasets(datasets, paletteId, chartType, chartConfig) {
            if (!Array.isArray(datasets)) {
                return;
            }
            const palette = CUSTOM_CHART_PALETTES[paletteId] || CUSTOM_CHART_PALETTES.aurora;
            const baseColors = palette.colors || ['#6366F1'];
            datasets.forEach((dataset, index) => {
                if (!dataset || typeof dataset !== 'object') {
                    return;
                }
                const datasetType = dataset.type || chartType;
                const color = baseColors[index % baseColors.length] || '#6366F1';
                if (datasetType === 'line') {
                    if (!dataset.borderColor) {
                        dataset.borderColor = color;
                    }
                    if (!dataset.backgroundColor) {
                        const alpha = chartConfig?.options?.fillArea ? 0.25 : 0.08;
                        dataset.backgroundColor = hexToRgba(color, alpha);
                    }
                    if (!dataset.pointBackgroundColor) {
                        dataset.pointBackgroundColor = color;
                    }
                    if (!dataset.pointBorderColor) {
                        dataset.pointBorderColor = '#ffffff';
                    }
                    if (typeof dataset.borderWidth === 'undefined') {
                        dataset.borderWidth = 2;
                    }
                    if (chartConfig?.options?.smoothLines === false) {
                        dataset.tension = 0;
                    } else if (typeof dataset.tension !== 'number') {
                        dataset.tension = 0.35;
                    }
                    if (chartConfig?.options?.fillArea === false) {
                        dataset.fill = false;
                    } else if (typeof dataset.fill === 'undefined') {
                        dataset.fill = chartType === 'line' ? 'origin' : false;
                    }
                } else if (datasetType === 'doughnut' || datasetType === 'polarArea') {
                    const dataLength = Array.isArray(dataset.data) ? dataset.data.length : baseColors.length;
                    if (!Array.isArray(dataset.backgroundColor) || !dataset.backgroundColor.length) {
                        const alpha = datasetType === 'polarArea' ? 0.85 : 0.9;
                        dataset.backgroundColor = buildColorArray(baseColors.map(value => hexToRgba(value, alpha)), dataLength);
                    }
                    if (!dataset.borderColor) {
                        dataset.borderColor = '#ffffff';
                    }
                    if (typeof dataset.borderWidth === 'undefined') {
                        dataset.borderWidth = 1;
                    }
                    if (typeof dataset.hoverOffset === 'undefined') {
                        dataset.hoverOffset = 6;
                    }
                } else if (datasetType === 'radar') {
                    if (!dataset.borderColor) {
                        dataset.borderColor = color;
                    }
                    if (!dataset.backgroundColor) {
                        dataset.backgroundColor = hexToRgba(color, 0.22);
                    }
                    if (!dataset.pointBackgroundColor) {
                        dataset.pointBackgroundColor = color;
                    }
                    if (!dataset.pointBorderColor) {
                        dataset.pointBorderColor = '#ffffff';
                    }
                    if (typeof dataset.borderWidth === 'undefined') {
                        dataset.borderWidth = 2;
                    }
                    if (typeof dataset.fill === 'undefined') {
                        dataset.fill = true;
                    }
                } else {
                    if (!dataset.backgroundColor) {
                        dataset.backgroundColor = hexToRgba(color, 0.75);
                    }
                    if (!dataset.borderColor) {
                        dataset.borderColor = hexToRgba(color, 0.95);
                    }
                    if (typeof dataset.borderWidth === 'undefined') {
                        dataset.borderWidth = 1;
                    }
                    if (typeof dataset.borderRadius === 'undefined') {
                        dataset.borderRadius = 10;
                    }
                }
            });
        }

        function buildBaseChartOptions(chartConfig, datasetDefinition, computeResult) {
            const showLegend = chartConfig?.options?.showLegend !== false;
            const showTooltip = chartConfig?.options?.showTooltip !== false;
            const showGrid = chartConfig?.options?.showGrid !== false;
            const chartType = chartConfig.chartType || datasetDefinition?.defaultType || 'bar';

            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: showLegend,
                        position: 'bottom',
                        labels: { usePointStyle: true }
                    },
                    tooltip: {
                        enabled: showTooltip,
                        intersect: false,
                        mode: 'index'
                    }
                }
            };

            if (chartType === 'line') {
                options.interaction = { intersect: false, mode: 'index' };
                options.scales = {
                    x: { grid: { display: showGrid } },
                    y: { grid: { display: showGrid }, beginAtZero: true }
                };
            } else if (chartType === 'bar') {
                options.scales = {
                    x: { grid: { display: showGrid } },
                    y: { grid: { display: showGrid }, beginAtZero: true }
                };
            } else if (chartType === 'radar') {
                options.scales = {
                    r: {
                        grid: { display: showGrid },
                        beginAtZero: true
                    }
                };
                options.plugins.tooltip.mode = 'nearest';
            }

            if (computeResult?.options?.indexAxis) {
                options.indexAxis = computeResult.options.indexAxis;
            }

            return options;
        }

        function mergeChartOptions(base = {}, overrides = {}) {
            if (!overrides || typeof overrides !== 'object') {
                return Array.isArray(base) ? [...base] : { ...base };
            }
            const result = Array.isArray(base) ? [...base] : { ...base };
            Object.keys(overrides).forEach(key => {
                const overrideValue = overrides[key];
                if (overrideValue && typeof overrideValue === 'object' && !Array.isArray(overrideValue)) {
                    result[key] = mergeChartOptions(base[key] || {}, overrideValue);
                } else {
                    result[key] = overrideValue;
                }
            });
            return result;
        }

        function renderCustomChartOptions(dataset, chartConfig) {
            if (!customChartOptionsContainer || !customChartOptionsSection) {
                return;
            }
            const options = Array.isArray(dataset?.options) ? dataset.options : [];
            if (!options.length) {
                customChartOptionsContainer.innerHTML = '';
                customChartOptionsSection.hidden = true;
                return;
            }

            customChartOptionsSection.hidden = false;
            const markup = options.map(option => {
                const optionId = `customChartOption-${option.id}`;
                const value = chartConfig.datasetOptions?.[option.id];
                if (option.type === 'checkbox') {
                    const checked = value === true;
                    const description = option.description ? `<small>${escapeHtml(option.description)}</small>` : '';
                    return `
                        <div class="custom-chart-option" data-option-id="${escapeHtml(option.id)}" data-option-type="checkbox">
                            <label class="custom-chart-checkbox">
                                <input type="checkbox" id="${escapeHtml(optionId)}" ${checked ? 'checked' : ''}>
                                <span>${escapeHtml(option.label || option.id)}${description}</span>
                            </label>
                        </div>
                    `;
                }

                if (option.type === 'number') {
                    const numericValue = Number.isFinite(value) ? value : option.default || 0;
                    const attrs = [
                        typeof option.min !== 'undefined' ? `min="${option.min}"` : '',
                        typeof option.max !== 'undefined' ? `max="${option.max}"` : '',
                        typeof option.step !== 'undefined' ? `step="${option.step}"` : ''
                    ].filter(Boolean).join(' ');
                    const description = option.description ? `<div class="option-description">${escapeHtml(option.description)}</div>` : '';
                    return `
                        <div class="custom-chart-option" data-option-id="${escapeHtml(option.id)}" data-option-type="number">
                            <label for="${escapeHtml(optionId)}">${escapeHtml(option.label || option.id)}</label>
                            <input type="number" id="${escapeHtml(optionId)}" value="${escapeHtml(String(numericValue))}" ${attrs}>
                            ${description}
                        </div>
                    `;
                }

                const choices = resolveOptionChoices(option, { crmData, chartConfig });
                let optionsMarkup = choices.map(choice => {
                    const choiceValue = String(choice.value);
                    const selected = String(value) === choiceValue ? 'selected' : '';
                    return `<option value="${escapeHtml(choiceValue)}" ${selected}>${escapeHtml(choice.label || choiceValue)}</option>`;
                }).join('');
                if (!choices.some(choice => String(choice.value) === String(value)) && typeof value !== 'undefined' && value !== null && value !== '') {
                    const fallback = String(value);
                    optionsMarkup = `<option value="${escapeHtml(fallback)}" selected>${escapeHtml(fallback)} (недоступно)</option>` + optionsMarkup;
                }
                const description = option.description ? `<div class="option-description">${escapeHtml(option.description)}</div>` : '';
                return `
                    <div class="custom-chart-option" data-option-id="${escapeHtml(option.id)}" data-option-type="select">
                        <label for="${escapeHtml(optionId)}">${escapeHtml(option.label || option.id)}</label>
                        <select id="${escapeHtml(optionId)}">${optionsMarkup}</select>
                        ${description}
                    </div>
                `;
            }).join('');

            customChartOptionsContainer.innerHTML = markup;
        }

        function renderCustomChartToggles(chartConfig) {
            if (!customChartToggleList) {
                return;
            }
            const toggles = CUSTOM_CHART_TOGGLES;
            if (!toggles.length) {
                customChartToggleList.innerHTML = '';
                return;
            }

            const markup = toggles.map(toggle => {
                const supported = !Array.isArray(toggle.types) || toggle.types.includes(chartConfig.chartType);
                const checked = supported && chartConfig.options?.[toggle.id] !== false;
                const disabledAttr = supported ? '' : 'disabled';
                const toggleId = `customChartToggle-${toggle.id}`;
                return `
                    <label class="custom-chart-toggle" data-disabled="${supported ? 'false' : 'true'}" for="${escapeHtml(toggleId)}">
                        <input type="checkbox" id="${escapeHtml(toggleId)}" value="${escapeHtml(toggle.id)}" ${checked ? 'checked' : ''} ${disabledAttr}>
                        ${escapeHtml(toggle.label)}
                    </label>
                `;
            }).join('');

            customChartToggleList.innerHTML = markup;
        }

        function updateCustomChartFormState(config) {
            if (!customChartForm) {
                return;
            }

            const nextConfig = { ...config };
            let dataset = getCustomChartDataset(nextConfig.datasetId);
            if (!dataset && CUSTOM_CHART_DATASETS.length) {
                dataset = CUSTOM_CHART_DATASETS[0];
                nextConfig.datasetId = dataset.id;
            }
            if (!dataset) {
                return;
            }

            const datasetDefaults = getDatasetDefaultOptions(dataset, { chartConfig: nextConfig, dataset });
            nextConfig.datasetOptions = {
                ...datasetDefaults,
                ...(nextConfig.datasetOptions || {})
            };
            const toggleDefaults = getDefaultToggleValues();
            nextConfig.options = {
                ...toggleDefaults,
                ...(nextConfig.options || {})
            };

            if (customChartIdInput) {
                customChartIdInput.value = nextConfig.id || '';
            }

            if (customChartMetricSelect) {
                customChartMetricSelect.value = dataset.id;
            }

            if (customChartTitleInput) {
                customChartTitleInput.value = nextConfig.title || dataset.label;
            }

            if (customChartMetricHint) {
                customChartMetricHint.textContent = dataset.description || '';
            }

            if (customChartTypeSelect) {
                const allowedTypes = Array.isArray(dataset.allowedTypes) && dataset.allowedTypes.length
                    ? dataset.allowedTypes
                    : ['bar'];
                customChartTypeSelect.innerHTML = allowedTypes
                    .map(type => `<option value="${escapeHtml(type)}">${escapeHtml(CHART_TYPE_LABELS[type] || type)}</option>`)
                    .join('');
                const selectedType = allowedTypes.includes(nextConfig.chartType)
                    ? nextConfig.chartType
                    : (dataset.defaultType || allowedTypes[0]);
                customChartTypeSelect.value = selectedType;
                nextConfig.chartType = selectedType;
            }

            if (customChartPaletteSelect) {
                const paletteId = CUSTOM_CHART_PALETTES[nextConfig.palette] ? nextConfig.palette : 'aurora';
                customChartPaletteSelect.value = paletteId;
                nextConfig.palette = paletteId;
            }

            renderCustomChartOptions(dataset, nextConfig);
            renderCustomChartToggles(nextConfig);
        }

        function collectCustomChartFormValues({ normalize = false } = {}) {
            if (!customChartForm) {
                return null;
            }

            const selectedDatasetId = customChartMetricSelect?.value || (CUSTOM_CHART_DATASETS[0]?.id ?? '');
            const dataset = getCustomChartDataset(selectedDatasetId);
            const paletteValue = customChartPaletteSelect?.value;
            const palette = CUSTOM_CHART_PALETTES[paletteValue] ? paletteValue : 'aurora';
            const rawType = customChartTypeSelect?.value || dataset?.defaultType || 'bar';
            const allowedTypes = Array.isArray(dataset?.allowedTypes) && dataset.allowedTypes.length
                ? dataset.allowedTypes
                : [rawType];
            const chartType = allowedTypes.includes(rawType) ? rawType : (dataset?.defaultType || allowedTypes[0]);

            const baseConfig = {
                id: customChartIdInput ? customChartIdInput.value : '',
                title: customChartTitleInput ? customChartTitleInput.value.trim() : '',
                datasetId: dataset ? dataset.id : selectedDatasetId,
                chartType,
                palette,
                datasetOptions: {},
                options: {}
            };

            const defaults = dataset ? getDatasetDefaultOptions(dataset, { chartConfig: baseConfig, dataset }) : {};
            const datasetOptions = { ...defaults };
            if (dataset && customChartOptionsContainer) {
                dataset.options?.forEach(option => {
                    const wrapper = customChartOptionsContainer.querySelector(`[data-option-id="${option.id}"]`);
                    if (!wrapper) {
                        return;
                    }
                    let value = defaults[option.id];
                    if (option.type === 'checkbox') {
                        const input = wrapper.querySelector('input[type="checkbox"]');
                        value = input ? input.checked : defaults[option.id];
                    } else if (option.type === 'number') {
                        const input = wrapper.querySelector('input[type="number"]');
                        value = input ? Number(input.value) : defaults[option.id];
                    } else {
                        const input = wrapper.querySelector('select, input');
                        value = input ? input.value : defaults[option.id];
                    }
                    datasetOptions[option.id] = normalizeOptionValue(option, value, { chartConfig: baseConfig, dataset });
                });
            }

            baseConfig.datasetOptions = datasetOptions;

            const toggleDefaults = getDefaultToggleValues();
            const toggleValues = { ...toggleDefaults };
            if (customChartToggleList) {
                customChartToggleList.querySelectorAll('input[type="checkbox"]').forEach(input => {
                    const toggleId = input.value;
                    if (!Object.prototype.hasOwnProperty.call(toggleValues, toggleId)) {
                        toggleValues[toggleId] = input.checked;
                        return;
                    }
                    toggleValues[toggleId] = input.disabled ? toggleDefaults[toggleId] : input.checked;
                });
            }
            baseConfig.options = toggleValues;

            if (!baseConfig.title) {
                baseConfig.title = dataset ? dataset.label : 'Графік';
            }

            return normalize ? normalizeCustomChart(baseConfig) : baseConfig;
        }

        function handleCustomChartSubmit(event) {
            event.preventDefault();
            const config = collectCustomChartFormValues({ normalize: true });
            if (!config) {
                return;
            }
            const charts = getCustomCharts();
            const index = charts.findIndex(chart => chart.id === config.id);
            if (index >= 0) {
                charts[index] = config;
            } else {
                charts.push(config);
            }
            setCustomCharts(charts);
            closeModal('customChartModal');
        }

        function duplicateCustomChart(config) {
            if (!config) {
                return;
            }
            const copy = normalizeCustomChart({
                ...config,
                id: generateId('chart'),
                title: config.title ? `${config.title} — копія` : config.title
            });
            const charts = getCustomCharts();
            charts.push(copy);
            setCustomCharts(charts);
        }

        function deleteCustomChart(chartId) {
            if (!chartId) {
                return;
            }
            if (!window.confirm('Видалити графік? Дію неможливо скасувати.')) {
                return;
            }
            const charts = getCustomCharts().filter(chart => chart.id !== chartId);
            if (customChartInstances.has(chartId)) {
                const instance = customChartInstances.get(chartId);
                instance.destroy();
                customChartInstances.delete(chartId);
            }
            setCustomCharts(charts);
        }

        function openCustomChartModal(config = null) {
            if (!customChartForm) {
                return;
            }
            let preparedConfig = null;
            if (config) {
                preparedConfig = normalizeCustomChart(config);
            } else if (CUSTOM_CHART_DATASETS.length) {
                const dataset = CUSTOM_CHART_DATASETS[0];
                preparedConfig = {
                    id: '',
                    title: dataset.label,
                    datasetId: dataset.id,
                    chartType: dataset.defaultType,
                    palette: 'aurora',
                    datasetOptions: getDatasetDefaultOptions(dataset, { chartConfig: { datasetId: dataset.id, chartType: dataset.defaultType }, dataset }),
                    options: getDefaultToggleValues()
                };
            }

            if (!preparedConfig) {
                return;
            }

            if (!config) {
                preparedConfig.id = '';
            }

            updateCustomChartFormState(preparedConfig);
            if (customChartModalTitle) {
                customChartModalTitle.textContent = config ? 'Редагувати графік' : 'Новий графік';
            }
            openModal('customChartModal');
            if (customChartTitleInput) {
                requestAnimationFrame(() => {
                    if (config) {
                        customChartTitleInput.focus();
                    } else {
                        customChartTitleInput.select();
                    }
                });
            }
        }

        function setupCustomCharts() {
            const container = document.getElementById('customChartsContainer');
            customChartForm = document.getElementById('customChartForm');
            if (!container || !customChartForm) {
                return;
            }

            customChartIdInput = document.getElementById('customChartId');
            customChartTitleInput = document.getElementById('customChartTitle');
            customChartMetricSelect = document.getElementById('customChartMetric');
            customChartTypeSelect = document.getElementById('customChartType');
            customChartPaletteSelect = document.getElementById('customChartPalette');
            customChartOptionsContainer = document.getElementById('customChartOptions');
            customChartOptionsSection = document.getElementById('customChartOptionsSection');
            customChartToggleList = document.getElementById('customChartToggleList');
            customChartMetricHint = document.getElementById('customChartMetricHint');
            customChartModalTitle = document.getElementById('customChartModalTitle');

            populateCustomChartSelects();

            const addButton = document.getElementById('addCustomChartBtn');
            if (addButton) {
                addButton.addEventListener('click', () => openCustomChartModal());
            }

            customChartForm.addEventListener('submit', handleCustomChartSubmit);

            if (customChartMetricSelect) {
                customChartMetricSelect.addEventListener('change', () => {
                    const dataset = getCustomChartDataset(customChartMetricSelect.value);
                    if (!dataset) {
                        return;
                    }
                    const paletteValue = customChartPaletteSelect && CUSTOM_CHART_PALETTES[customChartPaletteSelect.value]
                        ? customChartPaletteSelect.value
                        : 'aurora';
                    const config = {
                        id: customChartIdInput ? customChartIdInput.value : '',
                        title: customChartTitleInput ? (customChartTitleInput.value.trim() || dataset.label) : dataset.label,
                        datasetId: dataset.id,
                        chartType: dataset.defaultType,
                        palette: paletteValue,
                        datasetOptions: getDatasetDefaultOptions(dataset, { chartConfig: { datasetId: dataset.id, chartType: dataset.defaultType }, dataset }),
                        options: getDefaultToggleValues()
                    };
                    updateCustomChartFormState(config);
                });
            }

            if (customChartTypeSelect) {
                customChartTypeSelect.addEventListener('change', () => {
                    const current = collectCustomChartFormValues();
                    if (!current) {
                        return;
                    }
                    current.chartType = customChartTypeSelect.value;
                    updateCustomChartFormState(current);
                });
            }

            container.addEventListener('click', event => {
                const actionButton = event.target.closest('[data-chart-action]');
                if (!actionButton) {
                    return;
                }
                const chartId = actionButton.dataset.chartId;
                const action = actionButton.dataset.chartAction;
                if (!chartId || !action) {
                    return;
                }
                const charts = getCustomCharts();
                const config = charts.find(chart => chart.id === chartId);
                if (action === 'edit') {
                    if (!config) {
                        return;
                    }
                    updateCustomChartFormState(config);
                    if (customChartModalTitle) {
                        customChartModalTitle.textContent = 'Редагувати графік';
                    }
                    openModal('customChartModal');
                    if (customChartTitleInput) {
                        requestAnimationFrame(() => customChartTitleInput.focus());
                    }
                } else if (action === 'duplicate') {
                    if (config) {
                        duplicateCustomChart(config);
                    }
                } else if (action === 'delete') {
                    deleteCustomChart(chartId);
                }
            });

            renderCustomCharts();
        }

        function parseCustomChartDate(value) {
            if (!value) {
                return null;
            }
            const date = value instanceof Date ? new Date(value.getTime()) : new Date(value);
            return Number.isNaN(date.getTime()) ? null : date;
        }

        function startOfMonth(date) {
            return new Date(date.getFullYear(), date.getMonth(), 1);
        }

        function getMonthKeyValue(date) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        }

        function getRecentMonths(count, referenceDate = new Date()) {
            const months = [];
            const safeCount = Math.max(1, Math.round(count));
            const start = startOfMonth(referenceDate);
            for (let index = safeCount - 1; index >= 0; index -= 1) {
                months.push(new Date(start.getFullYear(), start.getMonth() - index, 1));
            }
            return months;
        }

        function formatMonthLabel(date) {
            const formatter = new Intl.DateTimeFormat('uk-UA', { month: 'short', year: 'numeric' });
            return formatter.format(date);
        }

        function computePipelineStageDataset(crmData, chartConfig) {
            const leads = Array.isArray(crmData?.leads) ? crmData.leads : [];
            if (!leads.length) {
                return {
                    empty: true,
                    emptyMessage: 'Додайте угоди у CRM, щоб побачити розподіл по етапах.'
                };
            }

            const options = chartConfig?.datasetOptions || {};
            const includeLost = options.includeLost === true;
            const valueMode = options.valueMode === 'count' ? 'count' : 'value';
            const sortMode = options.sort === 'desc' ? 'desc' : 'pipeline';

            const stages = STAGES.filter(stage => includeLost || stage !== 'Втрачено');
            const rows = stages.map(stage => {
                const stageLeads = leads.filter(lead => lead.stage === stage);
                const amount = stageLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0), 0);
                return {
                    stage,
                    amount,
                    count: stageLeads.length
                };
            });

            if (sortMode === 'desc') {
                rows.sort((a, b) => {
                    const valueA = valueMode === 'value' ? a.amount : a.count;
                    const valueB = valueMode === 'value' ? b.amount : b.count;
                    return valueB - valueA;
                });
            }

            const labels = rows.map(item => item.stage);
            const values = rows.map(item => valueMode === 'value' ? item.amount : item.count);
            const totalAmount = rows.reduce((sum, item) => sum + item.amount, 0);
            const totalCount = rows.reduce((sum, item) => sum + item.count, 0);

            const summaryParts = [];
            if (valueMode === 'value') {
                summaryParts.push(`Активна воронка: ${formatCurrency(totalAmount)}`);
            } else {
                summaryParts.push(`Усього угод: ${formatIntegerDisplay(totalCount)}`);
            }
            const leader = rows.reduce((best, item) => {
                const value = valueMode === 'value' ? item.amount : item.count;
                if (!best || value > best.value) {
                    return { stage: item.stage, value };
                }
                return best;
            }, null);
            if (leader && leader.value > 0) {
                summaryParts.push(`Лідирує етап «${leader.stage}»`);
            }

            const empty = values.every(value => !Number.isFinite(value) || value <= 0);

            return {
                labels,
                datasets: [
                    {
                        label: valueMode === 'value' ? 'Сума угод, ₴' : 'Кількість угод',
                        data: values
                    }
                ],
                options: {
                    scales: {
                        y: { beginAtZero: true }
                    }
                },
                summary: summaryParts,
                empty,
                emptyMessage: 'Поки що немає угод у вибраному розрізі.'
            };
        }

        function computeRevenueTrendDataset(crmData, chartConfig) {
            const leads = Array.isArray(crmData?.leads) ? crmData.leads : [];
            if (!leads.length) {
                return {
                    empty: true,
                    emptyMessage: 'Додайте угоди, щоб побудувати динаміку.'
                };
            }

            const rangeValue = Math.max(1, Number(chartConfig?.datasetOptions?.range) || 6);
            const metric = chartConfig?.datasetOptions?.metric || 'wonValue';
            const showComparison = chartConfig?.datasetOptions?.comparison !== false;

            const relevantDates = leads.flatMap(lead => [
                parseCustomChartDate(lead.closedAt),
                parseCustomChartDate(lead.updatedAt),
                parseCustomChartDate(lead.expectedClose),
                parseCustomChartDate(lead.createdAt)
            ].filter(Boolean));
            const referenceDate = relevantDates.length
                ? relevantDates.reduce((latest, current) => (current > latest ? current : latest), relevantDates[0])
                : new Date();

            const months = getRecentMonths(rangeValue, referenceDate);
            const monthKeys = months.map(getMonthKeyValue);
            const monthState = monthKeys.reduce((acc, key) => {
                acc[key] = {
                    wonValue: 0,
                    wonCount: 0,
                    newLeads: 0,
                    pipelineValue: 0,
                    pipelineCount: 0
                };
                return acc;
            }, {});

            leads.forEach(lead => {
                const value = Number(lead.value) || 0;
                const created = parseCustomChartDate(lead.createdAt);
                if (created) {
                    const key = getMonthKeyValue(startOfMonth(created));
                    if (monthState[key]) {
                        monthState[key].newLeads += 1;
                    }
                }
                const closedDate = (lead.stage === 'Угода' || lead.status === 'won')
                    ? (parseCustomChartDate(lead.closedAt) || parseCustomChartDate(lead.updatedAt))
                    : null;
                if (closedDate) {
                    const key = getMonthKeyValue(startOfMonth(closedDate));
                    if (monthState[key]) {
                        monthState[key].wonValue += value;
                        monthState[key].wonCount += 1;
                    }
                }
                const expected = parseCustomChartDate(lead.expectedClose);
                if (expected) {
                    const key = getMonthKeyValue(startOfMonth(expected));
                    if (monthState[key]) {
                        const probability = Number(lead.probability);
                        const weighted = Number.isFinite(probability) ? value * (probability / 100) : value;
                        monthState[key].pipelineValue += weighted;
                        monthState[key].pipelineCount += 1;
                    }
                }
            });

            const labels = months.map(formatMonthLabel);
            const primaryData = monthKeys.map(key => {
                if (metric === 'wonValue') return monthState[key].wonValue;
                if (metric === 'wonCount') return monthState[key].wonCount;
                if (metric === 'newLeads') return monthState[key].newLeads;
                return monthState[key].pipelineValue;
            });

            let comparisonDataset = null;
            if (showComparison) {
                if (metric === 'wonValue') {
                    comparisonDataset = {
                        label: 'Прогноз, ₴',
                        data: monthKeys.map(key => monthState[key].pipelineValue),
                        borderDash: [6, 4],
                        type: chartConfig.chartType === 'bar' ? 'line' : undefined,
                        fill: false
                    };
                } else if (metric === 'wonCount') {
                    comparisonDataset = {
                        label: 'Очікувані угоди',
                        data: monthKeys.map(key => monthState[key].pipelineCount),
                        borderDash: [6, 4],
                        fill: false
                    };
                } else if (metric === 'newLeads') {
                    const average = monthKeys.length
                        ? Math.round(monthKeys.reduce((sum, key) => sum + monthState[key].newLeads, 0) / monthKeys.length)
                        : 0;
                    comparisonDataset = {
                        label: 'Середнє значення',
                        data: monthKeys.map(() => average),
                        borderDash: [6, 4],
                        fill: false
                    };
                } else {
                    comparisonDataset = {
                        label: 'Закрито, ₴',
                        data: monthKeys.map(key => monthState[key].wonValue),
                        borderDash: [6, 4],
                        type: chartConfig.chartType === 'bar' ? 'line' : undefined,
                        fill: false
                    };
                }
            }

            const datasets = [
                {
                    label: metric === 'wonValue'
                        ? 'Виграно, ₴'
                        : metric === 'wonCount'
                            ? 'Виграно, шт.'
                            : metric === 'newLeads'
                                ? 'Нові ліди'
                                : 'Очікуваний прогноз, ₴',
                    data: primaryData
                }
            ];
            if (comparisonDataset) {
                datasets.push(comparisonDataset);
            }

            const summaryParts = [];
            const lastValue = primaryData[primaryData.length - 1] ?? 0;
            if (metric === 'wonValue' || metric === 'pipelineValue') {
                summaryParts.push(`Останній місяць: ${formatCurrency(lastValue)}`);
            } else {
                summaryParts.push(`Останній місяць: ${formatIntegerDisplay(lastValue)}`);
            }
            if (primaryData.length >= 2) {
                const prev = primaryData[primaryData.length - 2];
                const diff = lastValue - prev;
                if (metric === 'wonValue' || metric === 'pipelineValue') {
                    summaryParts.push(`${diff >= 0 ? 'Зростання' : 'Падіння'} проти попереднього місяця: ${formatCurrency(Math.abs(diff))}`);
                } else {
                    summaryParts.push(`${diff >= 0 ? 'Зростання' : 'Падіння'}: ${formatIntegerDisplay(Math.abs(diff))}`);
                }
            }

            const hasValues = datasets.some(dataset => Array.isArray(dataset.data)
                && dataset.data.some(value => Number.isFinite(value) && Math.abs(value) > 0));

            return {
                labels,
                datasets,
                options: {
                    scales: {
                        y: { beginAtZero: true }
                    }
                },
                summary: summaryParts,
                empty: !hasValues,
                emptyMessage: 'Немає історичних даних для побудови тренду.'
            };
        }

        function computeOwnerPerformanceDataset(crmData, chartConfig) {
            const leads = Array.isArray(crmData?.leads) ? crmData.leads : [];
            if (!leads.length) {
                return {
                    empty: true,
                    emptyMessage: 'Додайте угоди, щоб аналізувати результативність команди.'
                };
            }

            const options = chartConfig?.datasetOptions || {};
            const metric = options.metric || 'pipelineValue';
            const limit = options.limit || 'all';
            const includeLost = options.showLost === true;

            const ownerMap = new Map();
            leads.forEach(lead => {
                const owner = typeof lead.owner === 'string' && lead.owner.trim().length ? lead.owner.trim() : 'Без відповідального';
                if (!ownerMap.has(owner)) {
                    ownerMap.set(owner, { pipelineValue: 0, wonValue: 0, total: 0, wonCount: 0, lostCount: 0 });
                }
                const stats = ownerMap.get(owner);
                const value = Number(lead.value) || 0;
                const stage = lead.stage;
                const isWon = stage === 'Угода' || lead.status === 'won';
                const isLost = stage === 'Втрачено' || lead.status === 'lost';
                stats.total += 1;
                if (!isLost) {
                    stats.pipelineValue += value;
                }
                if (isWon) {
                    stats.wonValue += value;
                    stats.wonCount += 1;
                }
                if (isLost) {
                    stats.lostCount += 1;
                }
            });

            let entries = Array.from(ownerMap.entries()).map(([owner, stats]) => {
                let metricValue = 0;
                if (metric === 'pipelineValue') {
                    metricValue = stats.pipelineValue;
                } else if (metric === 'wonValue') {
                    metricValue = stats.wonValue;
                } else if (metric === 'dealCount') {
                    metricValue = includeLost ? stats.total : Math.max(0, stats.total - stats.lostCount);
                } else if (metric === 'winRate') {
                    const denominator = stats.wonCount + stats.lostCount;
                    metricValue = denominator ? Math.round((stats.wonCount / denominator) * 100) : 0;
                }
                return { owner, stats, metricValue };
            });

            entries.sort((a, b) => b.metricValue - a.metricValue);
            if (limit !== 'all') {
                const limitNumber = Number(limit);
                if (Number.isFinite(limitNumber) && limitNumber > 0) {
                    entries = entries.slice(0, limitNumber);
                }
            }

            const labels = entries.map(entry => entry.owner);
            const values = entries.map(entry => entry.metricValue);
            const datasets = [
                {
                    label: metric === 'pipelineValue'
                        ? 'Активна воронка, ₴'
                        : metric === 'wonValue'
                            ? 'Виграно, ₴'
                            : metric === 'dealCount'
                                ? 'Кількість угод'
                                : 'Win rate, %',
                    data: values
                }
            ];

            const summaryParts = [];
            if (metric === 'pipelineValue' || metric === 'wonValue') {
                summaryParts.push(`У вибірці: ${formatCurrency(values.reduce((sum, value) => sum + value, 0))}`);
            } else if (metric === 'dealCount') {
                summaryParts.push(`У вибірці: ${formatIntegerDisplay(values.reduce((sum, value) => sum + value, 0))} угод`);
            } else {
                const averageWinRate = leads.reduce((acc, lead) => acc + (lead.stage === 'Угода' ? 1 : 0), 0);
                const lost = leads.reduce((acc, lead) => acc + (lead.stage === 'Втрачено' ? 1 : 0), 0);
                const denominator = averageWinRate + lost;
                const avgRate = denominator ? Math.round((averageWinRate / denominator) * 100) : 0;
                summaryParts.push(`Середній win rate: ${avgRate}%`);
            }
            const leader = entries[0];
            if (leader && leader.metricValue > 0) {
                if (metric === 'pipelineValue' || metric === 'wonValue') {
                    summaryParts.push(`Лідер: ${leader.owner} — ${formatCurrency(leader.metricValue)}`);
                } else if (metric === 'winRate') {
                    summaryParts.push(`Лідер: ${leader.owner} — ${formatIntegerDisplay(leader.metricValue)}%`);
                } else {
                    summaryParts.push(`Лідер: ${leader.owner} — ${formatIntegerDisplay(leader.metricValue)}`);
                }
            }

            return {
                labels,
                datasets,
                summary: summaryParts,
                empty: !entries.length,
                emptyMessage: 'Додайте угоди, щоб аналізувати результативність команди.'
            };
        }

        function computeTaskStatusDataset(crmData, chartConfig) {
            const tasks = Array.isArray(crmData?.tasks) ? crmData.tasks : [];
            if (!tasks.length) {
                return {
                    empty: true,
                    emptyMessage: 'Створіть хоча б одну задачу, щоб побачити розподіл.'
                };
            }

            const options = chartConfig?.datasetOptions || {};
            const groupBy = options.groupBy === 'priority' ? 'priority' : 'status';
            const includeDone = options.includeDone !== false;
            const onlyOverdue = options.onlyOverdue === true;
            const orientation = options.orientation === 'horizontal' ? 'horizontal' : 'vertical';

            let filtered = tasks.slice();
            if (!includeDone) {
                filtered = filtered.filter(task => task.status !== 'done');
            }
            if (onlyOverdue) {
                filtered = filtered.filter(task => isOverdue(task.dueDate));
            }

            if (!filtered.length) {
                return {
                    empty: true,
                    emptyMessage: 'За обраними умовами немає задач.'
                };
            }

            let groups = [];
            if (groupBy === 'priority') {
                groups = ['high', 'medium', 'low'].map(id => ({
                    id,
                    label: TASK_PRIORITY_LABELS[id] || id,
                    count: filtered.filter(task => task.priority === id).length
                }));
            } else {
                groups = TASK_COLUMNS.map(column => ({
                    id: column.id,
                    label: column.title,
                    count: filtered.filter(task => task.status === column.id).length
                }));
            }

            const total = groups.reduce((sum, group) => sum + group.count, 0);
            const labels = groups.map(group => group.label);
            const values = groups.map(group => group.count);

            const summaryParts = [`Усього задач: ${formatIntegerDisplay(total)}`];
            const overdueCount = filtered.filter(task => isOverdue(task.dueDate)).length;
            if (onlyOverdue) {
                summaryParts.push(`Прострочено: ${formatIntegerDisplay(overdueCount)}`);
            } else if (overdueCount > 0) {
                summaryParts.push(`Потребують уваги: ${formatIntegerDisplay(overdueCount)}`);
            }

            const optionsOverrides = {};
            if (chartConfig.chartType === 'bar' && orientation === 'horizontal') {
                optionsOverrides.indexAxis = 'y';
            }
            if (chartConfig.chartType === 'bar') {
                optionsOverrides.scales = {
                    x: { beginAtZero: true },
                    y: { beginAtZero: true }
                };
            }

            return {
                labels,
                datasets: [
                    {
                        label: 'Кількість задач',
                        data: values
                    }
                ],
                options: optionsOverrides,
                summary: summaryParts,
                empty: values.every(value => value === 0),
                emptyMessage: 'За обраними умовами немає задач.'
            };
        }

        function computeTaskOwnerWorkloadDataset(crmData, chartConfig) {
            const tasks = Array.isArray(crmData?.tasks) ? crmData.tasks : [];
            if (!tasks.length) {
                return {
                    empty: true,
                    emptyMessage: 'Додайте задачі, щоб побачити навантаження команди.'
                };
            }

            const options = chartConfig?.datasetOptions || {};
            const statusFilter = options.status || 'active';
            const limit = options.limit || 'all';
            const orientation = options.orientation === 'horizontal' ? 'horizontal' : 'vertical';

            let filtered = tasks.slice();
            if (statusFilter === 'active') {
                filtered = filtered.filter(task => task.status !== 'done');
            } else if (statusFilter === 'done') {
                filtered = filtered.filter(task => task.status === 'done');
            }

            if (!filtered.length) {
                return {
                    empty: true,
                    emptyMessage: 'За обраними умовами немає задач.'
                };
            }

            const ownerMap = new Map();
            filtered.forEach(task => {
                const owner = typeof task.owner === 'string' && task.owner.trim().length ? task.owner.trim() : 'Без відповідального';
                ownerMap.set(owner, (ownerMap.get(owner) || 0) + 1);
            });

            let entries = Array.from(ownerMap.entries()).map(([owner, count]) => ({ owner, count }));
            entries.sort((a, b) => b.count - a.count);

            if (limit !== 'all') {
                const limitNumber = Number(limit);
                if (Number.isFinite(limitNumber) && limitNumber > 0) {
                    entries = entries.slice(0, limitNumber);
                }
            }

            const labels = entries.map(entry => entry.owner);
            const values = entries.map(entry => entry.count);

            const summaryParts = [
                `У вибірці: ${formatIntegerDisplay(filtered.length)} задач`
            ];
            const top = entries[0];
            if (top) {
                summaryParts.push(`Найбільше у ${top.owner}: ${formatIntegerDisplay(top.count)}`);
            }

            const optionsOverrides = {};
            if (chartConfig.chartType === 'bar' && orientation === 'horizontal') {
                optionsOverrides.indexAxis = 'y';
            }
            if (chartConfig.chartType === 'bar') {
                optionsOverrides.scales = {
                    x: { beginAtZero: true },
                    y: { beginAtZero: true }
                };
            }

            return {
                labels,
                datasets: [
                    {
                        label: 'Кількість задач',
                        data: values
                    }
                ],
                options: optionsOverrides,
                summary: summaryParts,
                empty: !entries.length,
                emptyMessage: 'За обраними умовами немає задач.'
            };
        }

        function computeContactStatusDataset(crmData, chartConfig) {
            const contacts = Array.isArray(crmData?.contacts) ? crmData.contacts : [];
            if (!contacts.length) {
                return {
                    empty: true,
                    emptyMessage: 'Додайте контакти, щоб побачити розподіл за статусами.'
                };
            }

            const ownerFilter = chartConfig?.datasetOptions?.owner || 'all';
            const filtered = ownerFilter === 'all'
                ? contacts
                : contacts.filter(contact => contact.owner === ownerFilter);

            if (!filtered.length) {
                return {
                    empty: true,
                    emptyMessage: 'За обраним менеджером поки немає контактів.'
                };
            }

            const statusCounts = new Map(Object.keys(STATUS_LABELS).map(status => [status, 0]));
            filtered.forEach(contact => {
                const statusKey = statusCounts.has(contact.status) ? contact.status : (contact.status || 'potential');
                if (!statusCounts.has(statusKey)) {
                    statusCounts.set(statusKey, 0);
                }
                statusCounts.set(statusKey, (statusCounts.get(statusKey) || 0) + 1);
            });

            const entries = Array.from(statusCounts.entries()).filter(([, count]) => count > 0);
            if (!entries.length) {
                return {
                    empty: true,
                    emptyMessage: 'За обраними умовами немає контактів.'
                };
            }

            const labels = entries.map(([status]) => STATUS_LABELS[status] || status);
            const values = entries.map(([, count]) => count);

            const total = values.reduce((sum, value) => sum + value, 0);
            const mostCommonIndex = values.reduce((bestIndex, value, index, array) => {
                if (bestIndex === -1 || value > array[bestIndex]) {
                    return index;
                }
                return bestIndex;
            }, -1);

            const summaryParts = [`У базі: ${formatIntegerDisplay(total)} контактів`];
            if (mostCommonIndex >= 0 && values[mostCommonIndex] > 0) {
                summaryParts.push(`Найбільше статусів: ${labels[mostCommonIndex]}`);
            }
            if (ownerFilter !== 'all') {
                summaryParts.push(`Менеджер: ${ownerFilter}`);
            }

            return {
                labels,
                datasets: [
                    {
                        label: 'Контакти',
                        data: values
                    }
                ],
                summary: summaryParts,
                empty: total === 0,
                emptyMessage: 'За обраними умовами немає контактів.'
            };
        }

        function renderRoles() {
            renderRoleDefinitions();
            renderRoleAssignments();
            updateCustomRoleBaseOptions();
            updateCurrentUserBadge();
        }

        function renderRoleDefinitions() {
            const container = document.getElementById('roleDefinitionGrid');
            if (!container) {
                return;
            }

            const definitions = getAllRoleDefinitions();
            if (!definitions.length) {
                container.innerHTML = '<div class="empty-state">Немає визначених ролей. Додайте першу роль, щоб налаштувати доступ.</div>';
                return;
            }

            container.innerHTML = definitions.map(role => {
                const permissionsMarkup = role.permissions && role.permissions.length
                    ? `<ul class="role-permissions">${role.permissions.map(item => `<li>${escapeHtml(item)}</li>`).join('')}</ul>`
                    : '';
                const limitationsMarkup = role.limitations && role.limitations.length
                    ? `<div class="metric-sub">Обмеження: ${escapeHtml(role.limitations.join(', '))}</div>`
                    : '';
                const meta = role.custom
                    ? `<div class="metric-sub">Створено ${escapeHtml(role.createdBy)} • ${formatDate(role.createdAt)}</div>`
                    : '';
                return `
                    <div class="role-card">
                        <span class="role-badge"><i class="fa-solid fa-user-shield" aria-hidden="true"></i> ${escapeHtml(role.badge)}</span>
                        <h4>${escapeHtml(role.name)}</h4>
                        ${role.description ? `<p>${escapeHtml(role.description)}</p>` : ''}
                        ${permissionsMarkup}
                        ${limitationsMarkup}
                        ${meta}
                    </div>
                `;
            }).join('');
        }

        function renderRoleAssignments() {
            const container = document.getElementById('roleAssignmentsTable');
            if (!container) {
                return;
            }

            const assignments = crmData && crmData.roles && Array.isArray(crmData.roles.assignments)
                ? [...crmData.roles.assignments]
                : [];

            if (!assignments.length) {
                container.innerHTML = '<div class="empty-state">Додайте учасників команди для керування доступом.</div>';
                return;
            }

            assignments.sort((a, b) => a.name.localeCompare(b.name, 'uk'));

            const roles = getAllRoleDefinitions();
            const head = `
                <div class="role-row role-head">
                    <div>Учасник</div>
                    <div>Роль</div>
                    <div>Права доступу</div>
                </div>
            `;

            const rows = assignments.map(assignment => {
                const roleDefinition = getRoleDefinition(assignment.roleId);
                const combinedScopes = new Set();
                if (roleDefinition?.permissions?.length) {
                    roleDefinition.permissions.forEach(scope => combinedScopes.add(scope));
                }
                if (assignment.responsibilities?.length) {
                    assignment.responsibilities.forEach(scope => combinedScopes.add(scope));
                }
                const scopeMarkup = combinedScopes.size
                    ? `<div class="role-permission-tags">${Array.from(combinedScopes).slice(0, 6).map(scope => `<span class="role-permission-tag">${escapeHtml(scope)}</span>`).join('')}</div>`
                    : '<span class="metric-sub">Додайте сфери відповідальності</span>';

                const limitationMarkup = roleDefinition?.limitations?.length
                    ? `<div class="metric-sub">Обмеження: ${escapeHtml(roleDefinition.limitations[0])}${roleDefinition.limitations.length > 1 ? '…' : ''}</div>`
                    : '';

                const metaParts = [];
                if (assignment.updatedAt) {
                    metaParts.push(`Оновлено ${escapeHtml(formatRelativeTime(assignment.updatedAt))}`);
                }
                if (assignment.updatedBy) {
                    metaParts.push(escapeHtml(assignment.updatedBy));
                }
                const meta = metaParts.length ? `<div class="metric-sub">${metaParts.join(' • ')}</div>` : '';
                const note = assignment.note ? `<div class="metric-sub">${escapeHtml(assignment.note)}</div>` : '';

                const memberMetaParts = [];
                if (assignment.title) memberMetaParts.push(assignment.title);
                if (assignment.department) memberMetaParts.push(assignment.department);
                if (assignment.email) memberMetaParts.push(assignment.email);
                const memberMeta = memberMetaParts.length ? `<span class="role-meta">${escapeHtml(memberMetaParts.join(' • '))}</span>` : '';

                const options = roles.map(role => {
                    const disabled = role.id === 'owner' && assignment.name === CURRENT_USER.name && CURRENT_USER.role !== 'owner';
                    const selected = role.id === assignment.roleId ? 'selected' : '';
                    return `<option value="${role.id}" ${selected} ${disabled ? 'disabled' : ''}>${escapeHtml(role.name)}</option>`;
                }).join('');
                const hasCurrentRole = roles.some(role => role.id === assignment.roleId);
                const fallbackOption = hasCurrentRole
                    ? ''
                    : `<option value="${escapeHtml(assignment.roleId)}" selected>${escapeHtml(getRoleLabel(assignment.roleId))}</option>`;

                const initials = getInitials(assignment.name);
                const disabledAttr = assignment.locked ? 'disabled' : '';
                const selectLabel = `aria-label="Змінити роль для ${escapeHtml(assignment.name)}"`;

                return `
                    <div class="role-row">
                        <div class="role-member">
                            <div class="avatar avatar-sm">${escapeHtml(initials)}</div>
                            <div class="role-member-details">
                                <strong>${escapeHtml(assignment.name)}</strong>
                                ${memberMeta}
                            </div>
                        </div>
                        <div>
                            <select data-role-assignment="${assignment.id}" ${selectLabel} ${disabledAttr}>
                                ${fallbackOption}${options}
                            </select>
                            ${assignment.roleId === 'owner' ? '<div class="metric-sub">Єдиний власник акаунту</div>' : ''}
                        </div>
                        <div>
                            ${scopeMarkup}
                            ${limitationMarkup}
                            ${meta}
                            ${note}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = head + rows;

            container.querySelectorAll('select[data-role-assignment]').forEach(select => {
                const assignmentId = select.dataset.roleAssignment;
                const assignment = crmData.roles.assignments.find(item => item.id === assignmentId);
                if (assignment) {
                    select.dataset.currentRole = assignment.roleId;
                }
                select.addEventListener('change', event => {
                    handleRoleAssignmentChange(assignmentId, event.target.value, event.target);
                });
            });
        }

        function handleRoleAssignmentChange(assignmentId, newRoleId, selectElement) {
            const assignments = crmData && crmData.roles && Array.isArray(crmData.roles.assignments)
                ? crmData.roles.assignments
                : [];
            const assignment = assignments.find(item => item.id === assignmentId);

            if (!assignment || !newRoleId || assignment.roleId === newRoleId) {
                if (selectElement && assignment) {
                    selectElement.value = assignment.roleId;
                }
                return;
            }

            if (newRoleId === 'owner' && assignment.name === CURRENT_USER.name && CURRENT_USER.role !== 'owner') {
                alert('Менеджери не можуть самостійно призначити собі роль Owner. Зверніться до поточного власника.');
                if (selectElement) {
                    selectElement.value = assignment.roleId;
                }
                return;
            }

            if (assignment.roleId === 'owner' && newRoleId !== 'owner') {
                const otherOwnerExists = assignments.some(item => item.roleId === 'owner' && item.id !== assignment.id);
                if (!otherOwnerExists) {
                    alert('У системі має залишатися хоча б один власник. Спочатку передайте роль іншому користувачу.');
                    if (selectElement) {
                        selectElement.value = assignment.roleId;
                    }
                    return;
                }
            }

            if (newRoleId === 'owner') {
                const currentOwner = assignments.find(item => item.roleId === 'owner');
                if (currentOwner && currentOwner.id !== assignment.id) {
                    const confirmTransfer = confirm(`Передати роль Owner від ${currentOwner.name} до ${assignment.name}?`);
                    if (!confirmTransfer) {
                        if (selectElement) {
                            selectElement.value = assignment.roleId;
                        }
                        return;
                    }
                    currentOwner.roleId = 'manager';
                    currentOwner.updatedAt = new Date().toISOString();
                    currentOwner.updatedBy = CURRENT_USER.name;
                    logActivity(`Роль ${currentOwner.name} змінена на ${getRoleLabel('manager')} після передачі Owner.`, 'role', currentOwner.id);
                }
            }

            assignment.roleId = newRoleId;
            assignment.updatedAt = new Date().toISOString();
            assignment.updatedBy = CURRENT_USER.name;

            if (assignment.name === CURRENT_USER.name) {
                CURRENT_USER.role = newRoleId;
            }

            logActivity(`Роль ${assignment.name} змінена на ${getRoleLabel(newRoleId)}.`, 'role', assignment.id);
            saveData();
            renderRoles();
            renderActivityTimeline();
        }

        function handleCustomRoleSubmit(event) {
            event.preventDefault();
            const form = event.target;
            const nameInput = document.getElementById('customRoleName');
            const baseSelect = document.getElementById('customRoleBase');
            const notesInput = document.getElementById('customRoleNotes');

            const name = nameInput ? nameInput.value.trim() : '';
            if (!name) {
                return;
            }

            const baseRoleId = baseSelect ? baseSelect.value : 'manager';
            const additionalNotes = notesInput
                ? notesInput.value.split('\n').map(note => note.trim()).filter(Boolean)
                : [];

            const allRoles = getAllRoleDefinitions();
            if (allRoles.some(role => role.name.toLowerCase() === name.toLowerCase())) {
                alert('Роль з такою назвою вже існує. Оберіть іншу назву.');
                return;
            }

            const baseRole = getRoleDefinition(baseRoleId);
            const permissions = baseRole && Array.isArray(baseRole.permissions)
                ? [...baseRole.permissions]
                : [];
            additionalNotes.forEach(note => {
                if (!permissions.includes(note)) {
                    permissions.push(note);
                }
            });

            const limitations = baseRole && Array.isArray(baseRole.limitations)
                ? [...baseRole.limitations]
                : [];

            const normalizedRole = normalizeRoleDefinition({
                id: generateId('role'),
                name,
                badge: name,
                description: baseRole ? `На основі ${baseRole.name}.` : 'Індивідуальна роль для вашої команди.',
                permissions,
                limitations,
                baseRoleId,
                createdAt: new Date().toISOString(),
                createdBy: CURRENT_USER.name,
                custom: true
            }, true);

            crmData.roles.customRoles.push(normalizedRole);
            logActivity(`Створено нову роль ${name}.`, 'role', normalizedRole.id);
            saveData();
            renderRoles();
            renderActivityTimeline();
            form.reset();
            updateCustomRoleBaseOptions();
            if (nameInput) {
                nameInput.focus();
            }
        }

        function renderForecastCard(pipelineValue, expectedRevenue) {
            const container = document.getElementById('forecastCard');
            const target = 200000;
            const coverage = Math.min(100, Math.round((pipelineValue / target) * 100));
            const weighted = Math.round(expectedRevenue);
            const topDeals = crmData.leads
                .filter(lead => lead.stage !== 'Втрачено')
                .sort((a, b) => b.value - a.value)
                .slice(0, 3);

            container.innerHTML = `
                <div class="highlight-card">
                    <div class="highlight-label">Покриття цілі</div>
                    <div class="highlight-value">${coverage}%</div>
                    <div class="metric-sub">Поточна мета: ${formatCurrency(target)}</div>
                </div>
                <div class="divider"></div>
                <div class="metric-sub">Очікуваний дохід за ймовірностями</div>
                <h2 style="margin: 6px 0 14px;">${formatCurrency(weighted)}</h2>
                <div class="metric-sub">ТОП-угоди</div>
                <div class="timeline-list">
                    ${topDeals.map(lead => `
                        <div class="timeline-entry">
                            <strong>${lead.name}</strong>
                            <span>${lead.company} • ${formatCurrency(lead.value)} • ${lead.probability}%</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        function renderPipeline() {
            const board = document.getElementById('pipelineBoard');
            const leads = pipelineFilterOwner === 'all' ? crmData.leads : crmData.leads.filter(lead => lead.owner === pipelineFilterOwner);
            if (!board) {
                return;
            }

            board.innerHTML = STAGES.map(stage => {
                const stageLeads = leads.filter(lead => lead.stage === stage);
                const stageValue = stageLeads.reduce((sum, lead) => sum + lead.value, 0);
                return `
                    <div class="pipeline-column" data-stage="${stage}">
                        <div class="column-head">
                            <h4>${stage}</h4>
                            <div class="column-meta">
                                <span>${stageLeads.length} угод</span>
                                <span>${formatCurrency(stageValue)}</span>
                            </div>
                        </div>
                        <div class="column-body" data-drop-zone>
                            ${stageLeads.length ? stageLeads.map(createDealCard).join('') : `<div class="empty-state">Немає угод</div>`}
                        </div>
                    </div>
                `;
            }).join('');

            renderPipelineMetrics(leads);
            renderPipelineStageStatus(leads);
            renderPipelinePriority(leads);
            renderPipelineOwnerSummary(leads);
            renderPipelineActivity(leads);
            setupPipelineInteractions();
        }

        function renderPipelineMetrics(leads) {
            const container = document.getElementById('pipelineMetrics');
            if (!container) {
                return;
            }

            const now = new Date();
            const activeLeads = leads.filter(lead => lead.stage !== 'Втрачено');
            const totalValue = activeLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0), 0);
            const expectedRevenue = activeLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0) * ((Number(lead.probability) || 0) / 100), 0);
            const averageProbability = activeLeads.length
                ? Math.round(activeLeads.reduce((sum, lead) => sum + (Number(lead.probability) || 0), 0) / activeLeads.length)
                : 0;
            const averageAge = activeLeads.length
                ? Math.round(activeLeads.reduce((sum, lead) => {
                    const baseDate = lead.createdAt || lead.updatedAt || now;
                    return sum + daysBetween(baseDate, now);
                }, 0) / activeLeads.length)
                : 0;
            const dueSoon = activeLeads.filter(lead => {
                if (!lead.expectedClose) {
                    return false;
                }
                const dueDate = new Date(lead.expectedClose);
                if (Number.isNaN(dueDate.getTime())) {
                    return false;
                }
                const diff = Math.ceil((dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                return diff >= 0 && diff <= 7;
            }).length;
            const won = leads.filter(lead => lead.stage === 'Угода').length;
            const lost = leads.filter(lead => lead.stage === 'Втрачено').length;
            const winRate = won + lost ? Math.round((won / (won + lost)) * 100) : (averageProbability || 0);
            const averageAgeLabel = activeLeads.length ? `~${averageAge} дн.` : '—';
            const dueSoonLabel = dueSoon ? `${dueSoon} закриттів протягом 7 днів` : 'Немає закриттів за 7 днів';

            container.innerHTML = `
                <div class="metric-card">
                    <div class="metric-icon">
                        <i class="fa-solid fa-briefcase"></i>
                    </div>
                    <div>
                        <div class="metric-label">Активні угоди</div>
                        <div class="metric-value">${activeLeads.length}</div>
                        <div class="metric-sub">${leads.length} угод у вибірці</div>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">
                        <i class="fa-solid fa-sack-dollar"></i>
                    </div>
                    <div>
                        <div class="metric-label">Вартість воронки</div>
                        <div class="metric-value">${formatCurrency(totalValue)}</div>
                        <div class="metric-sub">${formatCurrency(expectedRevenue)} прогнозовано</div>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">
                        <i class="fa-solid fa-gauge-high"></i>
                    </div>
                    <div>
                        <div class="metric-label">Середня ймовірність</div>
                        <div class="metric-value">${averageProbability}%</div>
                        <div class="metric-sub">Win-rate ${winRate}%</div>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">
                        <i class="fa-solid fa-calendar-check"></i>
                    </div>
                    <div>
                        <div class="metric-label">Середній вік угоди</div>
                        <div class="metric-value">${averageAgeLabel}</div>
                        <div class="metric-sub">${dueSoonLabel}</div>
                    </div>
                </div>
            `;
        }

        function renderPipelineStageStatus(leads) {
            const container = document.getElementById('pipelineStageStatus');
            if (!container) {
                return;
            }

            const now = new Date();
            const activeLeads = leads.filter(lead => lead.stage !== 'Втрачено');
            const totalValue = activeLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0), 0);

            const rows = STAGES.filter(stage => stage !== 'Втрачено').map(stage => {
                const stageLeads = leads.filter(lead => lead.stage === stage);
                const stageValue = stageLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0), 0);
                const valueShare = totalValue
                    ? Math.round((stageValue / totalValue) * 100)
                    : (activeLeads.length ? Math.round((stageLeads.length / activeLeads.length) * 100) : 0);
                const averageIdle = stageLeads.length
                    ? Math.round(stageLeads.reduce((sum, lead) => sum + daysBetween(lead.updatedAt || lead.createdAt || now, now), 0) / stageLeads.length)
                    : 0;
                const stuck = stageLeads.filter(lead => daysBetween(lead.updatedAt || lead.createdAt || now, now) > 10).length;
                const width = stageLeads.length ? Math.max(valueShare, 6) : 2;
                const shareLabel = totalValue ? `${valueShare}% вартості` : `${stageLeads.length} угод`;
                const averageIdleLabel = stageLeads.length ? `${averageIdle} дн.` : '—';
                const riskBadge = stuck
                    ? `<span class="stage-risk"><i class="fa-solid fa-triangle-exclamation"></i> Застигло ${stuck}</span>`
                    : '';

                return `
                    <div class="stage-row">
                        <div class="stage-info">
                            <div class="stage-name">${stage}</div>
                            <div class="stage-meta">${stageLeads.length} угод • ${formatCurrency(stageValue)}</div>
                            ${riskBadge}
                        </div>
                        <div class="stage-progress">
                            <div class="stage-share">${shareLabel}</div>
                            <div class="stage-progress-track"><span class="stage-progress-value" style="width:${Math.min(100, width)}%"></span></div>
                            <span>Середнє очікування: ${averageIdleLabel}</span>
                        </div>
                    </div>
                `;
            });

            const lostLeads = leads.filter(lead => lead.stage === 'Втрачено');
            if (lostLeads.length) {
                const lostValue = lostLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0), 0);
                const lostShare = leads.length ? Math.round((lostLeads.length / leads.length) * 100) : 0;
                const lostWidth = lostLeads.length ? Math.max(lostShare, 6) : 0;
                rows.push(`
                    <div class="stage-row">
                        <div class="stage-info">
                            <div class="stage-name">Втрачено</div>
                            <div class="stage-meta">${lostLeads.length} угод • ${formatCurrency(lostValue)}</div>
                            <span class="stage-risk stage-risk-danger"><i class="fa-solid fa-circle-xmark"></i> Потрібен аналіз</span>
                        </div>
                        <div class="stage-progress">
                            <div class="stage-share">${lostShare}% угод</div>
                            <div class="stage-progress-track"><span class="stage-progress-value" style="width:${Math.min(100, lostWidth)}%"></span></div>
                            <span>Втрачено: ${formatCurrency(lostValue)}</span>
                        </div>
                    </div>
                `);
            }

            container.innerHTML = rows.join('');
        }

        function renderPipelinePriority(leads) {
            const container = document.getElementById('pipelinePriorityList');
            if (!container) {
                return;
            }

            const now = new Date();
            const items = leads
                .filter(lead => !['Втрачено', 'Угода'].includes(lead.stage))
                .map(lead => {
                    const idleDays = daysBetween(lead.updatedAt || lead.createdAt || now, now);
                    const dueDate = lead.expectedClose ? new Date(lead.expectedClose) : null;
                    let dueDiff = null;
                    if (dueDate && !Number.isNaN(dueDate.getTime())) {
                        dueDiff = Math.ceil((dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                    }
                    const openTasks = crmData.tasks.filter(task => task.relatedLeadId === lead.id && task.status !== 'done');
                    const flags = [];
                    let score = 0;
                    const readinessScore = Math.max(0, Math.min(100, Number(lead.score) || 0));

                    if (typeof dueDiff === 'number') {
                        if (dueDiff < 0) {
                            score += 3;
                            flags.push({ type: 'danger', text: `Прострочено на ${Math.abs(dueDiff)} дн.` });
                        } else if (dueDiff <= 7) {
                            score += 2;
                            const dueText = dueDiff === 0 ? 'Закриття сьогодні' : `Закриття за ${dueDiff} дн.`;
                            flags.push({ type: 'warning', text: dueText });
                        }
                    }

                    if (idleDays > 10) {
                        score += 2;
                        flags.push({ type: 'warning', text: `Без оновлень ${idleDays} дн.` });
                    }

                    if ((Number(lead.probability) || 0) < 30) {
                        score += 1;
                        flags.push({ type: 'info', text: `Ймовірність ${lead.probability}%` });
                    }

                    if ((Number(lead.value) || 0) >= 80000) {
                        score += 1;
                        flags.push({ type: 'info', text: 'Висока вартість' });
                    }

                    if (readinessScore >= 80 && (STAGE_INDEX[lead.stage] ?? 0) < (STAGE_INDEX['Переговори'] ?? 3)) {
                        score += 1;
                        flags.push({ type: 'info', text: `Готовність ${readinessScore}%` });
                    }

                    if (openTasks.length) {
                        flags.push({ type: 'info', text: `Задач: ${openTasks.length}` });
                    }

                    return { lead, score, flags, idleDays };
                })
                .filter(item => item.score > 0 || item.flags.length > 0)
                .sort((a, b) => b.score - a.score || (Number(b.lead.value) || 0) - (Number(a.lead.value) || 0))
                .slice(0, 4);

            if (!items.length) {
                container.innerHTML = '<div class="empty-state">Усі угоди в комфортній зоні. Слідкуйте за новими змінами.</div>';
                return;
            }

            container.innerHTML = items.map(item => {
                const flagsMarkup = item.flags.map(flag => `<span class="priority-flag ${flag.type}">${flag.text}</span>`).join('');
                const manager = item.lead.owner ? `Менеджер: ${item.lead.owner}` : 'Менеджер не призначений';
                const idleText = item.idleDays > 0 ? ` • без оновлень ${item.idleDays} дн.` : '';
                return `
                    <div class="priority-item">
                        <div class="priority-header">
                            <div>
                                <div class="priority-title">${item.lead.name}</div>
                                <div class="priority-meta">${item.lead.company || 'Без компанії'} • ${item.lead.stage}</div>
                            </div>
                            <span class="badge badge-primary">${formatCurrency(Number(item.lead.value) || 0)}</span>
                        </div>
                        ${flagsMarkup ? `<div class="priority-flags">${flagsMarkup}</div>` : ''}
                        <div class="priority-meta">${manager}${idleText}</div>
                        <div class="priority-actions">
                            <button class="btn btn-small-primary" data-open-lead="${item.lead.id}">Перейти</button>
                        </div>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('[data-open-lead]').forEach(btn => {
                btn.addEventListener('click', () => openLeadDetails(btn.dataset.openLead));
            });
        }

        function renderPipelineOwnerSummary(leads) {
            const container = document.getElementById('pipelineOwnerSummary');
            if (!container) {
                return;
            }

            const ownerMap = new Map();
            leads.forEach(lead => {
                const ownerName = lead.owner || 'Без менеджера';
                if (!ownerMap.has(ownerName)) {
                    ownerMap.set(ownerName, {
                        owner: ownerName,
                        leads: 0,
                        value: 0,
                        probabilitySum: 0,
                        won: 0,
                        lost: 0
                    });
                }

                const entry = ownerMap.get(ownerName);
                entry.leads += 1;
                entry.value += Number(lead.value) || 0;
                entry.probabilitySum += Number(lead.probability) || 0;
                if (lead.stage === 'Угода') {
                    entry.won += 1;
                }
                if (lead.stage === 'Втрачено') {
                    entry.lost += 1;
                }
            });

            const stats = Array.from(ownerMap.values()).map(entry => {
                const openTasks = crmData.tasks.filter(task => task.owner === entry.owner && task.status !== 'done').length;
                const avgProbability = entry.leads ? Math.round(entry.probabilitySum / entry.leads) : 0;
                const winRate = entry.won + entry.lost ? Math.round((entry.won / (entry.won + entry.lost)) * 100) : avgProbability;
                return {
                    ...entry,
                    avgProbability,
                    winRate,
                    openTasks
                };
            }).sort((a, b) => b.value - a.value);

            if (!stats.length) {
                container.innerHTML = '<div class="empty-state">Немає даних для відображення.</div>';
                return;
            }

            container.innerHTML = stats.map(entry => {
                const avatarLetter = entry.owner ? entry.owner.charAt(0).toUpperCase() : '?';
                const progressWidth = entry.avgProbability > 0 ? Math.max(entry.avgProbability, 6) : 0;
                return `
                    <div class="owner-row">
                        <div class="owner-info">
                            <div class="avatar">${avatarLetter}</div>
                            <div>
                                <strong>${entry.owner}</strong>
                                <div class="metric-sub">${entry.leads} угод • ${formatCurrency(entry.value)}</div>
                            </div>
                        </div>
                        <div class="owner-metrics">
                            <div class="owner-progress-track"><span class="owner-progress-value" style="width:${Math.min(100, progressWidth)}%"></span></div>
                            <div class="metric-sub">Середня ймовірність ${entry.avgProbability}%</div>
                            <div class="metric-sub">Win-rate ${entry.winRate}%</div>
                            <div class="metric-sub">Активних задач: ${entry.openTasks}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPipelineActivity(leads) {
            const container = document.getElementById('pipelineActivityTimeline');
            if (!container) {
                return;
            }

            const leadIds = new Set(leads.map(lead => lead.id));
            const relevantActivities = crmData.activities
                .filter(activity => ['stage', 'note', 'won', 'lost'].includes(activity.type))
                .filter(activity => leadIds.has(activity.entityId))
                .slice(0, 8);

            if (!relevantActivities.length) {
                container.innerHTML = '<div class="empty-state">Поки немає нових подій по воронці.</div>';
                return;
            }

            container.innerHTML = relevantActivities.map(activity => `
                <div class="timeline-entry">
                    <strong>${escapeHtml(activity.message)}</strong>
                    <span>${formatRelativeTime(activity.timestamp)}</span>
                </div>
            `).join('');
        }

        function renderProjects(searchTerm = '') {
            const container = document.getElementById('projectsTable');
            if (!container) {
                return;
            }

            projectSearchTerm = typeof searchTerm === 'string' ? searchTerm : '';
            const normalizedSearch = projectSearchTerm.trim().toLowerCase();

            const searchInput = document.getElementById('projectSearch');
            if (searchInput && searchInput.value !== projectSearchTerm) {
                searchInput.value = projectSearchTerm;
            }

            const stageSelect = document.getElementById('projectStageFilter');
            if (stageSelect && stageSelect.value !== projectStageFilter) {
                stageSelect.value = projectStageFilter;
            }

            const probabilityRange = document.getElementById('projectProbabilityRange');
            if (probabilityRange && Number(probabilityRange.value) !== projectMinProbability) {
                probabilityRange.value = projectMinProbability;
            }

            const probabilityLabel = document.getElementById('projectProbabilityValue');
            if (probabilityLabel) {
                probabilityLabel.textContent = `${projectMinProbability}%+`;
            }

            let projects = Array.isArray(crmData.projects) ? [...crmData.projects] : [];

            if (projectStageFilter !== 'all') {
                projects = projects.filter(project => project.stage === projectStageFilter);
            }

            projects = projects.filter(project => {
                const probability = Math.max(0, Math.min(100, Number(project.probability) || 0));
                return probability >= projectMinProbability;
            });

            if (normalizedSearch) {
                projects = projects.filter(project => {
                    const haystack = [
                        project.name,
                        project.company,
                        project.owner,
                        project.contact,
                        project.stage,
                        Array.isArray(project.tags) ? project.tags.join(' ') : '',
                        Array.isArray(project.team) ? project.team.join(' ') : '',
                        project.description
                    ];
                    return haystack
                        .filter(Boolean)
                        .some(value => value.toLowerCase().includes(normalizedSearch));
                });
            }

            projects.sort((a, b) => {
                const dateA = new Date(a.updatedAt || a.createdAt || 0).getTime();
                const dateB = new Date(b.updatedAt || b.createdAt || 0).getTime();
                return dateB - dateA;
            });

            renderProjectMetrics(projects);
            renderProjectStageBreakdown(projects);
            renderProjectRiskList(projects);
            renderProjectTeamLoad(projects);
            renderProjectUpdates(projects);

            if (!projects.length) {
                container.innerHTML = '<div class="empty-state" style="padding: 32px;">Проекти за вказаними фільтрами не знайдені.</div>';
                return;
            }

            container.innerHTML = projects.map(project => {
                const probability = Math.max(0, Math.min(100, Math.round(Number(project.probability) || 0)));
                const probabilityClass = getProbabilityClass(probability);
                const stageBadgeClass = getProjectStageBadgeClass(project.stage);
                const updatedLabel = project.updatedAt
                    ? `Оновлено ${formatRelativeTime(project.updatedAt)}`
                    : 'Оновлено щойно';
                const tags = project.tags && project.tags.length
                    ? `<div class="project-tags">${project.tags.map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('')}</div>`
                    : '';
                const description = project.description
                    ? `<div class="metric-sub">${escapeHtml(project.description)}</div>`
                    : '';
                const attachmentsCount = Array.isArray(project.attachments) ? project.attachments.length : 0;
                const notesCount = Array.isArray(project.notes) ? project.notes.length : 0;
                const indicatorParts = [];
                if (attachmentsCount) {
                    indicatorParts.push(`<span class="chip"><i class="fa-solid fa-paperclip"></i> ${attachmentsCount}</span>`);
                }
                if (notesCount) {
                    indicatorParts.push(`<span class="chip"><i class="fa-solid fa-note-sticky"></i> ${notesCount}</span>`);
                }
                const indicatorMarkup = indicatorParts.length ? `<div class="chips">${indicatorParts.join('')}</div>` : '';
                const teamContent = project.team && project.team.length
                    ? `<div class="project-team">${project.team.map(member => `<span class="project-member-chip">${escapeHtml(member)}</span>`).join('')}</div>`
                    : '<span class="metric-sub">Не призначено</span>';
                const ownerName = project.owner && project.owner.trim().length ? project.owner.trim() : 'Не призначено';
                const ownerInitial = ownerName === 'Не призначено' ? '—' : ownerName.charAt(0);
                const contactName = project.contact && project.contact.trim().length ? project.contact.trim() : 'Без контакту';

                return `
                    <div class="table-row" data-project-id="${project.id}">
                        <div class="project-main">
                            <strong>${escapeHtml(project.name)}</strong>
                            ${project.company ? `<div class="project-sub">${escapeHtml(project.company)}</div>` : ''}
                            ${description}
                            <div class="project-updated">${escapeHtml(updatedLabel)}</div>
                            ${tags}
                            ${indicatorMarkup}
                        </div>
                        <div>${teamContent}</div>
                        <div><strong>${formatCurrency(project.budget)}</strong></div>
                        <div><span class="badge ${stageBadgeClass}">${escapeHtml(project.stage)}</span></div>
                        <div>
                            <div class="probability-pill ${probabilityClass}" style="--fill:${probability}%" data-value="${probability}">
                                <span>${probability}%</span>
                            </div>
                        </div>
                        <div>
                            <div class="project-owner">
                                <div class="avatar avatar-sm">${escapeHtml(ownerInitial)}</div>
                                <div>
                                    <strong>${escapeHtml(ownerName)}</strong>
                                    <span>${escapeHtml(contactName)}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderProjectMetrics(projects) {
            const container = document.getElementById('projectMetrics');
            if (!container) {
                return;
            }

            if (!projects.length) {
                container.innerHTML = '<div class="empty-state" style="grid-column: 1 / -1;">Немає проектів для аналітики.</div>';
                return;
            }

            let totalBudget = 0;
            let probabilitySum = 0;
            let activeProjects = 0;
            let recentUpdates = 0;
            let highProbability = 0;
            let totalTeamMembers = 0;
            const uniqueContributors = new Set();
            const now = new Date();

            projects.forEach(project => {
                const budget = Number(project.budget) || 0;
                const probability = Math.max(0, Math.min(100, Number(project.probability) || 0));
                totalBudget += budget;
                probabilitySum += probability;

                if (probability >= 70) {
                    highProbability += 1;
                }

                const stageNormalized = (project.stage || '').toLowerCase();
                if (!stageNormalized.includes('архів') && !stageNormalized.includes('заверш') && !stageNormalized.includes('підтрим')) {
                    activeProjects += 1;
                }

                const updatedAt = project.updatedAt ? new Date(project.updatedAt) : null;
                if (updatedAt && !Number.isNaN(updatedAt.getTime())) {
                    const diffDays = Math.round((now.getTime() - updatedAt.getTime()) / (1000 * 60 * 60 * 24));
                    if (diffDays <= 7) {
                        recentUpdates += 1;
                    }
                }

                const memberSet = new Set();
                const owner = typeof project.owner === 'string' ? project.owner.trim() : '';
                if (owner) {
                    memberSet.add(owner);
                    uniqueContributors.add(owner);
                }
                if (Array.isArray(project.team)) {
                    project.team.forEach(member => {
                        const normalized = typeof member === 'string' ? member.trim() : String(member || '').trim();
                        if (normalized) {
                            memberSet.add(normalized);
                            uniqueContributors.add(normalized);
                        }
                    });
                }
                totalTeamMembers += memberSet.size;
            });

            const averageProbability = projects.length ? Math.round(probabilitySum / projects.length) : 0;
            const averageBudget = projects.length ? totalBudget / projects.length : 0;
            const avgTeamSize = projects.length ? totalTeamMembers / projects.length : 0;
            const avgTeamFormatted = avgTeamSize
                ? new Intl.NumberFormat('uk-UA', { maximumFractionDigits: 1, minimumFractionDigits: 1 }).format(avgTeamSize)
                : '0,0';

            container.innerHTML = `
                <div class="metric-card">
                    <div class="metric-icon"><i class="fa-solid fa-briefcase"></i></div>
                    <div>
                        <div class="metric-label">Проекти в роботі</div>
                        <div class="metric-value">${formatIntegerDisplay(activeProjects)}</div>
                        <div class="metric-sub">Оновлено за 7 днів: ${formatIntegerDisplay(recentUpdates)}</div>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon"><i class="fa-solid fa-sack-dollar"></i></div>
                    <div>
                        <div class="metric-label">Портфель, ₴</div>
                        <div class="metric-value">${formatCurrency(totalBudget)}</div>
                        <div class="metric-sub">Середній бюджет: ${formatCurrency(averageBudget)}</div>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon"><i class="fa-solid fa-bullseye"></i></div>
                    <div>
                        <div class="metric-label">Середня ймовірність</div>
                        <div class="metric-value">${averageProbability}%</div>
                        <div class="metric-sub">≥70% шансів: ${formatIntegerDisplay(highProbability)}</div>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon"><i class="fa-solid fa-users"></i></div>
                    <div>
                        <div class="metric-label">Учасники команд</div>
                        <div class="metric-value">${formatIntegerDisplay(uniqueContributors.size)}</div>
                        <div class="metric-sub">Середній склад: ${avgTeamFormatted} ос.</div>
                    </div>
                </div>
            `;
        }

        function renderProjectStageBreakdown(projects) {
            const container = document.getElementById('projectStageBreakdown');
            if (!container) {
                return;
            }

            if (!projects.length) {
                container.innerHTML = '<div class="empty-state">Немає проектів для відображення.</div>';
                return;
            }

            const stageMap = new Map();
            projects.forEach(project => {
                const stageLabel = project.stage && project.stage.trim().length ? project.stage.trim() : 'Без етапу';
                if (!stageMap.has(stageLabel)) {
                    stageMap.set(stageLabel, { count: 0, budget: 0, probabilitySum: 0 });
                }
                const stats = stageMap.get(stageLabel);
                stats.count += 1;
                stats.budget += Number(project.budget) || 0;
                stats.probabilitySum += Number(project.probability) || 0;
            });

            const total = projects.length;
            const stageEntries = Array.from(stageMap.entries()).sort((a, b) => b[1].count - a[1].count);

            container.innerHTML = stageEntries.map(([stageLabel, stats]) => {
                const share = Math.round((stats.count / total) * 100);
                const avgProbability = stats.count ? Math.round(stats.probabilitySum / stats.count) : 0;
                const progressWidth = share <= 0 ? 0 : Math.max(8, Math.min(share, 100));
                return `
                    <div class="project-stage-row">
                        <div class="project-stage-info">
                            <strong>${escapeHtml(stageLabel)}</strong>
                            <span class="metric-sub">${formatIntegerDisplay(stats.count)} проєктів • ${formatCurrency(stats.budget, true)}</span>
                        </div>
                        <div class="project-stage-progress">
                            <div class="project-stage-track"><span class="project-stage-fill" style="width:${progressWidth}%"></span></div>
                            <span class="metric-sub">${share}%</span>
                        </div>
                        <span class="project-stage-chip">Сер. ймовірність ${avgProbability}%</span>
                    </div>
                `;
            }).join('');
        }

        function renderProjectRiskList(projects) {
            const container = document.getElementById('projectRiskList');
            if (!container) {
                return;
            }

            if (!projects.length) {
                container.innerHTML = '<div class="empty-state">Немає ризикових проектів за поточними фільтрами.</div>';
                return;
            }

            const risks = projects.map(project => {
                const probability = Math.max(0, Math.min(100, Number(project.probability) || 0));
                const updatedAt = project.updatedAt ? new Date(project.updatedAt) : null;
                const daysWithoutUpdate = updatedAt && !Number.isNaN(updatedAt.getTime())
                    ? Math.max(0, Math.round((Date.now() - updatedAt.getTime()) / (1000 * 60 * 60 * 24)))
                    : null;

                const memberSet = new Set();
                const owner = typeof project.owner === 'string' ? project.owner.trim() : '';
                if (owner) {
                    memberSet.add(owner);
                }
                if (Array.isArray(project.team)) {
                    project.team.forEach(member => {
                        const normalized = typeof member === 'string' ? member.trim() : String(member || '').trim();
                        if (normalized) {
                            memberSet.add(normalized);
                        }
                    });
                }

                const flags = [];
                if (probability < 40) {
                    flags.push({ label: 'Низька ймовірність', level: 'critical' });
                }
                if (daysWithoutUpdate !== null && daysWithoutUpdate > 10) {
                    flags.push({
                        label: `Без оновлень ${daysWithoutUpdate} дн.`,
                        level: daysWithoutUpdate > 20 ? 'critical' : 'warning'
                    });
                }
                if (memberSet.size <= 1) {
                    flags.push({ label: 'Немає команди', level: 'warning' });
                }

                const severity = flags.reduce((score, flag) => score + (flag.level === 'critical' ? 2 : 1), 0);

                return {
                    project,
                    probability,
                    flags,
                    severity,
                    updatedAt
                };
            }).filter(item => item.flags.length > 0);

            if (!risks.length) {
                container.innerHTML = '<div class="empty-state">Активні проекти виглядають стабільно.</div>';
                return;
            }

            risks.sort((a, b) => {
                if (b.severity !== a.severity) {
                    return b.severity - a.severity;
                }
                if (a.probability !== b.probability) {
                    return a.probability - b.probability;
                }
                const timeA = a.updatedAt ? a.updatedAt.getTime() : 0;
                const timeB = b.updatedAt ? b.updatedAt.getTime() : 0;
                return timeA - timeB;
            });

            const topRisks = risks.slice(0, 4);

            container.innerHTML = topRisks.map(item => {
                const { project, probability, flags, severity } = item;
                const ownerName = project.owner && project.owner.trim().length ? project.owner.trim() : 'Без менеджера';
                const company = project.company && project.company.trim().length ? project.company.trim() : 'Без компанії';
                const updateLabel = project.updatedAt
                    ? (formatRelativeTime(project.updatedAt) || formatDate(project.updatedAt))
                    : 'Немає даних';
                const itemClass = severity >= 4 ? 'critical' : 'warning';

                const flagsMarkup = flags.map(flag => {
                    const classes = ['project-risk-flag'];
                    if (flag.level === 'critical') {
                        classes.push('is-critical');
                    }
                    if (flag.level === 'warning') {
                        classes.push('is-warning');
                    }
                    return `<span class="${classes.join(' ')}">${escapeHtml(flag.label)}</span>`;
                }).join('');

                return `
                    <div class="project-risk-item ${itemClass}">
                        <div class="project-risk-head">
                            <div>
                                <strong>${escapeHtml(project.name)}</strong>
                                <div class="metric-sub">${escapeHtml(company)}</div>
                            </div>
                            <span class="project-risk-score">${probability}%</span>
                        </div>
                        <div class="project-risk-flags">${flagsMarkup}</div>
                        <div class="project-risk-meta">
                            <span><i class="fa-regular fa-user"></i>${escapeHtml(ownerName)}</span>
                            <span><i class="fa-regular fa-clock"></i>${escapeHtml(updateLabel)}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderProjectTeamLoad(projects) {
            const container = document.getElementById('projectTeamLoad');
            if (!container) {
                return;
            }

            if (!projects.length) {
                container.innerHTML = '<div class="empty-state">Немає призначень за поточними умовами.</div>';
                return;
            }

            const memberMap = new Map();

            projects.forEach(project => {
                const members = new Set();
                const owner = typeof project.owner === 'string' ? project.owner.trim() : '';
                if (owner) {
                    members.add(owner);
                }
                if (Array.isArray(project.team)) {
                    project.team.forEach(member => {
                        const normalized = typeof member === 'string' ? member.trim() : String(member || '').trim();
                        if (normalized) {
                            members.add(normalized);
                        }
                    });
                }

                members.forEach(member => {
                    if (!memberMap.has(member)) {
                        memberMap.set(member, {
                            name: member,
                            projects: 0,
                            budget: 0,
                            probabilitySum: 0
                        });
                    }
                    const entry = memberMap.get(member);
                    entry.projects += 1;
                    entry.budget += Number(project.budget) || 0;
                    entry.probabilitySum += Number(project.probability) || 0;
                });
            });

            const entries = Array.from(memberMap.values());
            if (!entries.length) {
                container.innerHTML = '<div class="empty-state">Немає учасників для відображення.</div>';
                return;
            }

            const maxProjects = entries.reduce((max, entry) => Math.max(max, entry.projects), 0) || 1;

            entries.forEach(entry => {
                entry.avgProbability = entry.projects ? Math.round(entry.probabilitySum / entry.projects) : 0;
            });

            entries.sort((a, b) => {
                if (b.projects !== a.projects) {
                    return b.projects - a.projects;
                }
                return b.budget - a.budget;
            });

            const rows = entries.slice(0, 5).map(entry => {
                const workloadPercent = Math.round((entry.projects / maxProjects) * 100);
                const fillWidth = entry.projects ? Math.max(12, Math.min(100, workloadPercent)) : 0;
                const initials = entry.name ? entry.name.charAt(0).toUpperCase() : '?';
                return `
                    <div class="project-team-row">
                        <div class="avatar avatar-sm">${escapeHtml(initials)}</div>
                        <div class="project-team-info">
                            <strong>${escapeHtml(entry.name)}</strong>
                            <span class="metric-sub">${formatIntegerDisplay(entry.projects)} проєктів • ${formatCurrency(entry.budget, true)}</span>
                        </div>
                        <div class="project-team-progress">
                            <div class="project-team-progress-track"><span class="project-team-progress-fill" style="width:${fillWidth}%"></span></div>
                            <span class="metric-sub">Сер. ймовірність ${entry.avgProbability}%</span>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = rows;
        }

        function renderProjectUpdates(projects) {
            const container = document.getElementById('projectUpdates');
            const counter = document.getElementById('projectUpdatesCount');
            if (!container) {
                if (counter) {
                    counter.textContent = '0 записів';
                }
                return;
            }

            if (!projects.length) {
                container.innerHTML = '<div class="empty-state">Додайте проект або зніміть фільтри, щоб бачити оновлення.</div>';
                if (counter) {
                    counter.textContent = '0 записів';
                }
                return;
            }

            const updates = [];

            projects.forEach(project => {
                const notes = Array.isArray(project.notes) ? project.notes : [];
                if (notes.length) {
                    notes.forEach(note => {
                        const author = typeof note.author === 'string' && note.author.trim().length
                            ? note.author.trim()
                            : (project.owner || 'CRM');
                        updates.push({
                            projectName: project.name,
                            company: project.company,
                            text: note.text,
                            author,
                            date: note.date || project.updatedAt || project.createdAt
                        });
                    });
                } else if (project.updatedAt) {
                    updates.push({
                        projectName: project.name,
                        company: project.company,
                        text: 'Статус проекту оновлено.',
                        author: project.owner || 'CRM',
                        date: project.updatedAt
                    });
                }
            });

            updates.sort((a, b) => {
                const timeA = new Date(a.date || 0).getTime();
                const timeB = new Date(b.date || 0).getTime();
                return timeB - timeA;
            });

            const topUpdates = updates.slice(0, 6);

            if (!topUpdates.length) {
                container.innerHTML = '<div class="empty-state">Немає активності по проектах.</div>';
                if (counter) {
                    counter.textContent = '0 записів';
                }
                return;
            }

            container.innerHTML = topUpdates.map(update => {
                const projectName = typeof update.projectName === 'string' ? update.projectName : 'Проект';
                const company = typeof update.company === 'string' && update.company.trim().length ? update.company.trim() : '';
                const companyMarkup = company ? `<div class="metric-sub">${escapeHtml(company)}</div>` : '';
                const description = typeof update.text === 'string' && update.text.trim().length
                    ? escapeHtml(update.text.trim())
                    : 'Без опису';
                const author = typeof update.author === 'string' && update.author.trim().length ? update.author.trim() : 'CRM';
                const relative = update.date ? formatRelativeTime(update.date) : '';
                const absolute = update.date ? formatDate(update.date) : '';
                const timeLabel = relative || absolute || '—';

                return `
                    <div class="project-update-item">
                        <div class="project-update-bullet" aria-hidden="true"></div>
                        <div class="project-update-body">
                            <div>
                                <strong>${escapeHtml(projectName)}</strong>
                                ${companyMarkup}
                            </div>
                            <p>${description}</p>
                            <div class="project-update-footer">
                                <span><i class="fa-regular fa-user"></i>${escapeHtml(author)}</span>
                                <span><i class="fa-regular fa-clock"></i>${escapeHtml(timeLabel)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            if (counter) {
                counter.textContent = `${formatIntegerDisplay(updates.length)} записів`;
            }
        }

        function getProjectStageBadgeClass(stage) {
            const normalized = (stage || '').toLowerCase();
            if (normalized.includes('запуск') || normalized.includes('підтрим')) {
                return 'badge-success';
            }
            if (normalized.includes('тест')) {
                return 'badge-info';
            }
            if (normalized.includes('розроб') || normalized.includes('в роботі')) {
                return 'badge-primary';
            }
            if (normalized.includes('план')) {
                return 'badge-neutral';
            }
            if (normalized.includes('discovery') || normalized.includes('ініціа')) {
                return 'badge-warning';
            }
            return 'badge-neutral';
        }

        function getProbabilityClass(probability) {
            if (probability >= 70) {
                return 'is-high';
            }
            if (probability < 40) {
                return 'is-low';
            }
            return '';
        }

        function focusProject(projectId) {
            if (!projectId) {
                return;
            }

            const navButton = document.querySelector(`.nav-item[data-section-target="projectsSection"]`);
            if (navButton) {
                navButton.click();
            } else {
                document.querySelectorAll('.section').forEach(section => section.classList.remove('active'));
                const targetSection = document.getElementById('projectsSection');
                if (targetSection) {
                    targetSection.classList.add('active');
                }
            }

            requestAnimationFrame(() => {
                const row = document.querySelector(`[data-project-id="${projectId}"]`);
                if (!row) {
                    return;
                }
                document.querySelectorAll('[data-project-id]').forEach(item => item.classList.remove('row-highlight'));
                row.classList.add('row-highlight');
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }

        function createDealCard(lead) {
            const tags = Array.isArray(lead.tags) ? lead.tags.filter(Boolean) : [];
            const stageClass = lead.stage === 'Угода' ? 'badge-success' : lead.stage === 'Втрачено' ? 'badge-danger' : 'badge-warning';
            const ownerName = lead.owner && lead.owner.trim().length ? lead.owner.trim() : 'Не призначено';
            const contactPieces = [];
            if (lead.company) {
                contactPieces.push(`<span><i class="fa-regular fa-building"></i> ${escapeHtml(lead.company)}</span>`);
            }
            if (lead.contact?.person) {
                contactPieces.push(`<span><i class="fa-regular fa-user"></i> ${escapeHtml(lead.contact.person)}</span>`);
            }
            const expectedClose = lead.expectedClose ? formatDate(lead.expectedClose, { day: '2-digit', month: 'short' }) : '—';
            const forecastValue = formatCurrency(Math.round((Number(lead.value) || 0) * ((Number(lead.probability) || 0) / 100)));
            const readiness = Math.max(0, Math.min(100, Number(lead.score) || 0));
            const badges = [];
            const sourceLabel = getLeadSourceLabel(lead.source);
            if (sourceLabel) {
                badges.push(`<span class="deal-badge">${escapeHtml(sourceLabel)}</span>`);
            }
            const qualificationLabel = getLeadQualificationLabel(lead.qualification);
            if (qualificationLabel) {
                badges.push(`<span class="deal-badge badge-outline">${escapeHtml(qualificationLabel)}</span>`);
            }
            tags.forEach(tag => {
                badges.push(`<span class="deal-badge">${escapeHtml(tag)}</span>`);
            });

            return `
                <div class="deal-card" draggable="true" data-lead-id="${lead.id}">
                    <div class="deal-card-top">
                        <span class="deal-stage ${stageClass}">${escapeHtml(lead.stage)}</span>
                        <span class="deal-updated">${formatRelativeTime(lead.updatedAt)}</span>
                    </div>
                    <div class="deal-title">${escapeHtml(lead.name)}</div>
                    <div class="deal-owner-row">
                        <div class="deal-owner">
                            <div class="avatar avatar-sm">${escapeHtml(getInitials(ownerName))}</div>
                            <div>
                                <strong>${escapeHtml(ownerName)}</strong>
                                <div class="deal-owner-sub">Менеджер угоди</div>
                            </div>
                        </div>
                    </div>
                    <div class="deal-meta-line">
                        ${contactPieces.join('')}
                    </div>
                    <div class="deal-info-grid">
                        <div class="deal-info">
                            <span class="deal-info-label">Вартість</span>
                            <span class="deal-info-value">${formatCurrency(lead.value)}</span>
                        </div>
                        <div class="deal-info">
                            <span class="deal-info-label">Ймовірність</span>
                            <span class="deal-info-value">${formatIntegerDisplay(lead.probability)}%</span>
                        </div>
                        <div class="deal-info">
                            <span class="deal-info-label">Очікуване закриття</span>
                            <span class="deal-info-value">${escapeHtml(expectedClose)}</span>
                        </div>
                        <div class="deal-info">
                            <span class="deal-info-label">Прогнозовано</span>
                            <span class="deal-info-value">${forecastValue}</span>
                        </div>
                    </div>
                    <div class="deal-card-bottom">
                        <div class="deal-badges">${badges.join('')}</div>
                        <div class="deal-readiness" aria-label="Готовність до купівлі ${readiness}%">
                            <span class="deal-readiness-label">Готовність</span>
                            <div class="deal-readiness-bar"><span style="width:${readiness}%"></span></div>
                            <span class="deal-readiness-value">${readiness}%</span>
                        </div>
                    </div>
                </div>
            `;
        }

        let draggedLeadId = null;

        function setupPipelineInteractions() {
            document.querySelectorAll('.deal-card').forEach(card => {
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragend', handleDragEnd);
                card.addEventListener('click', () => openLeadDetails(card.dataset.leadId));
            });

            document.querySelectorAll('[data-drop-zone]').forEach(zone => {
                zone.addEventListener('dragover', handleDragOver);
                zone.addEventListener('dragleave', handleDragLeave);
                zone.addEventListener('drop', handleDrop);
            });
        }

        function handleDragStart(event) {
            draggedLeadId = event.currentTarget.dataset.leadId;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', draggedLeadId);
        }

        function handleDragEnd() {
            draggedLeadId = null;
            document.querySelectorAll('[data-drop-zone]').forEach(zone => zone.classList.remove('drop-active'));
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('drop-active');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('drop-active');
        }

        function handleDrop(event) {
            event.preventDefault();
            const stage = event.currentTarget.closest('.pipeline-column').dataset.stage;
            event.currentTarget.classList.remove('drop-active');
            const leadId = draggedLeadId || event.dataTransfer.getData('text/plain');
            if (leadId) {
                moveLeadToStage(leadId, stage);
            }
            draggedLeadId = null;
        }
        function updateContactTagOptions() {
            const datalist = document.getElementById('contactTagOptions');
            if (!datalist) {
                return;
            }

            const tags = new Set();
            if (Array.isArray(crmData?.contacts)) {
                crmData.contacts.forEach(contact => {
                    if (Array.isArray(contact.tags)) {
                        contact.tags.forEach(tag => {
                            if (typeof tag === 'string') {
                                const normalized = tag.trim();
                                if (normalized.length) {
                                    tags.add(normalized);
                                }
                            }
                        });
                    }
                });
            }

            const options = Array.from(tags)
                .sort((a, b) => a.localeCompare(b, 'uk', { sensitivity: 'base' }))
                .map(tag => `<option value="${escapeHtml(tag)}">`)
                .join('');
            datalist.innerHTML = options;
        }

        function normalizeContactChannel(value, fallback = 'system') {
            if (typeof value !== 'string') {
                return fallback;
            }

            const normalized = value.trim().toLowerCase();
            if (!normalized.length) {
                return fallback;
            }

            if (CONTACT_CHANNEL_LABELS[normalized]) {
                return normalized;
            }

            if (CONTACT_CHANNEL_ALIASES[normalized]) {
                return CONTACT_CHANNEL_ALIASES[normalized];
            }

            return fallback;
        }

        function normalizeToISOString(value) {
            if (value instanceof Date) {
                return value.toISOString();
            }

            if (typeof value === 'number' && Number.isFinite(value)) {
                const date = new Date(value);
                return Number.isNaN(date.getTime()) ? '' : date.toISOString();
            }

            if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed.length) {
                    return '';
                }
                if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
                    return `${trimmed}T00:00:00.000Z`;
                }
                const date = new Date(trimmed);
                return Number.isNaN(date.getTime()) ? '' : date.toISOString();
            }

            return '';
        }

        function getContactTimeline(contact) {
            if (!contact) {
                return [];
            }

            const events = [];
            const seen = new Set();

            const addEvent = (interaction, fallbackAuthor, origin, extraTags = []) => {
                const normalized = normalizeContactInteraction(interaction, fallbackAuthor);
                if (!normalized) {
                    return;
                }

                if (!normalized.timestamp) {
                    return;
                }

                const key = `${normalized.id}|${normalized.timestamp}`;
                if (seen.has(key)) {
                    return;
                }

                const tagSet = new Set(
                    Array.isArray(normalized.tags)
                        ? normalized.tags
                            .filter(tag => typeof tag === 'string' && tag.trim().length)
                            .map(tag => tag.trim())
                        : []
                );
                extraTags.forEach(tag => {
                    if (typeof tag === 'string' && tag.trim().length) {
                        tagSet.add(tag.trim());
                    }
                });
                normalized.tags = Array.from(tagSet);
                normalized.origin = origin;
                seen.add(key);
                events.push(normalized);
            };

            if (Array.isArray(contact.interactions)) {
                contact.interactions.forEach(interaction => {
                    addEvent(interaction, contact.owner, 'contact', ['Контакт']);
                });
            }

            if (Array.isArray(contact.notes)) {
                contact.notes.forEach(note => {
                    const timestamp = normalizeToISOString(note.date);
                    if (!timestamp) {
                        return;
                    }
                    addEvent(
                        {
                            id: note.id,
                            type: 'note',
                            channel: 'system',
                            subject: 'Нотатка профілю',
                            summary: note.text,
                            timestamp,
                            author: note.author
                        },
                        note.author || contact.owner,
                        'contact-note',
                        ['Профіль']
                    );
                });
            }

            const normalizedEmail = (typeof contact.email === 'string' ? contact.email : '').trim().toLowerCase();
            const normalizedCompany = (typeof contact.company === 'string' ? contact.company : '').trim().toLowerCase();
            const normalizedName = (typeof contact.name === 'string' ? contact.name : '').trim().toLowerCase();

            const leads = Array.isArray(crmData?.leads) ? crmData.leads : [];
            const relatedLeads = leads.filter(lead => {
                if (!lead || typeof lead !== 'object') {
                    return false;
                }
                const leadContact = lead.contact || {};
                const leadContactId = typeof leadContact.id === 'string' ? leadContact.id : '';
                const leadEmail = typeof leadContact.email === 'string' ? leadContact.email.trim().toLowerCase() : '';
                const leadCompany = typeof lead.company === 'string' ? lead.company.trim().toLowerCase() : '';
                const leadName = typeof leadContact.person === 'string' ? leadContact.person.trim().toLowerCase() : '';
                return (
                    (leadContactId && leadContactId === contact.id) ||
                    (normalizedEmail && leadEmail && leadEmail === normalizedEmail) ||
                    (normalizedCompany && leadCompany && leadCompany === normalizedCompany) ||
                    (normalizedName && leadName && leadName === normalizedName)
                );
            });

            const relatedLeadIds = new Set(relatedLeads.map(lead => lead.id).filter(Boolean));

            relatedLeads.forEach(lead => {
                const leadLabel = lead.name || lead.company || contact.company || 'Угода';
                const leadTag = `Угода: ${leadLabel}`;
                if (Array.isArray(lead.timeline)) {
                    lead.timeline.forEach(item => {
                        const timestamp = normalizeToISOString(item.date || item.timestamp);
                        if (!timestamp) {
                            return;
                        }
                        addEvent(
                            {
                                id: item.id || generateId('cact'),
                                type: 'update',
                                channel: 'system',
                                subject: `Оновлення угоди ${leadLabel}`,
                                summary: item.text || `Оновлено статус угоди ${leadLabel}.`,
                                timestamp,
                                author: item.author || lead.owner,
                                tags: ['Угода']
                            },
                            lead.owner,
                            'lead-timeline',
                            [leadTag]
                        );
                    });
                }

                if (Array.isArray(lead.notes)) {
                    lead.notes.forEach(note => {
                        const timestamp = normalizeToISOString(note.date);
                        if (!timestamp) {
                            return;
                        }
                        addEvent(
                            {
                                id: note.id || generateId('cact'),
                                type: 'note',
                                channel: 'system',
                                subject: `Нотатка: ${leadLabel}`,
                                summary: note.text,
                                timestamp,
                                author: note.author,
                                tags: ['Угода']
                            },
                            note.author || lead.owner,
                            'lead-note',
                            [leadTag]
                        );
                    });
                }
            });

            const tasks = Array.isArray(crmData?.tasks) ? crmData.tasks : [];
            tasks.forEach(task => {
                if (!task || typeof task !== 'object') {
                    return;
                }
                const matchesLead = task.relatedLeadId && relatedLeadIds.has(task.relatedLeadId);
                const matchesContact = task.relatedContactId && task.relatedContactId === contact.id;
                if (!matchesLead && !matchesContact) {
                    return;
                }
                const lead = matchesLead ? relatedLeads.find(item => item.id === task.relatedLeadId) : null;
                const leadLabel = lead ? (lead.name || lead.company || contact.company || 'Угода') : '';
                const timestamp =
                    normalizeToISOString(task.completedAt) ||
                    normalizeToISOString(task.dueDate) ||
                    normalizeToISOString(task.createdAt);
                if (!timestamp) {
                    return;
                }
                const summaryParts = [
                    `Статус: ${TASK_STATUS_LABELS[task.status] || task.status}`,
                    `Пріоритет: ${TASK_PRIORITY_LABELS[task.priority] || task.priority}`
                ];
                if (task.dueDate) {
                    summaryParts.push(`Дедлайн: ${formatDate(task.dueDate)}`);
                }
                if (matchesContact && !matchesLead) {
                    summaryParts.push(`Контакт: ${contact.name || 'контакт'}`);
                }
                if (leadLabel) {
                    summaryParts.push(`Угода: ${leadLabel}`);
                }
                const summary = summaryParts.join('. ');
                const extraTags = ['Завдання'];
                if (matchesContact) {
                    extraTags.push('Контакт');
                }
                if (leadLabel) {
                    extraTags.push(`Угода: ${leadLabel}`);
                }
                addEvent(
                    {
                        id: task.id,
                        type: 'task',
                        channel: 'system',
                        subject: `Завдання: ${task.title}`,
                        summary,
                        timestamp,
                        author: task.owner,
                        tags: ['Завдання']
                    },
                    task.owner,
                    'task',
                    extraTags
                );
            });

            const tickets = Array.isArray(crmData?.supportTickets) ? crmData.supportTickets : [];
            tickets.forEach(ticket => {
                if (!ticket || typeof ticket !== 'object') {
                    return;
                }
                const client = typeof ticket.client === 'string' ? ticket.client.trim().toLowerCase() : '';
                if (!client || (client !== normalizedCompany && client !== normalizedName)) {
                    return;
                }
                const timestamp =
                    normalizeToISOString(ticket.resolvedAt) ||
                    normalizeToISOString(ticket.firstResponseAt) ||
                    normalizeToISOString(ticket.createdAt);
                if (!timestamp) {
                    return;
                }
                const channel = normalizeContactChannel(ticket.channel, 'portal');
                const summaryParts = [
                    `Статус: ${SUPPORT_STATUS_LABELS[ticket.status] || ticket.status}`,
                    `Пріоритет: ${SUPPORT_PRIORITY_LABELS[ticket.priority] || ticket.priority}`
                ];
                if (ticket.owner) {
                    summaryParts.push(`Відповідальний: ${ticket.owner}`);
                }
                addEvent(
                    {
                        id: ticket.id,
                        type: 'ticket',
                        channel,
                        subject: `Запит підтримки: ${ticket.subject}`,
                        summary: summaryParts.join('. '),
                        timestamp,
                        author: ticket.owner || 'Служба підтримки',
                        tags: ['Підтримка']
                    },
                    ticket.owner || 'Служба підтримки',
                    'support-ticket',
                    ['Підтримка']
                );
            });

            const parseEventTime = value => {
                if (!value) {
                    return 0;
                }
                const date = new Date(value);
                return Number.isNaN(date.getTime()) ? 0 : date.getTime();
            };

            events.sort((a, b) => parseEventTime(b.timestamp) - parseEventTime(a.timestamp));
            return events;
        }

        function renderContacts(searchTerm = '') {
            const container = document.getElementById('contactsTable');
            if (!container) {
                return;
            }

            updateContactTagOptions();

            const query = searchTerm.trim().toLowerCase();
            let contacts = Array.isArray(crmData?.contacts) ? crmData.contacts.slice() : [];

            if (contactStatusFilter !== 'all') {
                contacts = contacts.filter(contact => contact.status === contactStatusFilter
                    || (Array.isArray(contact.segments) && contact.segments.includes(contactStatusFilter)));
            }

            if (contactTagFilter.length) {
                contacts = contacts.filter(contact => {
                    const tagSet = new Set((Array.isArray(contact.tags) ? contact.tags : []).map(tag => tag.toLowerCase()));
                    return contactTagFilter.every(tag => tagSet.has(tag));
                });
            }

            if (query) {
                contacts = contacts.filter(contact => {
                    const haystack = [
                        contact.name,
                        contact.company,
                        contact.email,
                        contact.phone,
                        contact.role,
                        CONTACT_LIFECYCLE_LABELS[contact.lifecycleStage] || contact.lifecycleStage,
                        CONTACT_CHANNEL_LABELS[contact.preferredChannel] || contact.preferredChannel,
                        contact.owner,
                        contact.address?.street,
                        contact.address?.city,
                        contact.address?.country,
                        ...(Array.isArray(contact.tags) ? contact.tags : []),
                        ...(Array.isArray(contact.segments)
                            ? contact.segments.map(segment => STATUS_LABELS[segment] || segment)
                            : [])
                    ]
                        .filter(Boolean)
                        .join(' ')
                        .toLowerCase();
                    return haystack.includes(query);
                });
            }

            const activityCache = new Map();
            contacts.forEach(contact => {
                const timeline = getContactTimeline(contact);
                const lastTimestamp = timeline.length
                    ? timeline[0].timestamp
                    : normalizeToISOString(contact.lastActivity);
                activityCache.set(contact.id, {
                    timeline,
                    lastTimestamp,
                });
            });

            const getActivityTimestamp = contact => {
                const info = activityCache.get(contact.id);
                const timestamp = info && info.lastTimestamp ? info.lastTimestamp : normalizeToISOString(contact.lastActivity);
                const date = timestamp ? new Date(timestamp) : null;
                return date && !Number.isNaN(date.getTime()) ? date.getTime() : 0;
            };

            contacts.sort((a, b) => getActivityTimestamp(b) - getActivityTimestamp(a));

            if (!contacts.length) {
                container.innerHTML = '<div class="empty-state" style="padding: 32px;">Немає контактів за обраними фільтрами.</div>';
                renderContactDetails(null, activityCache);
                return;
            }

            if (!contacts.some(contact => contact.id === activeContactId)) {
                activeContactId = contacts[0].id;
            }

            container.innerHTML = contacts.map(contact => {
                const statusClass = `status-${contact.status}`;
                const tags = Array.isArray(contact.tags) && contact.tags.length
                    ? contact.tags.map(tag => `<span class="chip">${escapeHtml(tag)}</span>`).join('')
                    : '';
                const attachmentsCount = Array.isArray(contact.attachments) ? contact.attachments.length : 0;
                const notesCount = Array.isArray(contact.notes) ? contact.notes.length : 0;
                const activity = activityCache.get(contact.id) || {
                    timeline: [],
                    lastTimestamp: normalizeToISOString(contact.lastActivity),
                };
                const interactionsCount = activity.timeline.length;
                const lastActivityLabel = activity.lastTimestamp ? formatRelativeTime(activity.lastTimestamp) : '';
                const extras = [];
                if (lastActivityLabel) {
                    extras.push(`<span class="chip chip-ghost"><i class="fa-regular fa-clock"></i> ${escapeHtml(lastActivityLabel)}</span>`);
                }
                if (attachmentsCount) {
                    extras.push(`<span class="chip"><i class="fa-solid fa-paperclip"></i> ${attachmentsCount}</span>`);
                }
                if (notesCount) {
                    extras.push(`<span class="chip"><i class="fa-solid fa-note-sticky"></i> ${notesCount}</span>`);
                }
                if (interactionsCount) {
                    extras.push(`<span class="chip chip-ghost"><i class="fa-solid fa-comments"></i> ${interactionsCount}</span>`);
                }
                const hasAutomationSync = contact.automation
                    && ((Array.isArray(contact.automation.autoUpdate?.emailInboxes)
                        && contact.automation.autoUpdate.emailInboxes.length)
                        || (Array.isArray(contact.automation.autoUpdate?.webForms)
                            && contact.automation.autoUpdate.webForms.length));
                if (hasAutomationSync) {
                    extras.push('<span class="chip chip-ghost"><i class="fa-solid fa-arrows-rotate"></i> Автосинхронізація</span>');
                }
                const extrasMarkup = extras.length ? `<div class="chips" style="margin-top:6px;">${extras.join('')}</div>` : '';
                const segmentChips = Array.isArray(contact.segments)
                    ? contact.segments
                        .filter(segment => segment !== contact.status)
                        .map(segment => `<span class="chip chip-accent">${escapeHtml(STATUS_LABELS[segment] || segment)}</span>`)
                        .join('')
                    : '';
                const segmentsMarkup = segmentChips ? `<div class="chips" style="margin-top:6px;">${segmentChips}</div>` : '';
                const infoParts = [];
                if (contact.role) {
                    infoParts.push(contact.role);
                }
                const lifecycleLabel = CONTACT_LIFECYCLE_LABELS[contact.lifecycleStage] || '';
                if (lifecycleLabel) {
                    infoParts.push(lifecycleLabel);
                }
                const infoMarkup = infoParts.length ? `<span class="contact-sub">${infoParts.map(part => escapeHtml(part)).join(' • ')}</span>` : '';
                const locationParts = [contact.address?.city, contact.address?.country].filter(Boolean);
                const locationMarkup = locationParts.length ? `<span class="contact-sub">${escapeHtml(locationParts.join(', '))}</span>` : '';
                const ownerDisplay = contact.owner ? escapeHtml(contact.owner) : 'Не призначено';
                const ownerActivity = lastActivityLabel ? `<div class="metric-sub">Останній контакт: ${escapeHtml(lastActivityLabel)}</div>` : '';
                const emailDisplay = contact.email ? escapeHtml(contact.email) : '';
                const phoneDisplay = contact.phone ? escapeHtml(contact.phone) : '';

                return `
                    <div class="table-row${contact.id === activeContactId ? ' is-active' : ''}" data-contact-id="${contact.id}">
                        <div class="contact-main">
                            <div class="avatar">${getInitials(contact.name)}</div>
                            <div class="contact-info">
                                <strong>${escapeHtml(contact.name)}</strong>
                                ${infoMarkup}
                                ${locationMarkup}
                            </div>
                        </div>
                        <div>${escapeHtml(contact.company || '')}</div>
                        <div>${emailDisplay}</div>
                        <div>${phoneDisplay}</div>
                        <div>
                            <span class="status-badge ${statusClass}">${STATUS_LABELS[contact.status] || contact.status}</span>
                            ${segmentsMarkup}
                            ${tags ? `<div class="chips" style="margin-top:6px;">${tags}</div>` : ''}
                            ${extrasMarkup}
                        </div>
                        <div>${ownerDisplay}${ownerActivity}</div>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('.table-row').forEach(row => {
                row.addEventListener('click', () => {
                    activeContactId = row.dataset.contactId;
                    container.querySelectorAll('.table-row').forEach(item => item.classList.remove('is-active'));
                    row.classList.add('is-active');
                    renderContactDetails(activeContactId, activityCache);
                });
            });

            renderContactDetails(activeContactId, activityCache);
        }

        function renderContactAutomation(automation) {
            if (!automation || typeof automation !== 'object') {
                return '';
            }

            const sections = [];

            const mapStatus = (status, type) => {
                const normalized = typeof status === 'string' ? status.trim().toLowerCase() : '';
                if (type === 'form') {
                    switch (normalized) {
                        case 'active':
                            return 'Активна';
                        case 'paused':
                            return 'Призупинено';
                        case 'inactive':
                            return 'Неактивна';
                        default:
                            return normalized.length ? normalized : 'Активна';
                    }
                }
                switch (normalized) {
                    case 'connected':
                        return 'Підключено';
                    case 'disconnected':
                        return 'Відключено';
                    case 'syncing':
                        return 'Синхронізується';
                    case 'error':
                        return 'Помилка';
                    default:
                        return normalized.length ? normalized : 'Підключено';
                }
            };

            const mapProviderStatus = status => {
                const normalized = typeof status === 'string' ? status.trim().toLowerCase() : '';
                switch (normalized) {
                    case 'active':
                        return 'Активний';
                    case 'paused':
                        return 'Призупинено';
                    case 'inactive':
                        return 'Неактивний';
                    case 'trial':
                        return 'Пробний режим';
                    default:
                        return normalized.length ? normalized : 'Активний';
                }
            };

            const autoUpdateItems = [];
            const emailInboxes = Array.isArray(automation.autoUpdate?.emailInboxes)
                ? automation.autoUpdate.emailInboxes
                : [];
            emailInboxes.forEach(inbox => {
                if (!inbox || typeof inbox !== 'object' || !inbox.label) {
                    return;
                }
                const details = [];
                details.push(mapStatus(inbox.status, 'email'));
                if (inbox.provider) {
                    details.push(`Платформа: ${inbox.provider}`);
                }
                if (Number.isFinite(inbox.newRecords) && inbox.newRecords > 0) {
                    details.push(`${inbox.newRecords} нових записів`);
                }
                const syncRelative = formatRelativeTime(inbox.lastSync);
                if (syncRelative) {
                    details.push(`синхр. ${syncRelative}`);
                }
                const detailText = details.map(value => escapeHtml(value)).join(' • ');
                autoUpdateItems.push(`
                    <li><strong>${escapeHtml(inbox.label)}</strong>${detailText ? ` — ${detailText}` : ''}</li>
                `);
            });

            const webForms = Array.isArray(automation.autoUpdate?.webForms)
                ? automation.autoUpdate.webForms
                : [];
            webForms.forEach(form => {
                if (!form || typeof form !== 'object' || !form.label) {
                    return;
                }
                const details = [];
                details.push(mapStatus(form.status, 'form'));
                if (Number.isFinite(form.newRecords) && form.newRecords > 0) {
                    details.push(`${form.newRecords} нових заявок`);
                }
                const syncRelative = formatRelativeTime(form.lastSync);
                if (syncRelative) {
                    details.push(`синхр. ${syncRelative}`);
                }
                const detailText = details.map(value => escapeHtml(value)).join(' • ');
                autoUpdateItems.push(`
                    <li>Форма «${escapeHtml(form.label)}»${detailText ? ` — ${detailText}` : ''}</li>
                `);
            });

            if (autoUpdateItems.length) {
                sections.push(`
                    <div class="contact-automation-item">
                        <div class="contact-automation-icon"><i class="fa-solid fa-arrows-rotate"></i></div>
                        <div>
                            <h4>Автоматичне оновлення даних</h4>
                            <p>Імпорт з електронних скриньок і веб-форм за рекомендаціями Discover CRM (discovercrm.com) оновлює картку клієнта без ручного введення.</p>
                            <ul class="contact-automation-meta">${autoUpdateItems.join('')}</ul>
                        </div>
                    </div>
                `);
            }

            const enrichmentItems = [];
            const enrichmentProviders = Array.isArray(automation.enrichment?.providers)
                ? automation.enrichment.providers
                : [];
            enrichmentProviders.forEach(provider => {
                if (!provider || typeof provider !== 'object' || !provider.name) {
                    return;
                }
                const details = [];
                const statusLabel = mapProviderStatus(provider.status);
                if (statusLabel) {
                    details.push(statusLabel);
                }
                if (Array.isArray(provider.fields) && provider.fields.length) {
                    details.push(`Поля: ${provider.fields.join(', ')}`);
                }
                const refreshRelative = formatRelativeTime(provider.lastRefresh);
                if (refreshRelative) {
                    details.push(`оновлено ${refreshRelative}`);
                }
                const detailText = details.map(value => escapeHtml(value)).join(' • ');
                enrichmentItems.push(`
                    <li><strong>${escapeHtml(provider.name)}</strong>${detailText ? ` — ${detailText}` : ''}</li>
                `);
            });

            const enrichmentFields = Array.isArray(automation.enrichment?.fields)
                ? automation.enrichment.fields.filter(field => typeof field === 'string' && field.trim().length)
                : [];
            if (enrichmentFields.length) {
                enrichmentItems.push(`
                    <li><strong>Збагачені поля:</strong> ${escapeHtml(enrichmentFields.join(', '))}</li>
                `);
            }

            if (enrichmentItems.length) {
                sections.push(`
                    <div class="contact-automation-item">
                        <div class="contact-automation-icon"><i class="fa-solid fa-wand-magic-sparkles"></i></div>
                        <div>
                            <h4>Збагачення профілю</h4>
                            <p>API-інтеграції з бізнес-довідниками та маркетинговими платформами (Discover CRM) додають галузь, розмір компанії та соціальні профілі без зайвої ручної роботи.</p>
                            <ul class="contact-automation-meta">${enrichmentItems.join('')}</ul>
                        </div>
                    </div>
                `);
            }

            const communicationItems = [];
            const callLog = automation.communicationLog?.calls;
            if (callLog) {
                const details = [];
                details.push(callLog.recordings ? 'Записи та теги збережені' : 'Без записів');
                if (Number.isFinite(callLog.loggedCount) && callLog.loggedCount > 0) {
                    details.push(`${callLog.loggedCount} дзвінків`);
                }
                if (Array.isArray(callLog.tags) && callLog.tags.length) {
                    details.push(`Теги: ${callLog.tags.join(', ')}`);
                }
                if (callLog.followUp) {
                    details.push(`Фолоу-ап: ${callLog.followUp}`);
                }
                const syncRelative = formatRelativeTime(callLog.lastSync);
                if (syncRelative) {
                    details.push(`синхр. ${syncRelative}`);
                }
                const detailText = details.map(value => escapeHtml(value)).join(' • ');
                const providerLabel = callLog.provider ? ` (${escapeHtml(callLog.provider)})` : '';
                communicationItems.push(`
                    <li>Дзвінки${providerLabel}${detailText ? `: ${detailText}` : ''}</li>
                `);
            }

            const emailLog = automation.communicationLog?.emails;
            if (emailLog) {
                const details = [];
                details.push(emailLog.autoLink ? 'Листи автоматично прив’язуються' : 'Потрібна ручна прив’язка');
                if (Number.isFinite(emailLog.threadsTracked) && emailLog.threadsTracked > 0) {
                    details.push(`${emailLog.threadsTracked} потоків`);
                }
                if (emailLog.followUp) {
                    details.push(`Фолоу-ап: ${emailLog.followUp}`);
                }
                const syncRelative = formatRelativeTime(emailLog.lastSync);
                if (syncRelative) {
                    details.push(`синхр. ${syncRelative}`);
                }
                const detailText = details.map(value => escapeHtml(value)).join(' • ');
                const mailboxLabel = emailLog.mailbox ? ` (${escapeHtml(emailLog.mailbox)})` : '';
                communicationItems.push(`
                    <li>Листи${mailboxLabel}${detailText ? `: ${detailText}` : ''}</li>
                `);
            }

            if (communicationItems.length) {
                sections.push(`
                    <div class="contact-automation-item">
                        <div class="contact-automation-icon"><i class="fa-solid fa-headset"></i></div>
                        <div>
                            <h4>Автологування дзвінків і листів</h4>
                            <p>Zoom Contact Center (zoom.com) автоматично фіксує дзвінки, записи, теги та прив’язує електронні листи до потрібних контактів.</p>
                            <ul class="contact-automation-meta">${communicationItems.join('')}</ul>
                        </div>
                    </div>
                `);
            }

            if (!sections.length) {
                return '';
            }

            return `
                <div class="contact-profile-section">
                    <h4>Автоматизації</h4>
                    <div class="contact-automation-grid">
                        ${sections.join('')}
                    </div>
                </div>
            `;
        }

        function createContactComposerMarkup(contact) {
            if (!contact) {
                return '';
            }

            const contactLabel = escapeHtml(contact.name || 'клієнта');
            return `
                <div class="contact-timeline-composer" data-contact-id="${contact.id}">
                    <p class="composer-hint">Фіксуйте дзвінки, листи й нотатки по ${contactLabel} прямо в картці.</p>
                    <div class="composer-action-bar" role="radiogroup" aria-label="Тип взаємодії">
                        <button type="button" class="contact-action-button composer-action-btn" data-mode="note" aria-pressed="false">
                            <i class="fa-solid fa-note-sticky"></i>
                            <span>Нотатка</span>
                        </button>
                        <button type="button" class="contact-action-button composer-action-btn" data-mode="call" aria-pressed="false">
                            <i class="fa-solid fa-phone"></i>
                            <span>Дзвінок</span>
                        </button>
                        <button type="button" class="contact-action-button composer-action-btn" data-mode="email" aria-pressed="false">
                            <i class="fa-solid fa-envelope"></i>
                            <span>Лист</span>
                        </button>
                        <button type="button" class="contact-action-button composer-action-btn" data-mode="reminder" aria-pressed="false">
                            <i class="fa-solid fa-bell"></i>
                            <span>Нагадування</span>
                        </button>
                    </div>
                    <form class="composer-form" novalidate>
                        <div class="composer-field-grid">
                            <div class="composer-field">
                                <label>
                                    <span class="composer-label">Тема</span>
                                    <input type="text" name="subject" placeholder="Наприклад, фолоу-ап" required>
                                </label>
                            </div>
                            <div class="composer-field">
                                <label>
                                    <span class="composer-label">Деталі</span>
                                    <textarea name="summary" rows="3" placeholder="Зафіксуйте результат взаємодії" required></textarea>
                                </label>
                            </div>
                            <div class="composer-field composer-reminder-field" hidden>
                                <label>
                                    <span class="composer-label">Нагадати до</span>
                                    <input type="datetime-local" name="reminder">
                                </label>
                            </div>
                        </div>
                        <div class="composer-footer">
                            <div class="composer-meta" aria-live="polite"></div>
                            <button type="submit" class="btn btn-primary">
                                <i class="fa-solid fa-plus"></i>
                                <span>Зберегти</span>
                            </button>
                        </div>
                    </form>
                </div>
            `;
        }

        function setupContactComposer(timelineContainer, contact) {
            if (!timelineContainer || !contact) {
                return;
            }

            const composer = timelineContainer.querySelector('.contact-timeline-composer');
            if (!composer) {
                return;
            }

            const form = composer.querySelector('form');
            const actionButtons = composer.querySelectorAll('.composer-action-btn');
            const subjectInput = form?.querySelector('input[name="subject"]');
            const summaryInput = form?.querySelector('textarea[name="summary"]');
            const reminderField = form?.querySelector('.composer-reminder-field');
            const reminderInput = reminderField?.querySelector('input[name="reminder"]') || null;
            const statusElement = composer.querySelector('.composer-meta');
            const state = contactComposerState.get(contact.id) || { mode: 'note', status: null };
            contactComposerState.set(contact.id, state);

            const ensureDateValue = dateInput => {
                const instance = dateInput instanceof Date ? new Date(dateInput.getTime()) : new Date(dateInput);
                if (Number.isNaN(instance.getTime())) {
                    return '';
                }
                const pad = value => String(value).padStart(2, '0');
                return `${instance.getFullYear()}-${pad(instance.getMonth() + 1)}-${pad(instance.getDate())}T${pad(instance.getHours())}:${pad(instance.getMinutes())}`;
            };

            const clearStatus = () => {
                if (!statusElement) {
                    return;
                }
                statusElement.textContent = '';
                statusElement.classList.remove('is-success', 'is-error');
            };

            const updateStatusDisplay = () => {
                if (!statusElement) {
                    return;
                }
                clearStatus();
                if (state.status && state.status.message) {
                    statusElement.textContent = state.status.message;
                    if (state.status.type === 'success') {
                        statusElement.classList.add('is-success');
                    } else if (state.status.type === 'error') {
                        statusElement.classList.add('is-error');
                    }
                }
            };

            const setStatus = (message, type = null) => {
                if (message) {
                    state.status = { message, type };
                } else {
                    state.status = null;
                }
                contactComposerState.set(contact.id, state);
                updateStatusDisplay();
            };

            const contactName = typeof contact.name === 'string' && contact.name.trim().length
                ? contact.name.trim()
                : 'клієнта';

            const subjectTemplates = {
                note: `Нотатка: ${contactName}`,
                call: `Дзвінок з ${contactName}`,
                email: `Лист для ${contactName}`,
                reminder: `Нагадування: ${contactName}`
            };

            const summaryPlaceholders = {
                note: 'Запишіть нові домовленості або важливі деталі.',
                call: 'Зафіксуйте підсумки дзвінка та наступні кроки.',
                email: 'Коротко опишіть зміст листа чи відповідь клієнта.',
                reminder: 'Опишіть дію, про яку необхідно нагадати.'
            };

            const setSuggestedSubject = suggestion => {
                if (!subjectInput) {
                    return;
                }
                const previousAuto = subjectInput.dataset.autoValue || '';
                const currentValue = subjectInput.value.trim();
                if (!currentValue || currentValue === previousAuto) {
                    subjectInput.value = suggestion;
                    subjectInput.dataset.autoValue = suggestion;
                }
                subjectInput.placeholder = suggestion;
            };

            if (subjectInput) {
                subjectInput.addEventListener('input', () => {
                    if (!subjectInput.dataset.autoValue) {
                        return;
                    }
                    if (subjectInput.value.trim() !== subjectInput.dataset.autoValue) {
                        subjectInput.dataset.autoValue = '';
                    }
                });
            }

            const allowedModes = new Set(['note', 'call', 'email', 'reminder']);
            let mode = allowedModes.has(state.mode) ? state.mode : 'note';

            const applyMode = newMode => {
                const targetMode = allowedModes.has(newMode) ? newMode : 'note';
                mode = targetMode;
                state.mode = targetMode;
                contactComposerState.set(contact.id, state);
                actionButtons.forEach(button => {
                    const isActive = button.dataset.mode === mode;
                    button.classList.toggle('is-active', isActive);
                    button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });
                if (reminderField) {
                    if (mode === 'reminder') {
                        reminderField.hidden = false;
                        if (reminderInput) {
                            reminderInput.required = true;
                            if (!reminderInput.value) {
                                const defaultDate = new Date();
                                defaultDate.setDate(defaultDate.getDate() + 1);
                                defaultDate.setHours(10, 0, 0, 0);
                                reminderInput.value = ensureDateValue(defaultDate);
                            }
                        }
                    } else {
                        reminderField.hidden = true;
                        if (reminderInput) {
                            reminderInput.required = false;
                            reminderInput.value = '';
                        }
                    }
                }
                setSuggestedSubject(subjectTemplates[mode]);
                if (summaryInput) {
                    summaryInput.placeholder = summaryPlaceholders[mode];
                }
                if (state.status && state.status.type === 'error') {
                    setStatus('', null);
                }
            };

            actionButtons.forEach(button => {
                button.addEventListener('click', () => {
                    applyMode(button.dataset.mode);
                    if (summaryInput) {
                        summaryInput.focus({ preventScroll: true });
                    }
                });
            });

            updateStatusDisplay();
            applyMode(mode);

            if (state.status && state.status.type === 'success') {
                const statusSnapshot = { ...state.status };
                setTimeout(() => {
                    const stored = contactComposerState.get(contact.id);
                    if (stored && stored.status && stored.status.message === statusSnapshot.message && stored.status.type === statusSnapshot.type) {
                        stored.status = null;
                        contactComposerState.set(contact.id, stored);
                        const currentComposer = document.querySelector(`#contactTimelineCard .contact-timeline-composer[data-contact-id="${contact.id}"]`);
                        if (currentComposer) {
                            const meta = currentComposer.querySelector('.composer-meta');
                            if (meta) {
                                meta.textContent = '';
                                meta.classList.remove('is-success', 'is-error');
                            }
                        }
                    }
                }, 4000);
            }

            if (form) {
                form.addEventListener('submit', event => {
                    event.preventDefault();
                    const subjectValue = subjectInput ? subjectInput.value.trim() : '';
                    const summaryValue = summaryInput ? summaryInput.value.trim() : '';
                    const reminderValue = reminderInput ? reminderInput.value : '';

                    if (!subjectValue || !summaryValue) {
                        setStatus('Заповніть тему та деталі взаємодії.', 'error');
                        return;
                    }

                    const nowIso = new Date().toISOString();

                    if (mode === 'reminder') {
                        if (!reminderValue) {
                            setStatus('Вкажіть дату та час нагадування.', 'error');
                            return;
                        }
                        const dueDate = new Date(reminderValue);
                        if (Number.isNaN(dueDate.getTime())) {
                            setStatus('Дата нагадування має бути коректною.', 'error');
                            return;
                        }

                        const task = {
                            id: generateId('task'),
                            title: subjectValue,
                            owner: CURRENT_USER.name,
                            dueDate: dueDate.toISOString(),
                            priority: 'medium',
                            status: 'todo',
                            relatedContactId: contact.id,
                            description: summaryValue,
                            tags: ['Нагадування', contactName],
                            attachments: [],
                            createdAt: nowIso
                        };

                        if (!Array.isArray(crmData.tasks)) {
                            crmData.tasks = [];
                        }
                        crmData.tasks.unshift(task);
                        contact.lastActivity = nowIso;
                        saveData();
                        logActivity(`Нагадування для ${contactName} заплановано.`, 'reminder', contact.id);
                        form.reset();
                        setStatus('Нагадування збережено.', 'success');
                        const searchValue = document.getElementById('contactSearch')?.value || '';
                        renderContacts(searchValue);
                        renderTasks();
                        renderUpcomingActivities();
                        return;
                    }

                    const interactionType = mode === 'note' ? 'note' : mode;
                    const channel = mode === 'call' ? 'phone' : mode === 'email' ? 'email' : 'system';
                    if (!Array.isArray(contact.interactions)) {
                        contact.interactions = [];
                    }

                    contact.interactions.unshift({
                        id: generateId('cact'),
                        type: interactionType,
                        channel,
                        subject: subjectValue,
                        summary: summaryValue,
                        timestamp: nowIso,
                        author: CURRENT_USER.name,
                        tags: mode === 'note' ? ['CRM'] : ['Взаємодія']
                    });

                    contact.lastActivity = nowIso;
                    saveData();
                    const interactionLabel = CONTACT_INTERACTION_TYPE_LABELS[interactionType] || 'Активність';
                    logActivity(`${interactionLabel} з ${contactName} зафіксовано.`, interactionType, contact.id);
                    form.reset();
                    setStatus(`${interactionLabel} додано до історії.`, 'success');
                    const searchValue = document.getElementById('contactSearch')?.value || '';
                    renderContacts(searchValue);
                });
            }
        }

        function focusContactComposer(contactId, mode = 'note') {
            if (!contactId) {
                return;
            }
            const composer = document.querySelector(`#contactTimelineCard .contact-timeline-composer[data-contact-id="${contactId}"]`);
            if (!composer) {
                return;
            }
            const button = composer.querySelector(`.composer-action-btn[data-mode="${mode}"]`);
            if (button) {
                button.click();
            }
            const summaryInput = composer.querySelector('textarea[name="summary"]');
            if (summaryInput) {
                try {
                    summaryInput.focus({ preventScroll: true });
                } catch (error) {
                    summaryInput.focus();
                }
            }
            composer.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function renderContactDetails(contactId, activityCache = null) {
            const profileContainer = document.getElementById('contactProfileCard');
            const timelineContainer = document.getElementById('contactTimelineCard');
            if (!profileContainer || !timelineContainer) {
                return;
            }

            const contact = Array.isArray(crmData?.contacts)
                ? crmData.contacts.find(item => item.id === contactId)
                : null;

            if (!contact) {
                profileContainer.innerHTML = '<div class="contact-timeline-empty">Оберіть контакт, щоб побачити профіль клієнта.</div>';
                timelineContainer.innerHTML = '<div class="contact-timeline-empty">Історія взаємодій з\'явиться після вибору контакту.</div>';
                return;
            }

            const lifecycleLabel = CONTACT_LIFECYCLE_LABELS[contact.lifecycleStage] || '—';
            const activityInfo = activityCache ? activityCache.get(contact.id) : null;
            const timeline = activityInfo ? activityInfo.timeline : getContactTimeline(contact);
            const recentTimestamp = activityInfo && activityInfo.lastTimestamp
                ? activityInfo.lastTimestamp
                : (timeline.length ? timeline[0].timestamp : normalizeToISOString(contact.lastActivity));
            const lastActivityLabel = recentTimestamp ? formatRelativeTime(recentTimestamp) : '—';
            const channelLabel = CONTACT_CHANNEL_LABELS[contact.preferredChannel] || '—';
            const segmentBadges = Array.isArray(contact.segments) && contact.segments.length
                ? `<div class="chips">${contact.segments.map(segment => `<span class="chip chip-accent">${escapeHtml(STATUS_LABELS[segment] || segment)}</span>`).join('')}</div>`
                : '';
            const tagsMarkup = Array.isArray(contact.tags) && contact.tags.length
                ? `<div class="chips">${contact.tags.map(tag => `<span class="chip">${escapeHtml(tag)}</span>`).join('')}</div>`
                : '';
            const automationMarkup = renderContactAutomation(contact.automation);
            const addressLines = [
                contact.address?.street,
                [contact.address?.city, contact.address?.country].filter(Boolean).join(', '),
                contact.address?.postalCode
            ].filter(value => value && value.trim().length).map(value => escapeHtml(value));
            const addressMarkup = addressLines.length ? addressLines.join('<br>') : '—';
            const industry = contact.demographics?.industry ? escapeHtml(contact.demographics.industry) : '—';
            const employees = Number.isFinite(contact.demographics?.employees) ? formatIntegerDisplay(contact.demographics.employees) : '—';
            const revenue = Number.isFinite(contact.demographics?.annualRevenue) ? formatCurrency(contact.demographics.annualRevenue, true) : '—';
            const emailMarkup = contact.email
                ? `<a href="mailto:${encodeURIComponent(contact.email)}">${escapeHtml(contact.email)}</a>`
                : '—';
            const phoneMarkup = contact.phone
                ? `<a href="tel:${encodeURIComponent(contact.phone)}">${escapeHtml(contact.phone)}</a>`
                : '—';
            const websiteRaw = typeof contact.website === 'string' ? contact.website.trim() : '';
            const websiteUrl = websiteRaw
                ? (websiteRaw.startsWith('http://') || websiteRaw.startsWith('https://') ? websiteRaw : `https://${websiteRaw}`)
                : '';
            const websiteMarkup = websiteUrl
                ? `<a href="${escapeHtml(websiteUrl)}" target="_blank" rel="noopener">${escapeHtml(websiteUrl)}</a>`
                : '—';
            const linkedinRaw = typeof contact.linkedin === 'string' ? contact.linkedin.trim() : '';
            const linkedinUrl = linkedinRaw
                ? (linkedinRaw.startsWith('http://') || linkedinRaw.startsWith('https://') ? linkedinRaw : `https://${linkedinRaw}`)
                : '';
            const linkedinMarkup = linkedinUrl
                ? `<a href="${escapeHtml(linkedinUrl)}" target="_blank" rel="noopener">${escapeHtml(linkedinUrl)}</a>`
                : '—';

            const relatedLead = crmData && Array.isArray(crmData.leads)
                ? crmData.leads.find(lead => {
                    const sameId = lead.contact && lead.contact.id && lead.contact.id === contact.id;
                    const sameEmail = lead.contact && lead.contact.email && contact.email && lead.contact.email === contact.email;
                    const sameCompany = lead.company && contact.company && lead.company === contact.company;
                    return sameId || sameEmail || sameCompany;
                })
                : null;

            const leadActionMarkup = relatedLead
                ? `<div class="contact-profile-actions"><button class="btn btn-small-primary" type="button" data-open-lead="${relatedLead.id}"><i class="fa-solid fa-arrow-up-right-from-square"></i> Відкрити угоду</button></div>`
                : '';

            const quickActionsMarkup = `
                <div class="contact-profile-section contact-actions-section">
                    <h4>Швидкі дії</h4>
                    <div class="contact-quick-actions" data-contact-actions="${contact.id}">
                        <button type="button" class="contact-action-button" data-composer-trigger="call"><i class="fa-solid fa-phone"></i><span>Дзвінок</span></button>
                        <button type="button" class="contact-action-button" data-composer-trigger="email"><i class="fa-solid fa-envelope"></i><span>Лист</span></button>
                        <button type="button" class="contact-action-button" data-composer-trigger="note"><i class="fa-solid fa-note-sticky"></i><span>Нотатка</span></button>
                        <button type="button" class="contact-action-button" data-composer-trigger="reminder"><i class="fa-solid fa-bell"></i><span>Нагадування</span></button>
                    </div>
                    ${leadActionMarkup}
                </div>
            `;

            profileContainer.innerHTML = `
                <div class="contact-profile-header">
                    <div class="avatar avatar-lg">${getInitials(contact.name)}</div>
                    <div>
                        <h3>${escapeHtml(contact.name)}</h3>
                        <p class="metric-sub">${escapeHtml(contact.company || 'Без компанії')}</p>
                        ${segmentBadges}
                    </div>
                </div>
                <div class="contact-profile-section">
                    <h4>Контактні дані</h4>
                    <div class="contact-meta-list">
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-envelope"></i>
                            <div>${emailMarkup}</div>
                        </div>
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-phone"></i>
                            <div>${phoneMarkup}</div>
                        </div>
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-user"></i>
                            <div>${escapeHtml(contact.role || '—')}<br><span class="metric-sub">Менеджер: ${escapeHtml(contact.owner || 'Не призначено')}</span></div>
                        </div>
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-paper-plane"></i>
                            <div>Канал: ${escapeHtml(channelLabel)}<br><span class="metric-sub">Останній контакт: ${escapeHtml(lastActivityLabel)}</span></div>
                        </div>
                    </div>
                </div>
                <div class="contact-profile-section">
                    <h4>Локація</h4>
                    <div class="contact-meta-list">
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-location-dot"></i>
                            <div>${addressMarkup}</div>
                        </div>
                        <div class="contact-meta-item">
                            <i class="fa-regular fa-clock"></i>
                            <div>Часовий пояс: ${escapeHtml(contact.timezone || '—')}</div>
                        </div>
                    </div>
                </div>
                <div class="contact-profile-section">
                    <h4>Профіль компанії</h4>
                    <div class="contact-meta-list">
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-briefcase"></i>
                            <div>Індустрія: ${industry}</div>
                        </div>
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-users"></i>
                            <div>Співробітників: ${employees}</div>
                        </div>
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-chart-line"></i>
                            <div>Оборот: ${revenue}</div>
                        </div>
                    </div>
                </div>
                <div class="contact-profile-section">
                    <h4>Посилання</h4>
                    <div class="contact-meta-list">
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-globe"></i>
                            <div>${websiteMarkup}</div>
                        </div>
                        <div class="contact-meta-item">
                            <i class="fa-solid fa-link"></i>
                            <div>${linkedinMarkup}</div>
                        </div>
                    </div>
                </div>
                ${automationMarkup}
                ${tagsMarkup ? `<div class="contact-profile-section"><h4>Мітки</h4>${tagsMarkup}</div>` : ''}
                ${quickActionsMarkup}
            `;

            const timelineItems = timeline.map(interaction => {
                    const typeLabel = CONTACT_INTERACTION_TYPE_LABELS[interaction.type] || 'Активність';
                    const channel = CONTACT_CHANNEL_LABELS[interaction.channel] || interaction.channel;
                    const icon = CONTACT_INTERACTION_ICONS[interaction.type] || 'fa-solid fa-circle-info';
                    const whenRelative = interaction.timestamp ? formatRelativeTime(interaction.timestamp) : '';
                    const whenAbsolute = interaction.timestamp
                        ? formatDate(interaction.timestamp, { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit' })
                        : '';
                    const metaParts = [typeLabel];
                    if (channel && channel !== typeLabel) {
                        metaParts.push(channel);
                    }
                    if (interaction.author) {
                        metaParts.push(`Автор: ${interaction.author}`);
                    }
                    if (whenAbsolute) {
                        metaParts.push(whenAbsolute);
                    }
                    const metaMarkup = metaParts.map(part => `<span>${escapeHtml(part)}</span>`).join('');
                    const summary = interaction.summary ? `<p>${escapeHtml(interaction.summary)}</p>` : '';
                    const tagMarkup = Array.isArray(interaction.tags) && interaction.tags.length
                        ? `<div class="chips">${interaction.tags.map(tag => `<span class="chip chip-ghost">${escapeHtml(tag)}</span>`).join('')}</div>`
                        : '';
                    const attachmentsCount = Array.isArray(interaction.attachments) ? interaction.attachments.length : 0;
                    const attachmentsMarkup = attachmentsCount
                        ? `<div class="chips"><span class="chip chip-ghost"><i class="fa-solid fa-paperclip"></i> ${attachmentsCount}</span></div>`
                        : '';

                    return `
                        <div class="contact-timeline-item">
                            <div class="contact-timeline-icon"><i class="${icon}"></i></div>
                            <div class="contact-timeline-body">
                                <strong>${escapeHtml(interaction.subject || typeLabel)}</strong>
                                <div class="contact-timeline-meta">
                                    ${metaMarkup}
                                    ${whenRelative ? `<span>${escapeHtml(whenRelative)}</span>` : ''}
                                </div>
                                ${summary}
                                ${tagMarkup}
                                ${attachmentsMarkup}
                            </div>
                        </div>
                    `;
                }).join('');

            const timelineContent = timelineItems.length
                ? `<div class="contact-timeline-list">${timelineItems}</div>`
                : '<div class="contact-timeline-empty">Ще немає зафіксованих взаємодій. Заплануйте перший контакт.</div>';

            timelineContainer.innerHTML = `
                <div class="contact-timeline-header">
                    <h3>Історія взаємодій</h3>
                    <p>Повний контекст дзвінків, листів, задач і запитів підтримки.</p>
                </div>
                ${createContactComposerMarkup(contact)}
                ${timelineContent}
            `;

            setupContactComposer(timelineContainer, contact);

            profileContainer.querySelectorAll('[data-open-lead]').forEach(btn => {
                btn.addEventListener('click', () => openLeadDetails(btn.dataset.openLead));
            });

            profileContainer.querySelectorAll('[data-composer-trigger]').forEach(btn => {
                btn.addEventListener('click', () => focusContactComposer(contact.id, btn.dataset.composerTrigger));
            });
        }

        function updateTaskFilterControls() {
            const tasks = crmData && Array.isArray(crmData.tasks) ? crmData.tasks : [];
            const ownerSelect = document.getElementById('taskOwnerFilter');
            if (ownerSelect) {
                const owners = Array.from(new Set(tasks
                    .map(task => (typeof task.owner === 'string' ? task.owner.trim() : ''))
                    .filter(Boolean)));
                owners.sort((a, b) => a.localeCompare(b, 'uk', { sensitivity: 'base' }));
                const previousSelection = taskFilters.owner;
                ownerSelect.innerHTML = '';
                const defaultOption = document.createElement('option');
                defaultOption.value = 'all';
                defaultOption.textContent = 'Вся команда';
                ownerSelect.appendChild(defaultOption);
                owners.forEach(owner => {
                    const option = document.createElement('option');
                    option.value = owner;
                    option.textContent = owner;
                    ownerSelect.appendChild(option);
                });
                if (!owners.includes(previousSelection)) {
                    taskFilters.owner = 'all';
                }
                ownerSelect.value = taskFilters.owner;
            }

            const prioritySelect = document.getElementById('taskPriorityFilter');
            if (prioritySelect) {
                prioritySelect.value = taskFilters.priority;
            }

            const dueSelect = document.getElementById('taskDueFilter');
            if (dueSelect) {
                dueSelect.value = taskFilters.due;
            }

            const searchInput = document.getElementById('taskSearchInput');
            if (searchInput && searchInput.value !== taskFilters.search) {
                searchInput.value = taskFilters.search;
            }
        }

        function getFilteredTasks() {
            const tasks = crmData && Array.isArray(crmData.tasks) ? crmData.tasks : [];
            const leads = crmData && Array.isArray(crmData.leads) ? crmData.leads : [];
            const contacts = crmData && Array.isArray(crmData.contacts) ? crmData.contacts : [];
            const searchTerm = taskFilters.search.trim().toLowerCase();
            return tasks.filter(task => {
                const ownerName = typeof task.owner === 'string' ? task.owner.trim() : '';
                if (taskFilters.owner !== 'all' && ownerName !== taskFilters.owner) {
                    return false;
                }
                if (taskFilters.priority !== 'all' && task.priority !== taskFilters.priority) {
                    return false;
                }
                if (taskFilters.due !== 'all' && !matchesDueFilter(task, taskFilters.due)) {
                    return false;
                }
                if (searchTerm) {
                    const lead = task.relatedLeadId ? leads.find(item => item.id === task.relatedLeadId) : null;
                    const contact = task.relatedContactId ? contacts.find(item => item.id === task.relatedContactId) : null;
                    const haystackParts = [
                        task.title,
                        task.description,
                        ownerName,
                        ...(Array.isArray(task.tags) ? task.tags : []),
                        lead ? lead.name : '',
                        lead ? lead.company : '',
                        contact ? contact.name : '',
                        contact ? contact.company : '',
                        contact ? contact.email : '',
                        contact ? contact.phone : ''
                    ];
                    const haystack = haystackParts.filter(Boolean).join(' ').toLowerCase();
                    if (!haystack.includes(searchTerm)) {
                        return false;
                    }
                }
                return true;
            });
        }

        function matchesDueFilter(task, filterValue) {
            switch (filterValue) {
                case 'overdue':
                    return task.status !== 'done' && isOverdue(task.dueDate);
                case 'today':
                    return task.status !== 'done' && isDueToday(task.dueDate);
                case 'week':
                    return task.status !== 'done' && isDueWithinDays(task.dueDate, 7);
                case 'done':
                    return task.status === 'done';
                default:
                    return true;
            }
        }

        function renderTaskProcessSummary(filteredTasks) {
            const container = document.getElementById('taskProcessSummary');
            if (!container) {
                return;
            }
            const tasks = crmData && Array.isArray(crmData.tasks) ? crmData.tasks : [];
            if (!tasks.length) {
                container.innerHTML = '<div class="empty-state">Додайте перші задачі, щоб почати відстеження процесу.</div>';
                return;
            }

            const total = tasks.length;
            const completed = tasks.filter(task => task.status === 'done').length;
            const active = tasks.filter(task => task.status !== 'done');
            const inProgress = active.filter(task => task.status === 'inProgress').length;
            const overdue = active.filter(task => isOverdue(task.dueDate)).length;
            const dueSoon = active.filter(task => isDueWithinDays(task.dueDate, 3)).length;
            const completionRate = total ? Math.round((completed / total) * 100) : 0;
            const filteredCount = filteredTasks.length;
            const indicatorIcon = overdue ? 'fa-triangle-exclamation' : 'fa-circle-check';
            const indicatorClass = overdue ? 'process-summary-indicator has-warning' : 'process-summary-indicator';
            const indicatorText = overdue ? `${overdue} прострочено` : 'Прострочень немає';

            container.innerHTML = `
                <div class="process-summary-main">
                    <div>
                        <div class="process-summary-title">${completionRate}% виконання</div>
                        <div class="metric-sub">${completed} завершено • ${active.length} активні</div>
                    </div>
                    <div class="${indicatorClass}">
                        <i class="fa-solid ${indicatorIcon}"></i>
                        <span>${indicatorText}</span>
                    </div>
                </div>
                <div class="progress-track"><div class="progress-value" style="width:${completionRate ? Math.max(completionRate, 6) : 0}%"></div></div>
                <div class="process-summary-meta">
                    <span class="task-pill task-pill-info"><i class="fa-solid fa-person-running"></i> У роботі: ${inProgress}</span>
                    <span class="task-pill task-pill-warning"><i class="fa-solid fa-calendar-day"></i> Ближчі 3 дні: ${dueSoon}</span>
                    <span class="task-pill task-pill-muted"><i class="fa-solid fa-layer-group"></i> Всього: ${total}</span>
                </div>
                ${filteredCount !== total ? `<div class="metric-sub process-summary-filter">Фільтровано: ${filteredCount} із ${total} задач</div>` : ''}
            `;
        }

        function calculateAverageCycleTime(tasks) {
            if (!Array.isArray(tasks) || !tasks.length) {
                return null;
            }
            let totalDays = 0;
            let counted = 0;
            tasks.forEach(task => {
                if (task.status !== 'done') {
                    return;
                }
                const start = task.createdAt ? new Date(task.createdAt) : null;
                const endSource = task.completedAt || task.dueDate;
                const end = endSource ? new Date(endSource) : null;
                if (!start || Number.isNaN(start.getTime()) || !end || Number.isNaN(end.getTime())) {
                    return;
                }
                totalDays += daysBetween(start, end);
                counted += 1;
            });
            if (!counted) {
                return null;
            }
            return Math.max(0, Math.round(totalDays / counted));
        }

        function renderTaskSummaryInsights(filteredTasks) {
            const container = document.getElementById('taskSummaryGrid');
            if (!container) {
                return;
            }
            const tasks = crmData && Array.isArray(crmData.tasks) ? crmData.tasks : [];
            if (!tasks.length) {
                container.innerHTML = '<div class="empty-state">Додайте перші задачі, щоб запустити трекінг.</div>';
                return;
            }

            const total = tasks.length;
            const activeTasks = tasks.filter(task => task.status !== 'done');
            const highPriorityActive = activeTasks.filter(task => task.priority === 'high').length;
            const overdueTasks = activeTasks.filter(task => isOverdue(task.dueDate)).length;
            const dueSoon = activeTasks.filter(task => isDueWithinDays(task.dueDate, 3)).length;
            const completedTasks = tasks.filter(task => task.status === 'done');
            const completedThisWeek = completedTasks.filter(task => task.completedAt && daysBetween(task.completedAt, new Date()) <= 7).length;
            const completionRate = total ? Math.round((completedTasks.length / total) * 100) : 0;
            const averageCycle = calculateAverageCycleTime(tasks);
            const filteredHighPriority = filteredTasks.filter(task => task.priority === 'high' && task.status !== 'done').length;
            const filteredText = filteredTasks.length !== total ? `${filteredTasks.length} у фокусі` : `${activeTasks.length} активні`;

            container.innerHTML = `
                <div class="task-summary-card">
                    <div class="task-summary-icon"><i class="fa-solid fa-list-check"></i></div>
                    <div>
                        <div class="task-summary-label">Активні задачі</div>
                        <div class="task-summary-value">${activeTasks.length}</div>
                        <div class="metric-sub">${highPriorityActive} високий пріоритет</div>
                    </div>
                </div>
                <div class="task-summary-card">
                    <div class="task-summary-icon task-summary-icon-warning"><i class="fa-solid fa-clock-rotate-left"></i></div>
                    <div>
                        <div class="task-summary-label">Прострочено</div>
                        <div class="task-summary-value">${overdueTasks}</div>
                        <div class="metric-sub">${dueSoon} дедлайн у 3 дні</div>
                    </div>
                </div>
                <div class="task-summary-card">
                    <div class="task-summary-icon task-summary-icon-success"><i class="fa-solid fa-check-double"></i></div>
                    <div>
                        <div class="task-summary-label">Завершено (7 днів)</div>
                        <div class="task-summary-value">${completedThisWeek}</div>
                        <div class="metric-sub">${completionRate}% виконання</div>
                    </div>
                </div>
                <div class="task-summary-card">
                    <div class="task-summary-icon task-summary-icon-info"><i class="fa-solid fa-chart-simple"></i></div>
                    <div>
                        <div class="task-summary-label">Середній цикл</div>
                        <div class="task-summary-value">${averageCycle !== null ? `${averageCycle} дн.` : '—'}</div>
                        <div class="metric-sub">${filteredHighPriority ? `${filteredHighPriority} критичні в роботі` : filteredText}</div>
                    </div>
                </div>
            `;
        }

        function renderTaskFlowBreakdown(allTasks) {
            const container = document.getElementById('taskFlowBreakdown');
            if (!container) {
                return;
            }
            const tasks = Array.isArray(allTasks) ? allTasks : [];
            if (!tasks.length) {
                container.innerHTML = '<div class="empty-state">Задачі ще не додані.</div>';
                return;
            }

            const total = tasks.length;
            container.innerHTML = TASK_COLUMNS.map(column => {
                const columnTasks = tasks.filter(task => task.status === column.id);
                const count = columnTasks.length;
                const percent = total ? Math.round((count / total) * 100) : 0;
                const barWidth = count ? Math.max(percent, 6) : 0;
                const overdue = column.id === 'done' ? 0 : columnTasks.filter(task => isOverdue(task.dueDate)).length;
                const overdueText = overdue ? ` • прострочено: ${overdue}` : '';
                return `
                    <div class="task-flow-item">
                        <div class="task-flow-header">
                            <strong>${column.title}</strong>
                            <span>${count}</span>
                        </div>
                        <div class="progress-track"><div class="progress-value" style="width:${barWidth}%"></div></div>
                        <div class="metric-sub">${percent}% від усіх задач${overdueText}</div>
                    </div>
                `;
            }).join('');
        }

        function renderTaskTeamWorkload(allTasks) {
            const container = document.getElementById('taskTeamWorkload');
            if (!container) {
                return;
            }
            const tasks = Array.isArray(allTasks) ? allTasks : [];
            if (!tasks.length) {
                container.innerHTML = '<div class="empty-state">Задачі ще не призначені.</div>';
                return;
            }

            const workload = {};
            tasks.forEach(task => {
                const ownerName = typeof task.owner === 'string' ? task.owner.trim() : '';
                const owner = ownerName || 'Без виконавця';
                if (!workload[owner]) {
                    workload[owner] = { total: 0, done: 0, inProgress: 0, todo: 0, overdue: 0 };
                }
                const stats = workload[owner];
                stats.total += 1;
                if (task.status === 'done') {
                    stats.done += 1;
                } else if (task.status === 'inProgress') {
                    stats.inProgress += 1;
                } else if (task.status === 'todo') {
                    stats.todo += 1;
                }
                if (task.status !== 'done' && isOverdue(task.dueDate)) {
                    stats.overdue += 1;
                }
            });

            const items = Object.entries(workload).sort((a, b) => b[1].total - a[1].total);
            container.innerHTML = items.map(([owner, stats]) => {
                const completion = stats.total ? Math.round((stats.done / stats.total) * 100) : 0;
                const barWidth = completion ? Math.max(completion, 6) : 0;
                return `
                    <div class="task-workload-item">
                        <div class="task-workload-header">
                            <strong>${escapeHtml(owner)}</strong>
                            <span class="metric-sub">${stats.total} задач</span>
                        </div>
                        <div class="progress-track"><div class="progress-value" style="width:${barWidth}%"></div></div>
                        <div class="task-workload-meta">
                            <span class="task-pill task-pill-info">У роботі: ${stats.inProgress}</span>
                            <span class="task-pill task-pill-muted">Заплановано: ${stats.todo}</span>
                            ${stats.overdue ? `<span class="task-pill task-pill-danger">Прострочено: ${stats.overdue}</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderTaskFeatureInsights(allTasks) {
            const container = document.getElementById('taskFeatureInsights');
            if (!container) {
                return;
            }
            const tasks = Array.isArray(allTasks) ? allTasks : [];
            if (!tasks.length) {
                container.innerHTML = '<div class="empty-state">Додайте задачі, щоб відстежувати використання функцій.</div>';
                return;
            }

            const numberFormatter = new Intl.NumberFormat('uk-UA');
            const formatValue = value => numberFormatter.format(Number.isFinite(value) ? value : 0);
            const formatTasksLabel = count => {
                if (!Number.isFinite(count) || count <= 0) {
                    return 'жодної задачі';
                }
                const formatted = numberFormatter.format(count);
                const mod100 = count % 100;
                const mod10 = count % 10;
                if (mod10 === 1 && mod100 !== 11) {
                    return `${formatted} задача`;
                }
                if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
                    return `${formatted} задачі`;
                }
                return `${formatted} задач`;
            };

            const activeTasks = tasks.filter(task => task.status !== 'done');
            const dueToday = activeTasks.filter(task => isDueToday(task.dueDate)).length;
            const queueCount = tasks.filter(task => task.status === 'todo').length;
            const completedRecent = tasks.filter(task => {
                if (task.status !== 'done') {
                    return false;
                }
                const completionSource = task.completedAt || task.dueDate;
                if (!completionSource) {
                    return false;
                }
                return daysBetween(completionSource, new Date()) <= 7;
            }).length;

            const insights = [
                {
                    icon: 'fa-desktop',
                    label: 'Особистий робочий стіл',
                    value: formatValue(activeTasks.length),
                    sub: activeTasks.length
                        ? `${formatTasksLabel(activeTasks.length)} зібрано на персональній CRM-панелі поруч із зустрічами та контактами без перемикань між поштою, календарем і таблицями (hubspot.com).`
                        : 'Персональна CRM-панель готова зібрати задачі, зустрічі та контакти без потреби перемикатися між поштою, календарем і таблицями (hubspot.com).'
                },
                {
                    icon: 'fa-calendar-check',
                    label: 'Синхронізація з календарем',
                    value: formatValue(dueToday),
                    sub: dueToday
                        ? `${formatTasksLabel(dueToday)} заплановано на сьогодні; синхронізований календар допомагає миттєво планувати й приєднуватись до зустрічей та відстежувати реакцію клієнтів на листи чи матеріали (hubspot.com).`
                        : 'На сьогодні задач немає, але синхронізований календар допомагає миттєво планувати зустрічі та бачити реакцію клієнтів на листи чи матеріали (hubspot.com).'
                },
                {
                    icon: 'fa-bolt',
                    label: 'Черга завдань і швидкі дії',
                    value: formatValue(queueCount),
                    sub: queueCount
                        ? `${formatTasksLabel(queueCount)} у черзі можна створити з воркфлоу, електронної пошти чи списку справ і одразу запускати дзвінки, листи або соцмережі без виходу з CRM (hubspot.com).`
                        : 'Черга задач готова приймати елементи з воркфлоу, електронної пошти чи списку справ і запускати дзвінки, листи або соцмережі без виходу з CRM (hubspot.com).'
                },
                {
                    icon: 'fa-chart-line',
                    label: 'Вбудована аналітика по завданнях',
                    value: formatValue(completedRecent),
                    sub: completedRecent
                        ? `За останні 7 днів завершено ${formatTasksLabel(completedRecent)}, а вбудована аналітика показує створені угоди, дзвінки та активності, щоб команда зосереджувалась на результативних задачах (hubspot.com).`
                        : 'Вбудована аналітика покаже створені угоди, дзвінки та активності, щоб команда зосереджувалась на результативних задачах, щойно з\'являться завершені задачі (hubspot.com).'
                },
                {
                    icon: 'fa-layer-group',
                    label: 'Ключові функції для завдань',
                    value: '4×',
                    sub: 'Відстеження прогресу, управління дедлайнами, черги завдань і автоматичне створення задач — типовий набір можливостей для ефективної роботи (hubspot.com).'
                }
            ];

            container.innerHTML = insights.map(item => `
                <div class="task-feature-item">
                    <div class="task-feature-header">
                        <div class="task-feature-content">
                            <span class="task-feature-icon"><i class="fa-solid ${item.icon}"></i></span>
                            <div>
                                <strong>${item.label}</strong>
                                <div class="metric-sub">${item.sub}</div>
                            </div>
                        </div>
                        <div class="task-feature-value">${item.value}</div>
                    </div>
                </div>
            `).join('');
        }

        function renderTaskBoardColumns(tasks) {
            const board = document.getElementById('taskBoard');
            if (!board) {
                return;
            }
            const scopedTasks = Array.isArray(tasks) ? tasks : [];
            board.innerHTML = TASK_COLUMNS.map(column => {
                const columnTasks = scopedTasks.filter(task => task.status === column.id);
                return `
                    <div class="task-column" data-status="${column.id}">
                        <div class="task-column-header">
                            <h4>${column.title}</h4>
                            <span>${columnTasks.length}</span>
                        </div>
                        <div class="task-items">
                            ${columnTasks.length ? columnTasks.map(createTaskCard).join('') : '<div class="empty-state">Немає завдань</div>'}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderTasks() {
            updateTaskFilterControls();
            const filteredTasks = getFilteredTasks();
            renderTaskProcessSummary(filteredTasks);
            renderTaskSummaryInsights(filteredTasks);
            const allTasks = crmData && Array.isArray(crmData.tasks) ? crmData.tasks : [];
            renderTaskFlowBreakdown(allTasks);
            renderTaskTeamWorkload(allTasks);
            renderTaskFeatureInsights(allTasks);
            renderTaskBoardColumns(filteredTasks);
            setupTaskBoardInteractions();
        }

        function createTaskCard(task) {
            const leads = crmData && Array.isArray(crmData.leads) ? crmData.leads : [];
            const contacts = crmData && Array.isArray(crmData.contacts) ? crmData.contacts : [];
            const lead = task.relatedLeadId ? leads.find(item => item.id === task.relatedLeadId) : null;
            const contact = task.relatedContactId ? contacts.find(item => item.id === task.relatedContactId) : null;
            const overdue = task.status !== 'done' && isOverdue(task.dueDate);
            const priorityLabel = TASK_PRIORITY_LABELS[task.priority] || 'Середній';
            const tags = Array.isArray(task.tags) ? task.tags.filter(Boolean) : [];
            const attachmentsCount = Array.isArray(task.attachments) ? task.attachments.length : 0;
            const extras = [];
            if (tags.length) {
                extras.push(`<div class="chips">${tags.map(tag => `<span class="chip">${escapeHtml(tag)}</span>`).join('')}</div>`);
            }
            if (attachmentsCount) {
                extras.push(`<div class="metric-sub"><i class="fa-solid fa-paperclip"></i> ${attachmentsCount}</div>`);
            }
            const extrasMarkup = extras.join('');
            return `
                <div class="task-card" data-task-id="${task.id}">
                    <div class="task-header">
                        <span class="priority priority-${task.priority}">${priorityLabel}</span>
                        <span class="metric-sub">${task.status === 'done' ? 'завершено ' + formatDate(task.completedAt || task.dueDate) : formatRelativeTime(task.dueDate)}</span>
                    </div>
                    <div class="task-title">${task.title}</div>
                    <div class="task-meta">
                        <span><i class="fa-regular fa-calendar"></i> ${formatDate(task.dueDate)}${overdue ? ' • прострочено' : ''}</span>
                        <span><i class="fa-regular fa-user"></i> ${task.owner}</span>
                    </div>
                    ${lead ? `<div class="metric-sub" data-open-lead="${lead.id}"><i class="fa-solid fa-link"></i> ${escapeHtml(lead.name)}</div>` : ''}
                    ${contact ? `<div class="metric-sub" data-open-contact="${contact.id}"><i class="fa-solid fa-user"></i> ${escapeHtml(contact.name)}${contact.company ? ` • ${escapeHtml(contact.company)}` : ''}</div>` : ''}
                    ${task.description ? `<div class="metric-sub">${task.description}</div>` : ''}
                    ${extrasMarkup}
                    <div class="task-actions">
                        ${task.status === 'inProgress' ? `<button class="btn-small-muted" data-task-action="back">Повернути</button>` : ''}
                        ${task.status === 'done' ? `<span class="badge badge-success">Виконано</span>` : `<button class="btn-small-primary" data-task-action="${task.status === 'todo' ? 'start' : 'done'}">${task.status === 'todo' ? 'Розпочати' : 'Завершити'}</button>`}
                    </div>
                </div>
            `;
        }

        function setupTaskBoardInteractions() {
            document.querySelectorAll('#taskBoard [data-task-action]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const taskId = btn.closest('.task-card').dataset.taskId;
                    const action = btn.dataset.taskAction;
                    if (action === 'start') {
                        updateTaskStatus(taskId, 'inProgress');
                    } else if (action === 'done') {
                        updateTaskStatus(taskId, 'done');
                    } else if (action === 'back') {
                        updateTaskStatus(taskId, 'todo');
                    }
                });
            });

            document.querySelectorAll('#taskBoard [data-open-lead]').forEach(link => {
                link.addEventListener('click', () => openLeadDetails(link.dataset.openLead));
            });

            document.querySelectorAll('#taskBoard [data-open-contact]').forEach(link => {
                link.addEventListener('click', () => openContactsSection(link.dataset.openContact));
            });
        }

        function getCallCenterBaseUrl() {
            const base = window.CRM_API_BASE || window.location.origin;
            return base.endsWith('/') ? base.slice(0, -1) : base;
        }

        function buildCallCenterUrl(path, params = {}) {
            const normalizedPath = path.startsWith('/') ? path : `/${path}`;
            const url = new URL(normalizedPath, `${getCallCenterBaseUrl()}/`);
            Object.entries(params).forEach(([key, value]) => {
                if (value !== undefined && value !== null && value !== '') {
                    url.searchParams.set(key, value);
                }
            });
            return url.toString();
        }

        function buildCallCenterWebSocket(path) {
            const normalizedPath = path.startsWith('/') ? path : `/${path}`;
            const url = new URL(normalizedPath, `${getCallCenterBaseUrl()}/`);
            url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
            return url.toString();
        }

        async function refreshCallCenterData() {
            await Promise.all([
                loadCallCenterSummary(),
                loadCallCenterHistory(),
                loadCallCenterQuality()
            ]);
        }

        async function loadCallCenterSummary() {
            try {
                const response = await fetch(buildCallCenterUrl(CALL_CENTER_ENDPOINTS.summary));
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const summary = await response.json();
                updateCallCenterSummary(summary);
                setCallCenterStatus(true);
            } catch (error) {
                console.warn('Не вдалося отримати KPI контакт-центру', error);
                setCallCenterStatus(false);
            }
        }

        function updateCallCenterSummary(summary) {
            if (!summary || typeof summary !== 'object') {
                return;
            }
            callCenterLastSummary = summary;
            updateCallCenterMetrics(summary);
            updateCallCenterQueues(Array.isArray(summary.queues) ? summary.queues : []);
            updateCallCenterChartSummary(summary);
            appendCallCenterHistory(summary);
            if (callCenterHistoryCache.length) {
                renderCallCenterChart(callCenterHistoryCache);
            }
        }

        function updateCallCenterMetrics(summary) {
            const container = callCenterState.metricsContainer;
            if (!container) {
                return;
            }
            const updatedAt = summary.last_updated ? new Date(summary.last_updated) : new Date();
            const metrics = [
                {
                    label: 'Дзвінки за годину',
                    value: formatIntegerDisplay(summary.total_calls),
                    hint: `Оновлено ${formatTime(updatedAt)}`
                },
                {
                    label: 'Активні розмови',
                    value: formatIntegerDisplay(summary.active_calls),
                    hint: 'Live-статус із Zoom'
                },
                {
                    label: 'Середній час обробки',
                    value: formatDurationFromSeconds(Number(summary.avg_handle_time) || 0),
                    hint: 'AHT (Average Handle Time)'
                },
                {
                    label: 'CSAT',
                    value: `${Math.round(Number(summary.customer_satisfaction) || 0)}%`,
                    hint: 'Рівень задоволеності клієнтів'
                },
                {
                    label: 'Service level',
                    value: `${Math.round(Number(summary.service_level) || 0)}%`,
                    hint: 'Відповідь у межах цілі'
                },
                {
                    label: 'Втрачені дзвінки',
                    value: `${Math.round(Number(summary.abandonment_rate) || 0)}%`,
                    hint: 'Abandonment rate'
                }
            ];
            container.innerHTML = metrics
                .map(metric => `
                    <div class="call-center-metric">
                        <div class="metric-label">${metric.label}</div>
                        <div class="metric-value">${metric.value}</div>
                        <div class="metric-sub">${metric.hint}</div>
                    </div>
                `)
                .join('');
        }

        function updateCallCenterQueues(queues) {
            const container = callCenterState.queuesContainer;
            if (!container) {
                return;
            }
            if (!queues.length) {
                container.innerHTML = '';
                return;
            }
            container.innerHTML = queues
                .map(queue => {
                    const updatedAt = queue.captured_at ? new Date(queue.captured_at) : null;
                    return `
                        <div class="call-center-queue">
                            <strong>${escapeHtml(queue.queue || 'Черга')}</strong>
                            <div class="metric-sub">Оновлено ${updatedAt ? `${formatDate(updatedAt)} ${formatTime(updatedAt)}` : '—'}</div>
                            <div class="metric-sub">Активні: ${formatIntegerDisplay(queue.active_calls)}</div>
                            <div class="metric-sub">Service level: ${Math.round(Number(queue.service_level) || 0)}%</div>
                        </div>
                    `;
                })
                .join('');
        }

        function updateCallCenterChartSummary(summary) {
            const container = callCenterState.chartSummary;
            if (!container) {
                return;
            }
            const serviceLevel = Math.round(Number(summary.service_level) || 0);
            const csat = Math.round(Number(summary.customer_satisfaction) || 0);
            const abandonment = Math.round(Number(summary.abandonment_rate) || 0);
            container.innerHTML = `
                <span class="positive"><i class="fa-solid fa-gauge"></i> SL ${serviceLevel}%</span>
                <span class="info"><i class="fa-solid fa-face-smile"></i> CSAT ${csat}%</span>
                <span class="negative"><i class="fa-solid fa-phone-slash"></i> Втрати ${abandonment}%</span>
            `;
        }

        async function loadCallCenterHistory(limit = 24) {
            try {
                const response = await fetch(buildCallCenterUrl(CALL_CENTER_ENDPOINTS.history, { limit: String(limit) }));
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const history = await response.json();
                if (!Array.isArray(history)) {
                    return;
                }
                callCenterHistoryCache.length = 0;
                history.forEach(item => {
                    callCenterHistoryCache.push({
                        captured_at: item.captured_at,
                        total_calls: Number(item.total_calls) || 0,
                        active_calls: Number(item.active_calls) || 0,
                        avg_handle_time: Number(item.avg_handle_time) || 0,
                        service_level: Number(item.service_level) || 0,
                        customer_satisfaction: Number(item.customer_satisfaction) || 0,
                        abandonment_rate: Number(item.abandonment_rate) || 0
                    });
                });
                renderCallCenterChart(callCenterHistoryCache);
            } catch (error) {
                console.warn('Не вдалося завантажити історію KPI контакт-центру', error);
            }
        }

        function renderCallCenterChart(history) {
            const canvas = callCenterState.chartCanvas;
            if (!canvas) {
                return;
            }
            const context = canvas.getContext('2d');
            const labels = history.map(item => {
                const date = item.captured_at ? new Date(item.captured_at) : new Date();
                return formatTime(date);
            });
            const totalCalls = history.map(item => Number(item.total_calls) || 0);
            const serviceLevel = history.map(item => Number(item.service_level) || 0);

            if (callCenterState.chartInstance) {
                callCenterState.chartInstance.data.labels = labels;
                callCenterState.chartInstance.data.datasets[0].data = totalCalls;
                callCenterState.chartInstance.data.datasets[1].data = serviceLevel;
                callCenterState.chartInstance.update();
                return;
            }

            callCenterState.chartInstance = new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Дзвінки',
                            data: totalCalls,
                            borderColor: 'rgba(99, 102, 241, 1)',
                            backgroundColor: 'rgba(99, 102, 241, 0.15)',
                            fill: true,
                            tension: 0.35,
                            pointRadius: 0
                        },
                        {
                            label: 'Service level %',
                            data: serviceLevel,
                            borderColor: 'rgba(34, 197, 94, 1)',
                            backgroundColor: 'rgba(34, 197, 94, 0.15)',
                            fill: false,
                            tension: 0.35,
                            pointRadius: 0,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Дзвінки' }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            grid: { drawOnChartArea: false },
                            ticks: {
                                callback: value => `${value}%`
                            },
                            title: { display: true, text: 'Service level %' }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { usePointStyle: true }
                        }
                    }
                }
            });
        }

        function appendCallCenterHistory(summary) {
            if (!summary || !summary.last_updated) {
                return;
            }
            const entry = {
                captured_at: summary.last_updated,
                total_calls: Number(summary.total_calls) || 0,
                active_calls: Number(summary.active_calls) || 0,
                avg_handle_time: Number(summary.avg_handle_time) || 0,
                service_level: Number(summary.service_level) || 0,
                customer_satisfaction: Number(summary.customer_satisfaction) || 0,
                abandonment_rate: Number(summary.abandonment_rate) || 0
            };
            const existingIndex = callCenterHistoryCache.findIndex(item => item.captured_at === entry.captured_at);
            if (existingIndex >= 0) {
                callCenterHistoryCache[existingIndex] = entry;
            } else {
                callCenterHistoryCache.push(entry);
                callCenterHistoryCache.sort((a, b) => new Date(a.captured_at) - new Date(b.captured_at));
                if (callCenterHistoryCache.length > 48) {
                    callCenterHistoryCache.splice(0, callCenterHistoryCache.length - 48);
                }
            }
        }

        async function loadCallCenterQuality(limit = 5) {
            try {
                const response = await fetch(buildCallCenterUrl(CALL_CENTER_ENDPOINTS.quality, { limit: String(limit) }));
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const insights = await response.json();
                renderCallQualityFeed(Array.isArray(insights) ? insights : []);
            } catch (error) {
                console.warn('Не вдалося оновити AI-інсайти дзвінків', error);
            }
        }

        function renderCallQualityFeed(items) {
            const container = callCenterState.qualityContainer;
            if (!container) {
                return;
            }
            callCenterLastQuality = Array.isArray(items) ? items : [];
            if (!callCenterLastQuality.length) {
                container.innerHTML = '<div class="call-quality-empty">Очікуємо на перші розмови для аналізу…</div>';
                return;
            }
            container.innerHTML = callCenterLastQuality
                .map(item => {
                    const capturedAt = item.captured_at ? new Date(item.captured_at) : null;
                    const sentiment = (item.sentiment || 'neutral').toLowerCase();
                    const sentimentLabel = CALL_CENTER_SENTIMENT_LABELS[sentiment] || CALL_CENTER_SENTIMENT_LABELS.neutral;
                    const sentimentIcon = sentiment === 'positive'
                        ? 'fa-face-smile'
                        : sentiment === 'negative'
                            ? 'fa-face-frown'
                            : 'fa-face-meh';
                    const keywords = (item.keywords || item.key_words || []).slice(0, 4);
                    const questions = (item.key_phrases || item.keyPhrases || []).slice(0, 2);
                    const meta = [
                        item.agent ? `Агент: ${escapeHtml(item.agent)}` : '',
                        item.customer ? `Клієнт: ${escapeHtml(item.customer)}` : '',
                        item.duration_seconds ? `Тривалість: ${formatDurationFromSeconds(Number(item.duration_seconds))}` : ''
                    ].filter(Boolean);

                    return `
                        <article class="call-quality-item">
                            <div class="call-quality-meta">
                                <span class="call-quality-sentiment ${sentiment}">
                                    <i class="fa-solid ${sentimentIcon}" aria-hidden="true"></i>
                                    ${sentimentLabel}
                                </span>
                                ${capturedAt ? `<span>${formatDate(capturedAt)} ${formatTime(capturedAt)}</span>` : ''}
                                ${meta.map(part => `<span>${part}</span>`).join('')}
                            </div>
                            ${item.summary ? `<div>${escapeHtml(item.summary)}</div>` : ''}
                            ${questions.length ? `<div class="metric-sub">Питання: ${questions.map(escapeHtml).join('; ')}</div>` : ''}
                            ${keywords.length ? `<div class="call-quality-tags">${keywords.map(keyword => `<span class="call-quality-tag">${escapeHtml(keyword)}</span>`).join('')}</div>` : ''}
                            ${item.transcript_excerpt ? `<div class="metric-sub">Фрагмент: “${escapeHtml(item.transcript_excerpt)}”</div>` : ''}
                        </article>
                    `;
                })
                .join('');
        }

        function setCallCenterStatus(isOnline) {
            const badge = callCenterState.statusBadge;
            const label = callCenterState.statusLabel;
            if (!badge || !label) {
                return;
            }
            badge.classList.toggle('online', Boolean(isOnline));
            badge.classList.toggle('offline', !isOnline);
            label.textContent = isOnline ? 'Live оновлення' : 'Немає зʼєднання';
        }

        function initializeCallCenterAnalytics() {
            const card = document.getElementById('callCenterAnalyticsCard');
            if (!card || callCenterState.initialized) {
                return;
            }
            callCenterState.metricsContainer = card.querySelector('[data-call-metrics]');
            callCenterState.queuesContainer = card.querySelector('[data-call-queues]');
            callCenterState.qualityContainer = card.querySelector('[data-quality-feed]');
            callCenterState.statusBadge = document.getElementById('callCenterStatus');
            callCenterState.statusLabel = document.getElementById('callCenterStatusLabel');
            callCenterState.chartCanvas = document.getElementById('callCenterVolumeChart');
            callCenterState.chartSummary = document.getElementById('callCenterChartSummary');
            callCenterState.refreshButton = document.getElementById('callCenterRefreshBtn');
            if (callCenterState.refreshButton) {
                callCenterState.refreshButton.addEventListener('click', () => refreshCallCenterData());
            }
            refreshCallCenterData();
            connectCallCenterStreams();
            callCenterState.initialized = true;
        }

        function connectCallCenterStreams() {
            disposeCallCenterSockets();
            connectKpiStream();
            connectQualityStream();
        }

        function disposeCallCenterSockets() {
            if (callCenterState.kpiSocket) {
                callCenterState.kpiSocket.close();
                callCenterState.kpiSocket = null;
            }
            if (callCenterState.qualitySocket) {
                callCenterState.qualitySocket.close();
                callCenterState.qualitySocket = null;
            }
            if (callCenterState.reconnectHandle) {
                clearTimeout(callCenterState.reconnectHandle);
                callCenterState.reconnectHandle = null;
            }
        }

        function connectKpiStream() {
            try {
                const socket = new WebSocket(buildCallCenterWebSocket(CALL_CENTER_ENDPOINTS.kpiStream));
                callCenterState.kpiSocket = socket;
                socket.addEventListener('open', () => setCallCenterStatus(true));
                socket.addEventListener('message', event => {
                    try {
                        const payload = JSON.parse(event.data);
                        updateCallCenterSummary(payload);
                    } catch (error) {
                        console.warn('Не вдалося розпарсити KPI-повідомлення', error);
                    }
                });
                socket.addEventListener('close', () => scheduleCallCenterReconnect());
                socket.addEventListener('error', () => socket.close());
            } catch (error) {
                console.warn('Помилка підключення KPI WebSocket', error);
                scheduleCallCenterReconnect();
            }
        }

        function connectQualityStream() {
            try {
                const socket = new WebSocket(buildCallCenterWebSocket(CALL_CENTER_ENDPOINTS.qualityStream));
                callCenterState.qualitySocket = socket;
                socket.addEventListener('message', event => {
                    try {
                        const payload = JSON.parse(event.data);
                        renderCallQualityFeed(Array.isArray(payload) ? payload : []);
                    } catch (error) {
                        console.warn('Не вдалося розпарсити AI-повідомлення', error);
                    }
                });
                socket.addEventListener('close', () => scheduleCallCenterReconnect());
                socket.addEventListener('error', () => socket.close());
            } catch (error) {
                console.warn('Помилка підключення AI WebSocket', error);
                scheduleCallCenterReconnect();
            }
        }

        function scheduleCallCenterReconnect() {
            if (callCenterState.reconnectHandle) {
                return;
            }
            callCenterState.reconnectHandle = setTimeout(() => {
                callCenterState.reconnectHandle = null;
                connectCallCenterStreams();
            }, 7000);
        }

        function renderAnalytics() {
            document.getElementById('insightUpdated').textContent = `Оновлено ${formatTime(new Date())}`;
            renderConversionInsights();
            renderTeamPerformance();
            renderLeadFocus();
            renderVelocityInsights();
            setupRoleDashboardTabs();
            renderRoleDashboards();
            setupReportBuilderControls();
            renderReportBuilder();
            renderForecastingAnalytics();
            if (callCenterState.initialized) {
                if (callCenterLastSummary) {
                    updateCallCenterSummary(callCenterLastSummary);
                }
                if (callCenterHistoryCache.length) {
                    renderCallCenterChart(callCenterHistoryCache);
                }
                if (callCenterLastQuality.length) {
                    renderCallQualityFeed(callCenterLastQuality);
                }
            }
        }

        function renderConversionInsights() {
            const container = document.getElementById('conversionInsights');
            const total = crmData.leads.length || 1;
            container.innerHTML = STAGES.map(stage => {
                const count = crmData.leads.filter(lead => lead.stage === stage).length;
                const percent = Math.round((count / total) * 100);
                return `
                    <div class="progress-item">
                        <div><strong>${stage}</strong><div class="metric-sub">${percent}% угод</div></div>
                        <div class="progress-track"><div class="progress-value" style="width:${percent || count ? Math.max(percent, 6) : 4}%"></div></div>
                    </div>
                `;
            }).join('');
        }

        function renderTeamPerformance() {
            const container = document.getElementById('teamPerformance');
            container.innerHTML = TEAM_MEMBERS.map(member => {
                const leads = crmData.leads.filter(lead => lead.owner === member && lead.stage !== 'Втрачено');
                const value = leads.reduce((sum, lead) => sum + lead.value, 0);
                const tasksTotal = crmData.tasks.filter(task => task.owner === member).length;
                const tasksDone = crmData.tasks.filter(task => task.owner === member && task.status === 'done').length;
                const completion = tasksTotal ? Math.round((tasksDone / tasksTotal) * 100) : 0;
                return `
                    <div class="progress-item">
                        <div>
                            <strong>${member}</strong>
                            <div class="metric-sub">${formatCurrency(value)} у воронці</div>
                        </div>
                        <div class="progress-track"><div class="progress-value" style="width:${completion || leads.length ? Math.max(completion, 6) : 4}%"></div></div>
                        <div class="metric-sub">${completion}% виконання задач</div>
                    </div>
                `;
            }).join('');
        }

        function renderLeadFocus() {
            const container = document.getElementById('leadFocus');
            const now = new Date();
            const focus = crmData.leads
                .filter(lead => !['Угода', 'Втрачено'].includes(lead.stage))
                .map(lead => {
                    const daysIdle = daysBetween(new Date(lead.updatedAt), now);
                    const tasks = crmData.tasks.filter(task => task.relatedLeadId === lead.id && task.status !== 'done');
                    const overdue = tasks.filter(task => task.dueDate && new Date(task.dueDate) < now && !isSameDay(new Date(task.dueDate), now)).length;
                    return { lead, daysIdle, overdue, tasks: tasks.length };
                })
                .filter(item => item.daysIdle > 7 || item.overdue > 0)
                .sort((a, b) => b.overdue - a.overdue || b.daysIdle - a.daysIdle)
                .slice(0, 4);

            if (focus.length === 0) {
                container.innerHTML = '<div class="empty-state">Немає угод, що потребують негайної уваги.</div>';
                return;
            }

            container.innerHTML = focus.map(item => `
                <div class="lead-focus-item">
                    <strong>${item.lead.name}</strong>
                    <div class="focus-meta">${item.lead.company} • не оновлювалась ${item.daysIdle} дн.</div>
                    <div class="focus-meta">Відкритих задач: ${item.tasks}${item.overdue ? ` • <span style="color:#b91c1c;">прострочено ${item.overdue}</span>` : ''}</div>
                    <button class="btn btn-small-primary" data-open-lead="${item.lead.id}">Перейти до угоди</button>
                </div>
            `).join('');

            container.querySelectorAll('[data-open-lead]').forEach(btn => {
                btn.addEventListener('click', () => openLeadDetails(btn.dataset.openLead));
            });
        }

        function renderVelocityInsights() {
            const container = document.getElementById('velocityInsights');
            const now = new Date();
            const won = crmData.leads.filter(lead => lead.status === 'won' && lead.closedAt);
            const avgWin = won.length ? Math.round(won.reduce((sum, lead) => sum + daysBetween(new Date(lead.createdAt), new Date(lead.closedAt)), 0) / won.length) : 0;
            const active = crmData.leads.filter(lead => !['Угода', 'Втрачено'].includes(lead.stage));
            const avgAge = active.length ? Math.round(active.reduce((sum, lead) => sum + daysBetween(new Date(lead.createdAt), now), 0) / active.length) : 0;
            const stale = active.filter(lead => daysBetween(new Date(lead.updatedAt), now) > 14);

            container.innerHTML = `
                <div class="highlight-card">
                    <div class="highlight-label">Середній час до перемоги</div>
                    <div class="highlight-value">${avgWin || '-'} дн.</div>
                </div>
                <div class="highlight-card">
                    <div class="highlight-label">Середній вік активних угод</div>
                    <div class="highlight-value">${avgAge || '-'} дн.</div>
                </div>
                <div class="metric-sub" style="margin-top:12px;">Без активності > 14 днів: ${stale.length}</div>
                ${stale.slice(0, 3).map(lead => `<div class="timeline-entry"><strong>${lead.name}</strong><span>${lead.company} • оновлено ${formatRelativeTime(lead.updatedAt)}</span></div>`).join('')}
            `;
        }

        function setupRoleDashboardTabs() {
            const tabs = document.querySelectorAll('[data-role-dashboard]');
            if (!tabs.length) {
                return;
            }

            if (!roleDashboardState.initialized) {
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        roleDashboardState.active = tab.dataset.roleDashboard || 'sales';
                        renderRoleDashboards();
                    });
                });
                roleDashboardState.initialized = true;
            }

            updateRoleDashboardTabState();
        }

        function updateRoleDashboardTabState() {
            const tabs = document.querySelectorAll('[data-role-dashboard]');
            if (!tabs.length) {
                return;
            }

            const activeKey = roleDashboardState.active || 'sales';
            tabs.forEach(tab => {
                const isActive = tab.dataset.roleDashboard === activeKey;
                tab.classList.toggle('active', isActive);
                tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
            });
        }

        function renderRoleDashboards() {
            const container = document.getElementById('roleDashboardContent');
            if (!container) {
                return;
            }

            const dashboards = getRoleDashboardData();
            const activeKey = dashboards[roleDashboardState.active] ? roleDashboardState.active : 'sales';
            roleDashboardState.active = activeKey;
            updateRoleDashboardTabState();

            const view = dashboards[activeKey];
            if (!view) {
                container.innerHTML = '<div class="report-empty">Немає даних для обраної ролі.</div>';
                return;
            }

            container.innerHTML = `
                <div>
                    <h4 style="margin-bottom:6px;">${escapeHtml(view.title)}</h4>
                    <p class="metric-sub">${escapeHtml(view.summary)}</p>
                </div>
                <div class="role-dashboard-metrics">
                    ${view.metrics.map(metric => `
                        <div class="role-metric">
                            <span class="metric-sub" style="text-transform:uppercase; letter-spacing:0.04em;">${escapeHtml(metric.label)}</span>
                            <strong>${escapeHtml(String(metric.value))}</strong>
                            <span class="metric-sub">${escapeHtml(metric.hint)}</span>
                        </div>
                    `).join('')}
                </div>
                <div>
                    <div class="metric-sub" style="font-weight:600;">Рекомендовані віджети</div>
                    <ul class="role-dashboard-insights">
                        ${view.insights.map(item => `<li>${escapeHtml(item)}</li>`).join('')}
                    </ul>
                </div>
            `;
        }

        function getRoleDashboardData() {
            const leads = Array.isArray(crmData?.leads) ? crmData.leads : [];
            const projects = Array.isArray(crmData?.projects) ? crmData.projects : [];
            const tasks = Array.isArray(crmData?.tasks) ? crmData.tasks : [];
            const tickets = Array.isArray(crmData?.supportTickets) ? crmData.supportTickets : [];

            const activeLeads = leads.filter(lead => lead.stage !== 'Втрачено');
            const pipelineValue = activeLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0), 0);
            const weightedPipeline = activeLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0) * ((Number(lead.probability) || 0) / 100), 0);
            const hotDeals = activeLeads.filter(lead => Number(lead.probability) >= 60).length;
            const wonLeads = leads.filter(lead => lead.stage === 'Угода' || lead.status === 'won');
            const lostLeads = leads.filter(lead => lead.stage === 'Втрачено' || lead.status === 'lost');
            const totalClosed = wonLeads.length + lostLeads.length;
            const winRate = totalClosed
                ? Math.round((wonLeads.length / totalClosed) * 100)
                : (activeLeads.length ? Math.round(activeLeads.reduce((sum, lead) => sum + (Number(lead.probability) || 0), 0) / activeLeads.length) : 0);
            const avgCycle = wonLeads.length
                ? Math.round(wonLeads.reduce((sum, lead) => {
                    const start = lead.createdAt || lead.updatedAt || new Date().toISOString();
                    const end = lead.closedAt || lead.updatedAt || new Date().toISOString();
                    return sum + daysBetween(start, end);
                }, 0) / wonLeads.length)
                : 0;

            const marketingProjects = projects.filter(project => Array.isArray(project.tags) && project.tags.some(tag => tag.toLowerCase().includes('маркет')));
            const marketingBudget = marketingProjects.reduce((sum, project) => sum + (Number(project.budget) || 0), 0);
            const marketingAvgProbability = marketingProjects.length
                ? Math.round(marketingProjects.reduce((sum, project) => sum + (Number(project.probability) || 0), 0) / marketingProjects.length)
                : 0;
            const marketingActive = marketingProjects.filter(project => project.stage !== 'Підтримка');
            const marketingTasks = tasks.filter(task => Array.isArray(task.tags) && task.tags.some(tag => ['контент', 'маркетинг', 'promo', 'demo'].includes(tag.toLowerCase())));
            const marketingTasksOpen = marketingTasks.filter(task => task.status !== 'done').length;

            const supportTickets = tickets;
            const openTickets = supportTickets.filter(ticket => ['open', 'inProgress'].includes(ticket.status));
            const backlogTickets = supportTickets.filter(ticket => ticket.status === 'backlog');
            const resolvedTickets = supportTickets.filter(ticket => ticket.status === 'resolved');
            const responseTimes = supportTickets.filter(ticket => ticket.firstResponseAt).map(ticket => hoursBetween(ticket.createdAt, ticket.firstResponseAt));
            const avgResponse = responseTimes.length ? responseTimes.reduce((sum, value) => sum + value, 0) / responseTimes.length : null;
            const resolutionTimes = resolvedTickets.filter(ticket => ticket.resolvedAt).map(ticket => hoursBetween(ticket.createdAt, ticket.resolvedAt));
            const avgResolution = resolutionTimes.length ? resolutionTimes.reduce((sum, value) => sum + value, 0) / resolutionTimes.length : null;
            const csatValues = resolvedTickets.map(ticket => Number(ticket.csat)).filter(value => Number.isFinite(value) && value > 0);
            const avgCsat = csatValues.length ? csatValues.reduce((sum, value) => sum + value, 0) / csatValues.length : null;
            const slaRisk = openTickets.filter(ticket => ticket.priority === 'high' && hoursBetween(ticket.createdAt, new Date()) > 24).length;

            return {
                sales: {
                    title: 'Продажі',
                    summary: `Воронка ${formatCurrency(Math.round(pipelineValue), true)} • ${hotDeals} гарячих можливостей.`,
                    metrics: [
                        { label: 'Конверсія', value: `${winRate}%`, hint: totalClosed ? 'Win rate за закритими угодами' : 'Оцінка за поточними ймовірностями' },
                        { label: 'Активні ліди', value: activeLeads.length.toLocaleString('uk-UA'), hint: `${hotDeals} із шансом ≥60%` },
                        { label: 'Прогноз, ₴', value: formatCurrency(Math.round(weightedPipeline), true), hint: avgCycle ? `Середній цикл ${avgCycle} дн.` : 'Збираємо історію по виграних угодах' }
                    ],
                    insights: [
                        'Використовуйте віджети «Прогноз доходу» та «Динаміка продажів» для щотижневого рев’ю.',
                        'Слідкуйте за блоком «Угоди, що потребують уваги», щоб не втрачати темп у переговорах.'
                    ]
                },
                marketing: {
                    title: 'Маркетинг',
                    summary: `${marketingProjects.length} активні ініціативи • ${formatCurrency(Math.round(marketingBudget), true)} у роботі.`,
                    metrics: [
                        { label: 'Активні кампанії', value: marketingActive.length.toLocaleString('uk-UA'), hint: `${marketingTasksOpen} пов’язаних задач у роботі` },
                        { label: 'Бюджет, ₴', value: formatCurrency(Math.round(marketingBudget), true), hint: marketingAvgProbability ? `Середня ймовірність ${marketingAvgProbability}%` : 'Оцінка ймовірності ще не задана' },
                        { label: 'Контентні спринти', value: marketingTasks.length.toLocaleString('uk-UA'), hint: `${marketingTasks.filter(task => task.status === 'done').length} завершено` }
                    ],
                    insights: [
                        'Комбінуйте фільтри у «Гнучких звітах», щоб бачити ефективність за каналами.',
                        'Контролюйте завантаження матеріалів через файлові віджети та нотатки проектів.'
                    ]
                },
                support: {
                    title: 'Підтримка',
                    summary: `В роботі ${openTickets.length} звернень • backlog ${backlogTickets.length}.`,
                    metrics: [
                        { label: 'Активні звернення', value: (openTickets.length + backlogTickets.length).toLocaleString('uk-UA'), hint: `${slaRisk} SLA-подій із ризиком` },
                        { label: 'CSAT', value: avgCsat ? `${avgCsat.toFixed(1)} / 5` : '—', hint: resolvedTickets.length ? `${resolvedTickets.length} опитаних клієнтів` : 'Ще немає оцінок' },
                        { label: 'Час відповіді', value: formatHours(avgResponse), hint: avgResolution ? `Вирішення: ${formatHours(avgResolution)}` : 'Збираємо статистику' }
                    ],
                    insights: [
                        'Будуйте звіти за каналами та пріоритетами, щоб відстежувати SLA.',
                        'Додавайте клієнтів із повторними зверненнями у воронку продажів для апсейлу.'
                    ]
                }
            };
        }

        function setupReportBuilderControls() {
            const datasetSelect = document.getElementById('reportDataset');
            const periodSelect = document.getElementById('reportPeriod');
            const groupingSelect = document.getElementById('reportGrouping');
            const filterSelect = document.getElementById('reportFilter');
            const exportButton = document.getElementById('reportExportBtn');

            if (!datasetSelect || !periodSelect || !groupingSelect || !filterSelect || !exportButton) {
                return;
            }

            if (!reportBuilderState.initialized) {
                datasetSelect.addEventListener('change', () => {
                    const config = getReportConfig(datasetSelect.value);
                    reportBuilderState.dataset = config.id;
                    reportBuilderState.grouping = config.defaultGrouping;
                    reportBuilderState.filter = config.defaultFilter;
                    renderReportBuilder();
                });

                periodSelect.addEventListener('change', () => {
                    reportBuilderState.period = periodSelect.value || REPORT_PERIOD_DEFAULT;
                    renderReportBuilder();
                });

                groupingSelect.addEventListener('change', () => {
                    reportBuilderState.grouping = groupingSelect.value;
                    renderReportBuilder();
                });

                filterSelect.addEventListener('change', () => {
                    reportBuilderState.filter = filterSelect.value;
                    renderReportBuilder();
                });

                exportButton.addEventListener('click', () => exportReportToCsv());
                reportBuilderState.initialized = true;
            }
        }

        function getReportConfig(datasetId) {
            return REPORT_CONFIGS[datasetId] || REPORT_CONFIGS[REPORT_DATASET_DEFAULT];
        }

        function renderReportBuilder() {
            const datasetSelect = document.getElementById('reportDataset');
            const periodSelect = document.getElementById('reportPeriod');
            const groupingSelect = document.getElementById('reportGrouping');
            const filterSelect = document.getElementById('reportFilter');
            const summaryContainer = document.getElementById('reportSummary');
            const head = document.getElementById('reportPreviewHead');
            const body = document.getElementById('reportPreviewBody');
            const status = document.getElementById('reportExportStatus');

            if (!datasetSelect || !periodSelect || !groupingSelect || !filterSelect || !summaryContainer || !head || !body) {
                return;
            }

            if (status) {
                status.textContent = '';
            }

            const config = getReportConfig(reportBuilderState.dataset);
            datasetSelect.value = config.id;

            periodSelect.innerHTML = REPORT_PERIOD_OPTIONS.map(option => `<option value="${option.id}">${option.label}</option>`).join('');
            if (!REPORT_PERIOD_OPTIONS.some(option => option.id === reportBuilderState.period)) {
                reportBuilderState.period = REPORT_PERIOD_DEFAULT;
            }
            periodSelect.value = reportBuilderState.period;

            groupingSelect.innerHTML = Object.entries(config.groupings).map(([value, label]) => `<option value="${value}">${label}</option>`).join('');
            if (!config.groupings[reportBuilderState.grouping]) {
                reportBuilderState.grouping = config.defaultGrouping;
            }
            groupingSelect.value = reportBuilderState.grouping;

            filterSelect.innerHTML = Object.entries(config.filters).map(([value, label]) => `<option value="${value}">${label}</option>`).join('');
            if (!config.filters[reportBuilderState.filter]) {
                reportBuilderState.filter = config.defaultFilter;
            }
            filterSelect.value = reportBuilderState.filter;

            const allRecords = config.getRecords();
            const periodFiltered = filterRecordsByPeriod(allRecords, config.timeField, reportBuilderState.period);
            const filteredRecords = config.applyFilter(periodFiltered, reportBuilderState.filter);
            const report = config.buildReport(filteredRecords, reportBuilderState.grouping);
            reportBuilderState.lastReport = report;

            summaryContainer.textContent = report.summary?.text || 'Немає даних для звіту.';

            const columns = report.columns || [];
            const columnTemplate = getReportColumnTemplate(columns.length);
            head.style.gridTemplateColumns = columnTemplate;
            head.innerHTML = columns.map(column => `<span class="${column.align === 'right' ? 'align-right' : ''}">${escapeHtml(column.label)}</span>`).join('');

            if (!report.rows || !report.rows.length) {
                body.innerHTML = '<div class="report-empty">Немає даних для обраних фільтрів.</div>';
                return;
            }

            body.innerHTML = report.rows.map(row => {
                const cells = columns.map(column => {
                    const rawValue = row[column.id];
                    const formatted = typeof column.format === 'function'
                        ? column.format(rawValue)
                        : (rawValue === null || rawValue === undefined ? '—' : rawValue);
                    const text = typeof formatted === 'string' ? formatted : String(formatted);
                    return `<span class="${column.align === 'right' ? 'align-right' : ''}">${escapeHtml(text)}</span>`;
                }).join('');
                return `<div class="report-row" style="grid-template-columns:${columnTemplate};">${cells}</div>`;
            }).join('');
        }

        function filterRecordsByPeriod(records, field, periodKey) {
            const items = Array.isArray(records) ? records : [];
            const option = REPORT_PERIOD_OPTIONS.find(period => period.id === periodKey);
            if (!option || !option.days) {
                return items;
            }
            const now = new Date();
            const start = new Date(now.getTime() - option.days * 24 * 60 * 60 * 1000);
            return items.filter(record => {
                const value = record?.[field];
                if (!value) {
                    return false;
                }
                const date = new Date(value);
                if (Number.isNaN(date.getTime())) {
                    return false;
                }
                return date >= start && date <= now;
            });
        }

        function filterLeads(records, filter) {
            const items = Array.isArray(records) ? records : [];
            switch (filter) {
                case 'hot':
                    return items.filter(lead => Number(lead.probability) >= 60 && lead.stage !== 'Втрачено');
                case 'cold':
                    return items.filter(lead => Number(lead.probability) < 30 && lead.stage !== 'Втрачено');
                case 'lost':
                    return items.filter(lead => lead.stage === 'Втрачено' || lead.status === 'lost');
                default:
                    return items;
            }
        }

        function filterProjects(records, filter) {
            const items = Array.isArray(records) ? records : [];
            switch (filter) {
                case 'marketing':
                    return items.filter(project => Array.isArray(project.tags) && project.tags.some(tag => tag.toLowerCase().includes('маркет')));
                case 'delivery':
                    return items.filter(project => ['Розробка', 'Тестування', 'Запуск', 'Підтримка'].includes(project.stage));
                case 'highProbability':
                    return items.filter(project => Number(project.probability) >= 70);
                default:
                    return items;
            }
        }

        function filterSupportTickets(records, filter) {
            const items = Array.isArray(records) ? records : [];
            switch (filter) {
                case 'open':
                    return items.filter(ticket => ['open', 'inProgress'].includes(ticket.status));
                case 'backlog':
                    return items.filter(ticket => ticket.status === 'backlog');
                case 'resolved':
                    return items.filter(ticket => ticket.status === 'resolved');
                case 'high':
                    return items.filter(ticket => ticket.priority === 'high');
                default:
                    return items;
            }
        }

        function buildLeadsReport(records, grouping) {
            const items = Array.isArray(records) ? records : [];
            const config = REPORT_CONFIGS.leads;
            const groupKey = config.groupings[grouping] ? grouping : config.defaultGrouping;
            const groups = new Map();

            items.forEach(lead => {
                const group = getLeadGroup(lead, groupKey);
                if (!groups.has(group.key)) {
                    groups.set(group.key, { label: group.label, count: 0, value: 0, weighted: 0 });
                }
                const entry = groups.get(group.key);
                const value = Number(lead.value) || 0;
                const probability = Number(lead.probability) || 0;
                entry.count += 1;
                entry.value += value;
                entry.weighted += value * (probability / 100);
            });

            const sorted = Array.from(groups.values()).sort((a, b) => b.value - a.value);
            const totalValue = sorted.reduce((sum, item) => sum + item.value, 0);
            const totalWeighted = sorted.reduce((sum, item) => sum + item.weighted, 0);
            const totalCount = sorted.reduce((sum, item) => sum + item.count, 0);

            return {
                columns: [
                    { id: 'group', label: 'Група', align: 'left' },
                    { id: 'count', label: 'Угод', align: 'right', format: value => Number(value).toLocaleString('uk-UA') },
                    { id: 'value', label: 'Обсяг, ₴', align: 'right', format: value => formatCurrency(Math.round(value), true) },
                    { id: 'weighted', label: 'Очікувано, ₴', align: 'right', format: value => formatCurrency(Math.round(value), true) }
                ],
                rows: sorted.map(item => ({
                    group: item.label,
                    count: item.count,
                    value: item.value,
                    weighted: item.weighted
                })),
                summary: {
                    text: sorted.length
                        ? `У вибірці ${totalCount} угод на ${formatCurrency(Math.round(totalValue), true)}; зважений прогноз ${formatCurrency(Math.round(totalWeighted), true)}.`
                        : 'Немає даних для обраних фільтрів.'
                }
            };
        }

        function getLeadGroup(lead, grouping) {
            switch (grouping) {
                case 'owner':
                    return { key: lead.owner || 'no-owner', label: lead.owner || 'Без менеджера' };
                case 'segment':
                    const segmentKey = getLeadSegmentKey(lead);
                    return { key: segmentKey, label: LEAD_SEGMENT_LABELS[segmentKey] || segmentKey };
                case 'month':
                    return getMonthGroup(lead.createdAt || lead.updatedAt);
                default:
                    return { key: lead.stage || 'Без етапу', label: lead.stage || 'Без етапу' };
            }
        }

        function getLeadSegmentKey(lead) {
            const value = Number(lead.value) || 0;
            if (value >= 50000) {
                return 'enterprise';
            }
            if (value >= 20000) {
                return 'mid';
            }
            return 'smb';
        }

        function getMonthGroup(dateInput) {
            if (!dateInput) {
                return { key: 'no-date', label: 'Без дати' };
            }
            const date = new Date(dateInput);
            if (Number.isNaN(date.getTime())) {
                return { key: 'no-date', label: 'Без дати' };
            }
            const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            const label = new Intl.DateTimeFormat('uk-UA', { month: 'long', year: 'numeric' }).format(date);
            return { key, label };
        }

        function buildProjectsReport(records, grouping) {
            const items = Array.isArray(records) ? records : [];
            const config = REPORT_CONFIGS.projects;
            const groupKey = config.groupings[grouping] ? grouping : config.defaultGrouping;
            const groups = new Map();

            items.forEach(project => {
                const group = getProjectGroup(project, groupKey);
                if (!groups.has(group.key)) {
                    groups.set(group.key, { label: group.label, count: 0, budget: 0, probabilitySum: 0 });
                }
                const entry = groups.get(group.key);
                entry.count += 1;
                entry.budget += Number(project.budget) || 0;
                entry.probabilitySum += Number(project.probability) || 0;
            });

            const sorted = Array.from(groups.values()).sort((a, b) => b.budget - a.budget);
            const totalBudget = sorted.reduce((sum, item) => sum + item.budget, 0);
            const totalCount = sorted.reduce((sum, item) => sum + item.count, 0);
            const avgProbability = items.length
                ? Math.round(items.reduce((sum, project) => sum + (Number(project.probability) || 0), 0) / items.length)
                : 0;

            return {
                columns: [
                    { id: 'group', label: 'Група', align: 'left' },
                    { id: 'count', label: 'Проектів', align: 'right', format: value => Number(value).toLocaleString('uk-UA') },
                    { id: 'budget', label: 'Бюджет, ₴', align: 'right', format: value => formatCurrency(Math.round(value), true) },
                    { id: 'probability', label: 'Ймовірність, %', align: 'right', format: value => `${Math.round(value)}%` }
                ],
                rows: sorted.map(item => ({
                    group: item.label,
                    count: item.count,
                    budget: item.budget,
                    probability: item.count ? item.probabilitySum / item.count : 0
                })),
                summary: {
                    text: sorted.length
                        ? `Активних проектів ${totalCount} на ${formatCurrency(Math.round(totalBudget), true)} • середня ймовірність ${avgProbability}%`
                        : 'Немає проектів у вибірці.'
                }
            };
        }

        function getProjectGroup(project, grouping) {
            switch (grouping) {
                case 'owner':
                    return { key: project.owner || 'no-owner', label: project.owner || 'Без відповідального' };
                case 'tag':
                    if (Array.isArray(project.tags) && project.tags.length) {
                        return { key: project.tags[0], label: project.tags[0] };
                    }
                    return { key: 'no-tag', label: 'Без мітки' };
                case 'month':
                    return getMonthGroup(project.updatedAt || project.createdAt);
                default:
                    return { key: project.stage || 'Без етапу', label: project.stage || 'Без етапу' };
            }
        }

        function buildSupportReport(records, grouping) {
            const items = Array.isArray(records) ? records : [];
            const config = REPORT_CONFIGS.support;
            const groupKey = config.groupings[grouping] ? grouping : config.defaultGrouping;
            const groups = new Map();

            items.forEach(ticket => {
                const group = getSupportGroup(ticket, groupKey);
                if (!groups.has(group.key)) {
                    groups.set(group.key, { label: group.label, count: 0, csat: [], resolution: [] });
                }
                const entry = groups.get(group.key);
                entry.count += 1;
                const csatValue = Number(ticket.csat);
                if (Number.isFinite(csatValue) && csatValue > 0) {
                    entry.csat.push(csatValue);
                }
                if (ticket.resolvedAt) {
                    entry.resolution.push(hoursBetween(ticket.createdAt, ticket.resolvedAt));
                }
            });

            const sorted = Array.from(groups.values()).sort((a, b) => b.count - a.count);
            const openCount = items.filter(ticket => ['open', 'inProgress'].includes(ticket.status)).length;
            const backlogCount = items.filter(ticket => ticket.status === 'backlog').length;
            const csatValues = items.map(ticket => Number(ticket.csat)).filter(value => Number.isFinite(value) && value > 0);
            const avgCsat = csatValues.length ? csatValues.reduce((sum, value) => sum + value, 0) / csatValues.length : null;
            const responseTimes = items.filter(ticket => ticket.firstResponseAt).map(ticket => hoursBetween(ticket.createdAt, ticket.firstResponseAt));
            const avgResponse = responseTimes.length ? responseTimes.reduce((sum, value) => sum + value, 0) / responseTimes.length : null;

            return {
                columns: [
                    { id: 'group', label: 'Група', align: 'left' },
                    { id: 'count', label: 'Звернень', align: 'right', format: value => Number(value).toLocaleString('uk-UA') },
                    { id: 'csat', label: 'CSAT', align: 'right', format: value => value ? `${value.toFixed(1)} / 5` : '—' },
                    { id: 'resolution', label: 'Сер. вирішення, год', align: 'right', format: value => formatHours(value) }
                ],
                rows: sorted.map(item => ({
                    group: item.label,
                    count: item.count,
                    csat: item.csat.length ? item.csat.reduce((sum, value) => sum + value, 0) / item.csat.length : null,
                    resolution: item.resolution.length ? item.resolution.reduce((sum, value) => sum + value, 0) / item.resolution.length : null
                })),
                summary: {
                    text: `Активних звернень ${openCount}, backlog ${backlogCount}${avgCsat ? ` • середній CSAT ${avgCsat.toFixed(1)}/5` : ''}${avgResponse ? ` • час відповіді ${formatHours(avgResponse)}` : ''}`.trim()
                }
            };
        }

        function getSupportGroup(ticket, grouping) {
            switch (grouping) {
                case 'channel':
                    return { key: ticket.channel || 'other', label: ticket.channel || 'Інший канал' };
                case 'priority':
                    return { key: ticket.priority || 'medium', label: SUPPORT_PRIORITY_LABELS[ticket.priority] || SUPPORT_PRIORITY_LABELS.medium };
                case 'owner':
                    return { key: ticket.owner || 'team', label: ticket.owner || 'Команда підтримки' };
                default:
                    return { key: ticket.status || 'open', label: SUPPORT_STATUS_LABELS[ticket.status] || SUPPORT_STATUS_LABELS.open };
            }
        }

        function getReportColumnTemplate(columnCount) {
            if (!Number.isFinite(columnCount) || columnCount <= 1) {
                return 'minmax(0, 1fr)';
            }
            const trailing = new Array(columnCount - 1).fill('minmax(0, 0.9fr)').join(' ');
            return `minmax(0, 1.4fr) ${trailing}`;
        }

        function exportReportToCsv() {
            const report = reportBuilderState.lastReport;
            const status = document.getElementById('reportExportStatus');
            if (!report || !Array.isArray(report.columns)) {
                if (status) {
                    status.textContent = 'Немає даних для експорту.';
                }
                return;
            }

            const columns = report.columns;
            const rows = Array.isArray(report.rows) ? report.rows : [];
            const header = columns.map(column => `"${column.label.replace(/"/g, '""')}"`).join(';');
            const body = rows.map(row => columns.map(column => {
                const value = row[column.id];
                if (value === null || value === undefined) {
                    return '""';
                }
                if (typeof value === 'number') {
                    return String(value);
                }
                const text = String(value).replace(/"/g, '""');
                return `"${text}"`;
            }).join(';'));
            const csv = [header, ...body].join('\n');
            const blob = new Blob([`\uFEFF${csv}`], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const dataset = reportBuilderState.dataset || REPORT_DATASET_DEFAULT;
            link.href = url;
            link.download = `crm-report-${dataset}-${Date.now()}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            if (status) {
                const config = getReportConfig(dataset);
                status.textContent = `Експортовано ${config.entity.toLowerCase()} • ${new Date().toLocaleString('uk-UA')}`;
            }
        }

        function renderForecastingAnalytics() {
            const summaryContainer = document.getElementById('forecastingSummary');
            const head = document.getElementById('forecastingHead');
            const table = document.getElementById('forecastingTable');
            if (!summaryContainer || !head || !table) {
                return;
            }

            const activeLeads = Array.isArray(crmData?.leads)
                ? crmData.leads.filter(lead => lead.stage !== 'Втрачено')
                : [];

            if (!activeLeads.length) {
                summaryContainer.innerHTML = '<div class="forecasting-empty">Немає угод для прогнозу.</div>';
                head.innerHTML = '';
                table.innerHTML = '';
                return;
            }

            const totalWeighted = activeLeads.reduce((sum, lead) => sum + (Number(lead.value) || 0) * ((Number(lead.probability) || 0) / 100), 0);
            const avgProbability = Math.round(activeLeads.reduce((sum, lead) => sum + (Number(lead.probability) || 0), 0) / activeLeads.length);
            const now = new Date();
            const thisMonthWeighted = activeLeads
                .filter(lead => isSameMonth(lead.expectedClose, now.getFullYear(), now.getMonth()))
                .reduce((sum, lead) => sum + (Number(lead.value) || 0) * ((Number(lead.probability) || 0) / 100), 0);
            const thisMonthCount = activeLeads.filter(lead => isSameMonth(lead.expectedClose, now.getFullYear(), now.getMonth())).length;
            const nextMonthDate = new Date(now.getFullYear(), now.getMonth() + 1, 1);
            const nextMonthWeighted = activeLeads
                .filter(lead => isSameMonth(lead.expectedClose, nextMonthDate.getFullYear(), nextMonthDate.getMonth()))
                .reduce((sum, lead) => sum + (Number(lead.value) || 0) * ((Number(lead.probability) || 0) / 100), 0);
            const noDateCount = activeLeads.filter(lead => !lead.expectedClose).length;

            summaryContainer.innerHTML = `
                <div class="forecasting-metric">
                    <span class="metric-label">Зважений прогноз</span>
                    <strong>${formatCurrency(Math.round(totalWeighted))}</strong>
                    <div class="metric-sub">Ураховано вартість та ймовірність закриття.</div>
                </div>
                <div class="forecasting-metric">
                    <span class="metric-label">Очікувано цього місяця</span>
                    <strong>${formatCurrency(Math.round(thisMonthWeighted))}</strong>
                    <div class="metric-sub">${thisMonthCount ? `${thisMonthCount} угод у роботі` : 'Без очікуваних закриттів'}</div>
                    <div class="metric-sub">Наступний місяць: ${formatCurrency(Math.round(nextMonthWeighted))}</div>
                </div>
                <div class="forecasting-metric">
                    <span class="metric-label">Середня ймовірність</span>
                    <strong>${avgProbability}%</strong>
                    <div class="metric-sub">${noDateCount ? `${noDateCount} угод без дати` : 'Усі угоди мають дати'}</div>
                </div>
            `;

            const columnTemplate = 'minmax(0, 1.4fr) repeat(4, minmax(0, 0.9fr))';
            head.style.gridTemplateColumns = columnTemplate;
            head.innerHTML = `
                <span>Угода</span>
                <span class="align-right">Менеджер</span>
                <span class="align-right">Очікуване закриття</span>
                <span class="align-right">Ймовірність</span>
                <span class="align-right">Зважений дохід</span>
            `;

            const upcoming = activeLeads.slice().sort((a, b) => {
                const dateA = a.expectedClose ? new Date(a.expectedClose) : null;
                const dateB = b.expectedClose ? new Date(b.expectedClose) : null;
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;
                return dateA - dateB;
            });

            const rows = upcoming.slice(0, 6).map(lead => {
                const weighted = (Number(lead.value) || 0) * ((Number(lead.probability) || 0) / 100);
                const expectedLabel = lead.expectedClose ? formatDate(lead.expectedClose, { day: '2-digit', month: 'short' }) : 'Без дати';
                return `
                    <div class="forecasting-row" style="grid-template-columns:${columnTemplate};">
                        <span>${escapeHtml(lead.name || 'Угода')}</span>
                        <span class="align-right">${escapeHtml(lead.owner || '—')}</span>
                        <span class="align-right">${expectedLabel}</span>
                        <span class="align-right">${Math.round(Number(lead.probability) || 0)}%</span>
                        <span class="align-right">${formatCurrency(Math.round(weighted))}</span>
                    </div>
                `;
            });

            table.innerHTML = rows.length ? rows.join('') : '<div class="forecasting-empty">Угоди без визначеної дати закриття.</div>';
        }

        function isSameMonth(dateInput, year, month) {
            if (!dateInput && dateInput !== 0) {
                return false;
            }
            const date = new Date(dateInput);
            if (Number.isNaN(date.getTime())) {
                return false;
            }
            return date.getFullYear() === year && date.getMonth() === month;
        }
        function handleGlobalSearch(value) {
            const results = document.getElementById('searchResults');
            const query = value.trim().toLowerCase();
            if (!query) {
                hideSearchResults();
                return;
            }

            const projectMatches = crmData.projects.filter(project => {
                return [
                    project.name,
                    project.company,
                    project.owner,
                    project.contact,
                    ...(Array.isArray(project.tags) ? project.tags : [])
                ]
                    .filter(Boolean)
                    .some(field => field.toLowerCase().includes(query));
            }).slice(0, 4);

            const leadMatches = crmData.leads.filter(lead => {
                return [lead.name, lead.company, lead.contact?.person]
                    .filter(Boolean)
                    .some(field => field.toLowerCase().includes(query));
            }).slice(0, 4);

            const contactMatches = crmData.contacts.filter(contact => {
                return [contact.name, contact.company, contact.email]
                    .filter(Boolean)
                    .some(field => field.toLowerCase().includes(query));
            }).slice(0, 4);

            const taskMatches = crmData.tasks.filter(task => task.title.toLowerCase().includes(query)).slice(0, 3);

            if (!projectMatches.length && !leadMatches.length && !contactMatches.length && !taskMatches.length) {
                results.innerHTML = '<div class="search-empty">Нічого не знайдено</div>';
                results.classList.add('active');
                return;
            }

            results.innerHTML = `
                ${projectMatches.length ? `
                    <div class="search-group">
                        <div class="search-group-title">Проекти</div>
                        ${projectMatches.map(project => `<div class="search-result" data-result-project="${project.id}"><span>${project.name}</span><span class="metric-sub">${project.company || ''}</span></div>`).join('')}
                    </div>` : ''}
                ${leadMatches.length ? `
                    <div class="search-group">
                        <div class="search-group-title">Угоди</div>
                        ${leadMatches.map(lead => `<div class="search-result" data-result-lead="${lead.id}"><span>${lead.name}</span><span class="metric-sub">${lead.company}</span></div>`).join('')}
                    </div>` : ''}
                ${contactMatches.length ? `
                    <div class="search-group">
                        <div class="search-group-title">Контакти</div>
                        ${contactMatches.map(contact => `<div class="search-result" data-result-contact="${contact.id}"><span>${contact.name}</span><span class="metric-sub">${contact.company || ''}</span></div>`).join('')}
                    </div>` : ''}
                ${taskMatches.length ? `
                    <div class="search-group">
                        <div class="search-group-title">Завдання</div>
                        ${taskMatches.map(task => `<div class="search-result" data-result-task="${task.id}"><span>${task.title}</span><span class="metric-sub">${formatDate(task.dueDate)}</span></div>`).join('')}
                    </div>` : ''}
            `;

            results.classList.add('active');

            results.querySelectorAll('[data-result-project]').forEach(item => {
                item.addEventListener('click', () => {
                    focusProject(item.dataset.resultProject);
                    hideSearchResults();
                });
            });

            results.querySelectorAll('[data-result-lead]').forEach(item => {
                item.addEventListener('click', () => {
                    openLeadDetails(item.dataset.resultLead);
                    hideSearchResults();
                });
            });

            results.querySelectorAll('[data-result-contact]').forEach(item => {
                item.addEventListener('click', () => {
                    const contact = crmData.contacts.find(c => c.id === item.dataset.resultContact);
                    if (contact) {
                        openContactsSection(contact.id);
                    }
                    hideSearchResults();
                });
            });

            results.querySelectorAll('[data-result-task]').forEach(item => {
                item.addEventListener('click', () => {
                    const task = crmData.tasks.find(t => t.id === item.dataset.resultTask);
                    if (task?.relatedLeadId) {
                        openLeadDetails(task.relatedLeadId);
                    } else if (task?.relatedContactId) {
                        openContactsSection(task.relatedContactId);
                    }
                    hideSearchResults();
                });
            });
        }

        function hideSearchResults() {
            const results = document.getElementById('searchResults');
            results.classList.remove('active');
            results.innerHTML = '';
        }

        function getAttachmentIcon(type = '') {
            if (!type) return 'fa-file-lines';
            const normalized = type.toLowerCase();
            if (normalized.includes('pdf')) return 'fa-file-pdf';
            if (normalized.startsWith('image/')) return 'fa-image';
            if (normalized.startsWith('video/')) return 'fa-file-video';
            if (normalized.startsWith('audio/')) return 'fa-file-audio';
            if (normalized.includes('zip') || normalized.includes('compressed')) return 'fa-file-zipper';
            if (normalized.includes('sheet') || normalized.includes('excel')) return 'fa-file-excel';
            if (normalized.includes('presentation') || normalized.includes('powerpoint') || normalized.includes('ppt')) return 'fa-file-powerpoint';
            if (normalized.includes('word') || normalized.includes('document')) return 'fa-file-word';
            if (normalized.includes('text')) return 'fa-file-lines';
            return 'fa-file';
        }

        function getActivityIcon(type) {
            switch (type) {
                case 'stage':
                    return 'fa-solid fa-diagram-project';
                case 'note':
                    return 'fa-solid fa-pen-to-square';
                case 'task':
                    return 'fa-solid fa-square-check';
                case 'role':
                    return 'fa-solid fa-user-shield';
                case 'won':
                    return 'fa-solid fa-trophy';
                case 'lost':
                    return 'fa-solid fa-face-frown';
                case 'automation':
                    return 'fa-solid fa-bolt';
                case 'reminder':
                    return 'fa-solid fa-bell';
                case 'calendar':
                    return 'fa-solid fa-calendar-check';
                default:
                    return 'fa-solid fa-circle-info';
            }
        }
        function openModal(id) {
            const modal = document.getElementById(id);
            if (modal) {
                modal.classList.add('active');
            }
        }

        function closeModal(id) {
            const modal = document.getElementById(id);
            if (!modal) {
                return;
            }

            modal.classList.remove('active');
            if (id === 'leadDetailsModal') {
                activeLeadId = null;
            }

            const areaKeys = MODAL_ATTACHMENT_AREAS[id];
            if (Array.isArray(areaKeys)) {
                areaKeys.forEach(resetAttachmentArea);
            }
        }

        function resetDemoData() {
            if (confirm('Скинути дані та повернути демо-набір?')) {
                crmData = upgradeDataStructure(deepClone(defaultData));
                activeLeadId = null;
                activeContactId = null;
                contactComposerState.clear();
                Object.values(MODAL_ATTACHMENT_AREAS).forEach(areaList => {
                    areaList.forEach(areaKey => resetAttachmentArea(areaKey));
                });
                activeFileSnapshotId = Array.isArray(crmData.fileLibrary) && crmData.fileLibrary.length
                    ? crmData.fileLibrary[0].id
                    : null;
                const snapshotSources = Array.isArray(crmData.fileSources) ? crmData.fileSources : [];
                const linkedSource = snapshotSources.find(source => source.snapshotId === activeFileSnapshotId) || null;
                activeFileSourceId = linkedSource ? linkedSource.id : null;
                pendingFileSourceId = null;
                fileSearchTerm = '';
                pipelineFilterOwner = 'all';
                contactStatusFilter = 'all';
                contactTagFilter = [];
                activeContactId = null;
                projectStageFilter = 'all';
                projectMinProbability = 0;
                projectSearchTerm = '';
                saveData();
                leadOwnerManuallySelected = false;
                populateDropdowns();

                const pipelineFilter = document.getElementById('pipelineOwnerFilter');
                if (pipelineFilter) {
                    pipelineFilter.value = pipelineFilterOwner;
                }

                const contactSearchInput = document.getElementById('contactSearch');
                if (contactSearchInput) {
                    contactSearchInput.value = '';
                }

                const contactStatusSelect = document.getElementById('contactStatusFilter');
                if (contactStatusSelect) {
                    contactStatusSelect.value = contactStatusFilter;
                }

                const contactTagInput = document.getElementById('contactTagFilter');
                if (contactTagInput) {
                    contactTagInput.value = '';
                }

                const globalSearchInput = document.getElementById('globalSearch');
                if (globalSearchInput) {
                    globalSearchInput.value = '';
                }
                hideSearchResults();

                const navSearchInput = document.getElementById('navSearch');
                if (navSearchInput) {
                    navSearchInput.value = '';
                }

                const navFilterSelect = document.getElementById('navFilter');
                if (navFilterSelect) {
                    navFilterSelect.value = 'all';
                }

                navigationState.search = '';
                navigationState.filter = 'all';
                applyNavigationFilters();

                const projectSearchInput = document.getElementById('projectSearch');
                if (projectSearchInput) {
                    projectSearchInput.value = '';
                }

                const projectStageSelect = document.getElementById('projectStageFilter');
                if (projectStageSelect) {
                    projectStageSelect.value = 'all';
                }

                const projectProbabilityRange = document.getElementById('projectProbabilityRange');
                if (projectProbabilityRange) {
                    projectProbabilityRange.value = 0;
                }

                const projectProbabilityValue = document.getElementById('projectProbabilityValue');
                if (projectProbabilityValue) {
                    projectProbabilityValue.textContent = '0%+';
                }

                renderAll();
                updateFileSnapshotsSelect();
                renderFileSources();
            }
        }

        async function handleLeadSubmit(event) {
            event.preventDefault();
            const form = event.target;
            const submitButton = form.querySelector('button[type="submit"]');
            const originalText = submitButton ? submitButton.textContent : '';

            try {
                if (submitButton) {
                    submitButton.disabled = true;
                    submitButton.textContent = 'Збереження...';
                }

                const attachments = await prepareAttachmentsForArea('lead');
                const now = new Date().toISOString();
                const stageValue = document.getElementById('leadStage').value;
                const sourceValue = document.getElementById('leadSource').value;
                const qualificationValue = document.getElementById('leadQualification').value || 'new';
                const scoreValue = Math.max(0, Math.min(100, Number(document.getElementById('leadScore').value) || LEAD_SCORE_DEFAULT));
                const probabilityValue = Number(document.getElementById('leadProbability').value) || 0;
                const ownerSelect = document.getElementById('leadOwner');
                let ownerValue = ownerSelect ? ownerSelect.value : '';
                if (!ownerValue) {
                    ownerValue = suggestLeadOwner(sourceValue);
                }

                const expectedCloseInput = document.getElementById('leadExpectedClose');
                let expectedCloseValue = expectedCloseInput ? expectedCloseInput.value : '';
                if (!expectedCloseValue && stageValue === 'Угода') {
                    expectedCloseValue = now.split('T')[0];
                }

                const lead = {
                    id: generateId('lead'),
                    name: document.getElementById('leadTitle').value.trim(),
                    company: document.getElementById('leadCompany').value.trim(),
                    stage: stageValue,
                    value: Number(document.getElementById('leadValue').value) || 0,
                    probability: probabilityValue,
                    owner: ownerValue,
                    source: sourceValue,
                    qualification: qualificationValue,
                    score: scoreValue,
                    status: 'active',
                    expectedClose: expectedCloseValue,
                    contact: {
                        id: generateId('contact'),
                        person: document.getElementById('leadContactName').value.trim(),
                        email: document.getElementById('leadContactEmail').value.trim(),
                        phone: document.getElementById('leadContactPhone').value.trim()
                    },
                    tags: document.getElementById('leadTags').value.split(',').map(tag => tag.trim()).filter(Boolean),
                    createdAt: now,
                    updatedAt: now,
                    notes: [],
                    timeline: [],
                    attachments,
                    automation: normalizeLeadAutomation({})
                };

                if (lead.stage === 'Угода') {
                    lead.status = 'won';
                    lead.closedAt = now;
                    lead.probability = 100;
                    lead.automation.lastAutoStage = 'Угода';
                    lead.automation.calendarSynced = true;
                }

                const initialNote = document.getElementById('leadNotes').value.trim();
                if (initialNote) {
                    lead.notes.push({ id: generateId('note'), text: initialNote, author: 'Ви', date: now });
                }

                addTimelineEntry(lead, `Створено лід ${lead.name}`);
                addTimelineEntry(lead, `Стадія встановлена: ${lead.stage}`);
                addTimelineEntry(lead, `Джерело: ${getLeadSourceLabel(lead.source)} • Готовність ${lead.score}%`);

                if (attachments.length) {
                    const preview = attachments.slice(0, 3).map(file => (file.name || '').replace(/[<>]/g, '')).join(', ');
                    addTimelineEntry(lead, `Додано файли: ${preview}${attachments.length > 3 ? '…' : ''}`);
                }

                crmData.leads.unshift(lead);

                if (lead.contact.person || lead.contact.email) {
                    const existingContact = crmData.contacts.find(contact => contact.email && contact.email === lead.contact.email);
                    if (!existingContact) {
                        crmData.contacts.unshift({
                            id: lead.contact.id,
                            name: lead.contact.person || lead.name,
                            company: lead.company,
                            role: '',
                            email: lead.contact.email,
                            phone: lead.contact.phone,
                            status: 'lead',
                            segments: ['lead', 'potential'],
                            lifecycleStage: 'prospect',
                            owner: lead.owner,
                            preferredChannel: lead.contact.email ? 'email' : 'phone',
                            timezone: 'Europe/Kyiv',
                            website: '',
                            linkedin: '',
                            address: { street: '', city: '', country: '', postalCode: '' },
                            demographics: { industry: '', employees: null, annualRevenue: null },
                            tags: Array.isArray(lead.tags) ? lead.tags.filter(Boolean) : [],
                            attachments: [],
                            notes: [],
                            interactions: [
                                {
                                    id: generateId('cact'),
                                    type: 'note',
                                    channel: 'system',
                                    subject: 'Контакт створено з ліда',
                                    summary: `Контакт додано разом з угодою ${lead.name}.`,
                                    timestamp: now,
                                    author: CURRENT_USER.name,
                                    tags: ['Лід']
                                }
                            ],
                            lastActivity: now
                        });
                    }
                }

                logActivity(`Додано нову угоду ${lead.name} для ${lead.company} (${getLeadSourceLabel(lead.source)}).`, 'stage', lead.id);
                if (attachments.length) {
                    logActivity(`Додано ${attachments.length} файл(и) до ${lead.name}.`, 'note', lead.id);
                }

                saveData();
                updateTaskLeadOptions();
                renderAll();
                form.reset();
                resetAttachmentArea('lead');
                closeModal('addLeadModal');
            } catch (error) {
                console.error('Не вдалося створити лід', error);
                alert('Не вдалося зберегти лід. Будь ласка, спробуйте ще раз.');
            } finally {
                leadOwnerManuallySelected = false;
                updateLeadOwnerSuggestion(true);
                if (submitButton) {
                    submitButton.disabled = false;
                    submitButton.textContent = originalText;
                }
            }
        }

        async function handleProjectSubmit(event) {
            event.preventDefault();
            const form = event.target;
            const submitButton = form.querySelector('button[type="submit"]');
            const originalText = submitButton ? submitButton.textContent : '';

            try {
                if (submitButton) {
                    submitButton.disabled = true;
                    submitButton.textContent = 'Збереження...';
                }

                const now = new Date().toISOString();
                const attachments = await prepareAttachmentsForArea('project');
                const teamSelect = document.getElementById('projectTeam');
                const selectedTeam = teamSelect
                    ? Array.from(teamSelect.selectedOptions).map(option => option.value).filter(Boolean)
                    : [];
                const tags = document.getElementById('projectTags').value
                    .split(',')
                    .map(tag => tag.trim())
                    .filter(Boolean);
                const notes = document.getElementById('projectNotes').value
                    .split('\n')
                    .map(note => note.trim())
                    .filter(Boolean)
                    .map(text => ({ id: generateId('pnote'), text, author: CURRENT_USER.name, date: now }));

                const project = {
                    id: generateId('project'),
                    name: document.getElementById('projectName').value.trim(),
                    company: document.getElementById('projectCompany').value.trim(),
                    stage: document.getElementById('projectStage').value,
                    budget: Number(document.getElementById('projectBudget').value) || 0,
                    probability: Math.max(0, Math.min(100, Number(document.getElementById('projectProbability').value) || 0)),
                    owner: document.getElementById('projectOwner').value,
                    contact: document.getElementById('projectContact').value.trim(),
                    team: selectedTeam,
                    tags,
                    description: document.getElementById('projectSummary').value.trim(),
                    notes,
                    attachments,
                    createdAt: now,
                    updatedAt: now
                };

                crmData.projects.unshift(project);
                saveData();

                if (projectStageFilter !== 'all' && project.stage !== projectStageFilter) {
                    projectStageFilter = 'all';
                }

                if (projectMinProbability > project.probability) {
                    projectMinProbability = 0;
                }

                if (projectSearchTerm) {
                    projectSearchTerm = '';
                }

                renderProjects(projectSearchTerm);
                closeModal('addProjectModal');
                form.reset();
                resetAttachmentArea('project');
                if (teamSelect) {
                    Array.from(teamSelect.options).forEach(option => {
                        option.selected = false;
                    });
                }

                focusProject(project.id);
            } finally {
                if (submitButton) {
                    submitButton.disabled = false;
                    submitButton.textContent = originalText;
                }
            }
        }

        async function handleContactSubmit(event) {
            event.preventDefault();
            const now = new Date().toISOString();
            const attachments = await prepareAttachmentsForArea('contact');
            const noteText = document.getElementById('contactNotes').value.trim();
            const statusValue = document.getElementById('contactStatus').value;
            const normalizedStatus = CONTACT_SEGMENT_SET.has(statusValue) ? statusValue : 'lead';
            const segmentsSelect = document.getElementById('contactSegments');
            const selectedSegments = segmentsSelect
                ? Array.from(segmentsSelect.selectedOptions)
                    .map(option => option.value)
                    .filter(value => CONTACT_SEGMENT_SET.has(value))
                : [];
            if (!selectedSegments.includes(normalizedStatus)) {
                selectedSegments.unshift(normalizedStatus);
            }

            const lifecycleValue = document.getElementById('contactLifecycle').value;
            const lifecycleStage = CONTACT_LIFECYCLE_LABELS[lifecycleValue]
                ? lifecycleValue
                : (['customer', 'vip', 'partner'].includes(normalizedStatus) ? 'customer' : 'prospect');

            const preferredChannelValue = document.getElementById('contactChannel').value;
            const preferredChannel = CONTACT_CHANNEL_LABELS[preferredChannelValue]
                ? preferredChannelValue
                : (document.getElementById('contactEmail').value.trim() ? 'email' : 'phone');

            const employeesValue = Number(document.getElementById('contactEmployees').value);
            const revenueValue = Number(document.getElementById('contactRevenue').value);
            const demographics = {
                industry: document.getElementById('contactIndustry').value.trim(),
                employees: Number.isFinite(employeesValue) && employeesValue >= 0 ? Math.round(employeesValue) : null,
                annualRevenue: Number.isFinite(revenueValue) && revenueValue >= 0 ? Math.round(revenueValue) : null
            };

            const tags = document.getElementById('contactTags').value
                .split(',')
                .map(tag => tag.trim())
                .filter(Boolean);

            const contact = {
                id: generateId('contact'),
                name: document.getElementById('contactName').value.trim(),
                company: document.getElementById('contactCompany').value.trim(),
                role: document.getElementById('contactRole').value.trim(),
                email: document.getElementById('contactEmail').value.trim(),
                phone: document.getElementById('contactPhone').value.trim(),
                status: normalizedStatus,
                segments: selectedSegments,
                lifecycleStage,
                owner: document.getElementById('contactOwner').value,
                preferredChannel,
                timezone: document.getElementById('contactTimezone').value.trim() || 'Europe/Kyiv',
                website: document.getElementById('contactWebsite').value.trim(),
                linkedin: document.getElementById('contactLinkedin').value.trim(),
                address: {
                    street: document.getElementById('contactStreet').value.trim(),
                    city: document.getElementById('contactCity').value.trim(),
                    country: document.getElementById('contactCountry').value.trim(),
                    postalCode: document.getElementById('contactPostal').value.trim()
                },
                demographics,
                tags,
                attachments,
                notes: noteText ? [{ id: generateId('cnote'), text: noteText, author: CURRENT_USER.name, date: now }] : [],
                interactions: [
                    {
                        id: generateId('cact'),
                        type: 'note',
                        channel: 'system',
                        subject: 'Контакт створено',
                        summary: `Контакт додано ${CURRENT_USER.name}.`,
                        timestamp: now,
                        author: CURRENT_USER.name,
                        tags: ['Створення']
                    }
                ],
                lastActivity: now
            };

            if (noteText) {
                contact.interactions.unshift({
                    id: generateId('cact'),
                    type: 'note',
                    channel: 'note',
                    subject: 'Нотатка менеджера',
                    summary: noteText,
                    timestamp: now,
                    author: CURRENT_USER.name,
                    tags: ['Нотатка']
                });
            }

            crmData.contacts.unshift(contact);
            activeContactId = contact.id;
            logActivity(`Додано новий контакт ${contact.name}.`, 'note', contact.id);
            saveData();
            renderContacts(document.getElementById('contactSearch').value || '');
            closeModal('addContactModal');
            event.target.reset();
            resetAttachmentArea('contact');

            const statusSelect = document.getElementById('contactStatus');
            if (statusSelect) {
                statusSelect.value = CONTACT_SEGMENT_OPTIONS[0]?.id || 'lead';
            }
            const lifecycleSelect = document.getElementById('contactLifecycle');
            if (lifecycleSelect) {
                lifecycleSelect.value = 'prospect';
            }
            const channelSelect = document.getElementById('contactChannel');
            if (channelSelect) {
                channelSelect.value = 'email';
            }
            const timezoneInput = document.getElementById('contactTimezone');
            if (timezoneInput) {
                timezoneInput.value = 'Europe/Kyiv';
            }
            const segmentsSelectReset = document.getElementById('contactSegments');
            if (segmentsSelectReset) {
                Array.from(segmentsSelectReset.options).forEach(option => {
                    option.selected = false;
                });
            }
        }

        function openTaskModal(leadId = '') {
            updateTaskLeadOptions();
            const select = document.getElementById('taskLead');
            select.value = leadId || '';
            document.getElementById('taskStatus').value = 'todo';
            document.getElementById('taskPriority').value = 'medium';
            const dateInput = document.getElementById('taskDueDate');
            if (dateInput && !dateInput.value) {
                const tomorrow = startOfDay(new Date());
                if (tomorrow) {
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    dateInput.value = formatDateForInput(tomorrow);
                }
            }
            openModal('addTaskModal');
        }

        async function handleTaskSubmit(event) {
            event.preventDefault();
            const attachments = await prepareAttachmentsForArea('task');
            const task = {
                id: generateId('task'),
                title: document.getElementById('taskTitle').value.trim(),
                owner: document.getElementById('taskOwner').value,
                dueDate: document.getElementById('taskDueDate').value,
                priority: document.getElementById('taskPriority').value,
                status: document.getElementById('taskStatus').value,
                relatedLeadId: document.getElementById('taskLead').value,
                description: document.getElementById('taskDescription').value.trim(),
                tags: document.getElementById('taskTags').value.split(',').map(tag => tag.trim()).filter(Boolean),
                attachments
            };

            if (task.status === 'done') {
                task.completedAt = new Date().toISOString();
            }

            crmData.tasks.unshift(task);
            if (task.relatedLeadId) {
                const lead = crmData.leads.find(item => item.id === task.relatedLeadId);
                if (lead) {
                    addTimelineEntry(lead, `Додано завдання: ${task.title}`);
                }
            }
            logActivity(`Нове завдання: ${task.title}.`, 'task', task.id);
            saveData();
            renderTasks();
            renderUpcomingActivities();
            renderPipeline();
            renderLeadFocus();
            closeModal('addTaskModal');
            event.target.reset();
            resetAttachmentArea('task');
        }

        function updateTaskStatus(taskId, status) {
            const task = crmData.tasks.find(item => item.id === taskId);
            if (!task) return;
            task.status = status;
            if (status === 'done') {
                task.completedAt = new Date().toISOString();
            }
            saveData();
            renderTasks();
            renderDashboard();
            renderPipeline();
            renderLeadFocus();
        }

        function logActivity(message, type = 'note', entityId = null) {
            crmData.activities.unshift({
                id: generateId('act'),
                type,
                entityId,
                message,
                timestamp: new Date().toISOString()
            });
            crmData.activities = crmData.activities.slice(0, 40);

            const currentLeads = pipelineFilterOwner === 'all'
                ? crmData.leads
                : crmData.leads.filter(lead => lead.owner === pipelineFilterOwner);
            renderPipelineActivity(currentLeads);
        }

        function addTimelineEntry(lead, text) {
            lead.timeline.unshift({ id: generateId('tl'), text, date: new Date().toISOString() });
        }

        function moveLeadToStage(leadId, stage) {
            const lead = crmData.leads.find(item => item.id === leadId);
            if (!lead || lead.stage === stage) return;
            const previousStage = lead.stage;
            lead.stage = stage;
            lead.updatedAt = new Date().toISOString();
            if (stage === 'Угода') {
                lead.status = 'won';
                lead.closedAt = new Date().toISOString();
                lead.probability = 100;
            } else if (stage === 'Втрачено') {
                lead.status = 'lost';
                lead.probability = 0;
            } else {
                lead.status = 'active';
            }
            addTimelineEntry(lead, `Стадія змінена з ${previousStage} на ${stage}`);
            logActivity(`Лід ${lead.name} переміщено на етап ${stage}.`, 'stage', lead.id);
            saveData();
            renderPipeline();
            renderDashboard();
            renderAnalytics();
            if (activeLeadId === lead.id) {
                renderLeadDetails(lead.id);
            }
        }
        function openLeadDetails(leadId) {
            activeLeadId = leadId;
            renderLeadDetails(leadId);
            openModal('leadDetailsModal');
        }

        function renderLeadDetails(leadId) {
            const lead = crmData.leads.find(item => item.id === leadId);
            if (!lead) return;
            document.getElementById('leadDetailsTitle').textContent = lead.name;
            const content = document.getElementById('leadDetailsContent');
            const contact = lead.contact || {};
            const relatedTasks = crmData.tasks.filter(task => task.relatedLeadId === lead.id);
                const attachments = Array.isArray(lead.attachments) ? lead.attachments : [];
                const expectedCloseLabel = lead.expectedClose ? `${formatDate(lead.expectedClose, { day: '2-digit', month: 'short', year: 'numeric' })}` : '—';
                const forecastValue = formatCurrency(Math.round((Number(lead.value) || 0) * ((Number(lead.probability) || 0) / 100)));
                const sourceLabel = getLeadSourceLabel(lead.source);
                const qualificationLabel = getLeadQualificationLabel(lead.qualification);
                const attachmentsMarkup = attachments.length ? `
                    <div class="attachment-list">
                        ${attachments.map(file => {
                        const safeName = escapeHtml(file.name || 'Файл');
                        const downloadName = (file.name || 'file').replace(/["<>]/g, '');
                        const safeRelativePath = file.path && file.path !== file.name ? escapeHtml(file.path) : '';
                        const metaParts = [];
                        if (safeRelativePath) {
                            metaParts.push(safeRelativePath);
                        }
                        metaParts.push(formatBytes(Number(file.size) || 0));
                        const metaText = metaParts.filter(Boolean).join(' • ');
                        const hasData = typeof file.dataUrl === 'string' && file.dataUrl.startsWith('data:');
                        const icon = getAttachmentIcon(file.type);
                        const linkAttributes = hasData
                            ? `href="${file.dataUrl}" download="${downloadName}" target="_blank" rel="noopener"`
                            : 'href="#" onclick="return false;"';
                        return `
                            <a class="attachment-item" ${linkAttributes}>
                                <div class="attachment-icon"><i class="fa-solid ${icon}"></i></div>
                                <div class="attachment-details">
                                    <strong>${safeName}</strong>
                                    <div class="attachment-meta">${metaText}</div>
                                </div>
                                <i class="fa-solid fa-download"></i>
                            </a>
                        `;
                    }).join('')}
                </div>
            ` : '<span class="metric-sub">Файли ще не додані</span>';

                content.innerHTML = `
                    <div class="lead-highlights">
                        <div class="highlight-card">
                            <div class="highlight-label">Вартість</div>
                            <div class="highlight-value">${formatCurrency(lead.value)}</div>
                            <div class="metric-sub">Ймовірність ${lead.probability}%</div>
                        </div>
                        <div class="highlight-card">
                            <div class="highlight-label">Стадія</div>
                            <div class="highlight-value">${lead.stage}</div>
                            <div class="metric-sub">Оновлено ${formatRelativeTime(lead.updatedAt)}</div>
                        </div>
                        <div class="highlight-card">
                            <div class="highlight-label">Менеджер</div>
                            <div class="highlight-value">${lead.owner}</div>
                            <div class="metric-sub">Створено ${formatDate(lead.createdAt)}</div>
                        </div>
                        <div class="highlight-card">
                            <div class="highlight-label">Готовність</div>
                            <div class="highlight-value">${lead.score}%</div>
                            <div class="metric-sub">Канал: ${escapeHtml(sourceLabel)}</div>
                        </div>
                    </div>

                    <div class="lead-columns">
                    <div class="card">
                        <h3>Інформація про угоду</h3>
                        <div class="info-grid">
                            <div class="info-item">
                                <div class="info-label">Компанія</div>
                                <div class="info-value">${lead.company}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Контакт</div>
                                <div class="info-value">${contact.person || '—'}${contact.email ? `<br><span class="metric-sub">${contact.email}</span>` : ''}${contact.phone ? `<br><span class="metric-sub">${contact.phone}</span>` : ''}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Етап</div>
                                <select id="leadStageSelect" style="margin-top:6px;">
                                    ${STAGES.map(stage => `<option value="${stage}" ${stage === lead.stage ? 'selected' : ''}>${stage}</option>`).join('')}
                                </select>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Ймовірність</div>
                                <div class="probability-control">
                                    <input type="range" id="leadProbabilityRange" min="0" max="100" step="5" value="${lead.probability}">
                                    <span class="probability-value" id="leadProbabilityValue">${lead.probability}%</span>
                                </div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Джерело</div>
                                <div class="info-value">${escapeHtml(sourceLabel)}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Кваліфікація</div>
                                <div class="info-value">${escapeHtml(qualificationLabel)}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Очікуване закриття</div>
                                <div class="info-value">${escapeHtml(expectedCloseLabel)}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Прогнозована вартість</div>
                                <div class="info-value">${forecastValue}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Мітки</div>
                                <div class="chips">${lead.tags && lead.tags.length ? lead.tags.map(tag => `<span class="chip">${tag}</span>`).join('') : '—'}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Вкладення</div>
                                <div class="info-value">${attachmentsMarkup}</div>
                            </div>
                        </div>
                    </div>
                    <div class="card">
                        <h3>Примітки</h3>
                        <div class="notes-list" id="leadNotesList">
                            ${lead.notes && lead.notes.length ? lead.notes.map(note => `
                                <div class="note-item">
                                    <div>${note.text}</div>
                                    <div class="note-meta">${note.author || 'CRM'} • ${formatDate(note.date)}</div>
                                </div>
                            `).join('') : '<div class="empty-state">Ще немає приміток</div>'}
                        </div>
                        <form id="leadNoteForm" class="form-group full" style="margin-top:16px;">
                            <label for="leadNoteText">Додати примітку</label>
                            <textarea id="leadNoteText" required placeholder="Що зроблено? Які наступні кроки?"></textarea>
                            <div class="modal-actions" style="justify-content:flex-start;">
                                <button type="submit" class="btn btn-small-primary">Зберегти примітку</button>
                            </div>
                        </form>
                    </div>
                </div>

                <div class="lead-columns">
                    <div class="card">
                        <div class="section-header" style="margin-bottom:12px;">
                            <div>
                                <h3>Завдання по угоді</h3>
                                <p>${relatedTasks.length} завдань</p>
                            </div>
                            <button class="btn btn-small-primary" id="addLeadTaskBtn"><i class="fa-solid fa-circle-plus"></i> Нове завдання</button>
                        </div>
                        <div class="task-items">
                            ${relatedTasks.length ? relatedTasks.map(task => `
                                <div class="task-card" data-task-id="${task.id}">
                                    <div class="task-header">
                                        <span class="priority priority-${task.priority}">${task.priority === 'high' ? 'Високий' : task.priority === 'medium' ? 'Середній' : 'Низький'}</span>
                                        <span class="metric-sub">${task.status === 'done' ? 'виконано' : task.status === 'inProgress' ? 'в роботі' : 'до виконання'}</span>
                                    </div>
                                    <div class="task-title">${task.title}</div>
                                    <div class="task-meta">
                                        <span><i class="fa-regular fa-calendar"></i> ${formatDate(task.dueDate)}</span>
                                        <span><i class="fa-regular fa-user"></i> ${task.owner}</span>
                                    </div>
                                </div>
                            `).join('') : '<div class="empty-state">Завдання ще не додані</div>'}
                        </div>
                    </div>
                    <div class="card">
                        <h3>Хронологія</h3>
                        <div class="timeline-list">
                            ${lead.timeline && lead.timeline.length ? lead.timeline.slice(0, 8).map(item => `
                                <div class="timeline-entry">
                                    <strong>${escapeHtml(item.text)}</strong>
                                    <span>${formatRelativeTime(item.date)}</span>
                                </div>
                            `).join('') : '<div class="empty-state">Історія поки порожня</div>'}
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('leadStageSelect').addEventListener('change', event => {
                moveLeadToStage(lead.id, event.target.value);
            });

            const probabilityRange = document.getElementById('leadProbabilityRange');
            const probabilityValue = document.getElementById('leadProbabilityValue');
            probabilityRange.addEventListener('input', event => {
                probabilityValue.textContent = `${event.target.value}%`;
            });
            probabilityRange.addEventListener('change', event => {
                updateLeadProbability(lead.id, Number(event.target.value));
            });

            document.getElementById('leadNoteForm').addEventListener('submit', event => {
                event.preventDefault();
                const text = document.getElementById('leadNoteText').value.trim();
                if (!text) return;
                lead.notes.unshift({ id: generateId('note'), text, author: 'Ви', date: new Date().toISOString() });
                addTimelineEntry(lead, `Нова примітка: ${text.slice(0, 80)}`);
                logActivity(`Додано примітку до ${lead.name}.`, 'note', lead.id);
                saveData();
                renderLeadDetails(lead.id);
                renderActivityTimeline();
            });

            document.getElementById('addLeadTaskBtn').addEventListener('click', () => openTaskModal(lead.id));
        }

        function updateLeadProbability(leadId, probability) {
            const lead = crmData.leads.find(item => item.id === leadId);
            if (!lead) return;
            lead.probability = probability;
            lead.updatedAt = new Date().toISOString();
            addTimelineEntry(lead, `Ймовірність змінена на ${probability}%`);
            logActivity(`Оновлено прогноз для ${lead.name} (${probability}%).`, 'note', lead.id);
            saveData();
            renderPipeline();
            renderDashboard();
            renderForecastCard(
                crmData.leads.filter(l => l.stage !== 'Втрачено').reduce((sum, l) => sum + l.value, 0),
                crmData.leads.filter(l => l.stage !== 'Втрачено').reduce((sum, l) => sum + l.value * (l.probability / 100), 0)
            );
            renderAnalytics();
        }

        function escapeHtml(value) {
            if (typeof value !== 'string') {
                return '';
            }
            return value
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function formatCurrency(value, compact = false) {
            if (!Number.isFinite(value)) return '0 ₴';
            return new Intl.NumberFormat('uk-UA', {
                style: 'currency',
                currency: 'UAH',
                maximumFractionDigits: 0,
                notation: compact ? 'compact' : 'standard'
            }).format(value);
        }

        function formatDate(dateInput, options = { day: '2-digit', month: 'short' }) {
            if (!dateInput) return '—';
            const date = new Date(dateInput);
            if (Number.isNaN(date.getTime())) return '—';
            return new Intl.DateTimeFormat('uk-UA', options).format(date);
        }

        function formatTime(dateInput) {
            const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
            if (Number.isNaN(date.getTime())) return '';
            return new Intl.DateTimeFormat('uk-UA', { hour: '2-digit', minute: '2-digit' }).format(date);
        }

        function formatBytes(bytes) {
            const value = Number(bytes);
            if (!Number.isFinite(value) || value <= 0) {
                return '0 Б';
            }

            const units = ['Б', 'КБ', 'МБ', 'ГБ', 'ТБ'];
            let size = value;
            let index = 0;

            while (size >= 1024 && index < units.length - 1) {
                size /= 1024;
                index += 1;
            }

            const formatted = size >= 10 || index === 0 ? size.toFixed(0) : size.toFixed(1);
            return `${formatted} ${units[index]}`;
        }

        function formatIntegerDisplay(value) {
            const number = Number(value);
            if (!Number.isFinite(number) || number <= 0) {
                return '0';
            }
            return Math.round(number).toLocaleString('uk-UA');
        }

        function formatHours(hours) {
            if (!Number.isFinite(hours) || hours <= 0) {
                return '—';
            }
            if (hours < 1) {
                return `${Math.round(hours * 60)} хв`;
            }
            if (hours < 10) {
                return `${hours.toFixed(1)} год`;
            }
            return `${Math.round(hours)} год`;
        }

        function formatDurationFromSeconds(seconds) {
            const value = Number(seconds);
            if (!Number.isFinite(value) || value <= 0) {
                return '—';
            }
            if (value < 60) {
                return `${Math.round(value)} с`;
            }
            const minutes = Math.floor(value / 60);
            const remainingSeconds = Math.round(value % 60);
            if (minutes < 60) {
                return `${minutes} хв${remainingSeconds ? ` ${remainingSeconds} с` : ''}`.trim();
            }
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${hours} год${mins ? ` ${mins} хв` : ''}`.trim();
        }

        function formatRelativeTime(dateInput) {
            if (!dateInput) return '';
            const date = new Date(dateInput);
            if (Number.isNaN(date.getTime())) return '';
            const now = new Date();
            const diffSeconds = Math.round((date.getTime() - now.getTime()) / 1000);
            const rtf = new Intl.RelativeTimeFormat('uk-UA', { numeric: 'auto' });
            const divisions = [
                { amount: 60, unit: 'second' },
                { amount: 60, unit: 'minute' },
                { amount: 24, unit: 'hour' },
                { amount: 7, unit: 'day' },
                { amount: 4.34524, unit: 'week' },
                { amount: 12, unit: 'month' },
                { amount: Number.POSITIVE_INFINITY, unit: 'year' }
            ];
            let duration = diffSeconds;
            for (const division of divisions) {
                if (Math.abs(duration) < division.amount) {
                    return rtf.format(Math.round(duration), division.unit);
                }
                duration /= division.amount;
            }
            return '';
        }

        function daysBetween(startDate, endDate = new Date()) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            const diff = end.getTime() - start.getTime();
            return Math.max(0, Math.round(diff / (1000 * 60 * 60 * 24)));
        }

        function hoursBetween(startDate, endDate = new Date()) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
                return 0;
            }
            const diff = end.getTime() - start.getTime();
            return Math.max(0, diff / (1000 * 60 * 60));
        }

        function isSameDay(dateA, dateB) {
            return dateA.getFullYear() === dateB.getFullYear() && dateA.getMonth() === dateB.getMonth() && dateA.getDate() === dateB.getDate();
        }

        function isOverdue(dateInput) {
            if (!dateInput) return false;
            const due = new Date(dateInput);
            if (Number.isNaN(due.getTime())) return false;
            const now = new Date();
            if (isSameDay(due, now)) {
                return false;
            }
            return due.getTime() < now.getTime();
        }

        function isDueWithinDays(dateInput, days) {
            if (!dateInput || !Number.isFinite(days) || days < 0) return false;
            const due = new Date(dateInput);
            if (Number.isNaN(due.getTime())) return false;
            const now = new Date();
            const diff = due.getTime() - now.getTime();
            const diffDays = Math.ceil(diff / (1000 * 60 * 60 * 24));
            return diffDays >= 0 && diffDays <= days;
        }

        function isDueToday(dateInput) {
            if (!dateInput) return false;
            const due = new Date(dateInput);
            const today = new Date();
            return isSameDay(due, today);
        }
    </script>
</body>
</html>
